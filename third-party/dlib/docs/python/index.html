<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Classes &mdash; dlib  documentation</title>
    
    <link rel="stylesheet" href="_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="dlib  documentation" href="#" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="#">dlib  documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <a class="reference external image-reference" href="http://dlib.net"><img alt="Dlib C++ Library" src="_images/dlib-logo.png" /></a>
<p>Dlib is principally a C++ library, however, you can use a number of its tools
from python applications.  This page documents the python API for working with
these dlib tools.  If you haven&#8217;t done so already, you should probably look at
the python example programs first before consulting this reference.  These
example programs are little mini-tutorials for using dlib from python.  They
are listed on the left of the main dlib web page.</p>
<div class="section" id="classes">
<h1>Classes<a class="headerlink" href="#classes" title="Permalink to this headline">¶</a></h1>
<ul class="simple">
<li><a class="reference internal" href="#dlib.array" title="dlib.array"><code class="xref py py-class docutils literal"><span class="pre">dlib.array</span></code></a></li>
<li><a class="reference internal" href="#dlib.cca_outputs" title="dlib.cca_outputs"><code class="xref py py-class docutils literal"><span class="pre">dlib.cca_outputs</span></code></a></li>
<li><a class="reference internal" href="#dlib.chip_details" title="dlib.chip_details"><code class="xref py py-class docutils literal"><span class="pre">dlib.chip_details</span></code></a></li>
<li><a class="reference internal" href="#dlib.chip_dims" title="dlib.chip_dims"><code class="xref py py-class docutils literal"><span class="pre">dlib.chip_dims</span></code></a></li>
<li><a class="reference internal" href="#dlib.cnn_face_detection_model_v1" title="dlib.cnn_face_detection_model_v1"><code class="xref py py-class docutils literal"><span class="pre">dlib.cnn_face_detection_model_v1</span></code></a></li>
<li><a class="reference internal" href="#dlib.correlation_tracker" title="dlib.correlation_tracker"><code class="xref py py-class docutils literal"><span class="pre">dlib.correlation_tracker</span></code></a></li>
<li><a class="reference internal" href="#dlib.dpoint" title="dlib.dpoint"><code class="xref py py-class docutils literal"><span class="pre">dlib.dpoint</span></code></a></li>
<li><a class="reference internal" href="#dlib.dpoints" title="dlib.dpoints"><code class="xref py py-class docutils literal"><span class="pre">dlib.dpoints</span></code></a></li>
<li><a class="reference internal" href="#dlib.drectangle" title="dlib.drectangle"><code class="xref py py-class docutils literal"><span class="pre">dlib.drectangle</span></code></a></li>
<li><a class="reference internal" href="#dlib.face_recognition_model_v1" title="dlib.face_recognition_model_v1"><code class="xref py py-class docutils literal"><span class="pre">dlib.face_recognition_model_v1</span></code></a></li>
<li><a class="reference internal" href="#dlib.fhog_object_detector" title="dlib.fhog_object_detector"><code class="xref py py-class docutils literal"><span class="pre">dlib.fhog_object_detector</span></code></a></li>
<li><a class="reference internal" href="#dlib.full_object_detection" title="dlib.full_object_detection"><code class="xref py py-class docutils literal"><span class="pre">dlib.full_object_detection</span></code></a></li>
<li><a class="reference internal" href="#dlib.full_object_detections" title="dlib.full_object_detections"><code class="xref py py-class docutils literal"><span class="pre">dlib.full_object_detections</span></code></a></li>
<li><a class="reference internal" href="#dlib.function_evaluation" title="dlib.function_evaluation"><code class="xref py py-class docutils literal"><span class="pre">dlib.function_evaluation</span></code></a></li>
<li><a class="reference internal" href="#dlib.function_evaluation_request" title="dlib.function_evaluation_request"><code class="xref py py-class docutils literal"><span class="pre">dlib.function_evaluation_request</span></code></a></li>
<li><a class="reference internal" href="#dlib.function_spec" title="dlib.function_spec"><code class="xref py py-class docutils literal"><span class="pre">dlib.function_spec</span></code></a></li>
<li><a class="reference internal" href="#dlib.global_function_search" title="dlib.global_function_search"><code class="xref py py-class docutils literal"><span class="pre">dlib.global_function_search</span></code></a></li>
<li><a class="reference internal" href="#dlib.hough_transform" title="dlib.hough_transform"><code class="xref py py-class docutils literal"><span class="pre">dlib.hough_transform</span></code></a></li>
<li><a class="reference internal" href="#dlib.image_gradients" title="dlib.image_gradients"><code class="xref py py-class docutils literal"><span class="pre">dlib.image_gradients</span></code></a></li>
<li><a class="reference internal" href="#dlib.image_window" title="dlib.image_window"><code class="xref py py-class docutils literal"><span class="pre">dlib.image_window</span></code></a></li>
<li><a class="reference internal" href="#dlib.line" title="dlib.line"><code class="xref py py-class docutils literal"><span class="pre">dlib.line</span></code></a></li>
<li><a class="reference internal" href="#dlib.matrix" title="dlib.matrix"><code class="xref py py-class docutils literal"><span class="pre">dlib.matrix</span></code></a></li>
<li><a class="reference internal" href="#dlib.mmod_rectangle" title="dlib.mmod_rectangle"><code class="xref py py-class docutils literal"><span class="pre">dlib.mmod_rectangle</span></code></a></li>
<li><a class="reference internal" href="#dlib.mmod_rectangles" title="dlib.mmod_rectangles"><code class="xref py py-class docutils literal"><span class="pre">dlib.mmod_rectangles</span></code></a></li>
<li><a class="reference internal" href="#dlib.mmod_rectangless" title="dlib.mmod_rectangless"><code class="xref py py-class docutils literal"><span class="pre">dlib.mmod_rectangless</span></code></a></li>
<li><a class="reference internal" href="#dlib.no_convex_quadrilateral" title="dlib.no_convex_quadrilateral"><code class="xref py py-class docutils literal"><span class="pre">dlib.no_convex_quadrilateral</span></code></a></li>
<li><a class="reference internal" href="#dlib.pair" title="dlib.pair"><code class="xref py py-class docutils literal"><span class="pre">dlib.pair</span></code></a></li>
<li><a class="reference internal" href="#dlib.point" title="dlib.point"><code class="xref py py-class docutils literal"><span class="pre">dlib.point</span></code></a></li>
<li><a class="reference internal" href="#dlib.point_transform_projective" title="dlib.point_transform_projective"><code class="xref py py-class docutils literal"><span class="pre">dlib.point_transform_projective</span></code></a></li>
<li><a class="reference internal" href="#dlib.points" title="dlib.points"><code class="xref py py-class docutils literal"><span class="pre">dlib.points</span></code></a></li>
<li><a class="reference internal" href="#dlib.pyramid_down" title="dlib.pyramid_down"><code class="xref py py-class docutils literal"><span class="pre">dlib.pyramid_down</span></code></a></li>
<li><a class="reference internal" href="#dlib.range" title="dlib.range"><code class="xref py py-class docutils literal"><span class="pre">dlib.range</span></code></a></li>
<li><a class="reference internal" href="#dlib.ranges" title="dlib.ranges"><code class="xref py py-class docutils literal"><span class="pre">dlib.ranges</span></code></a></li>
<li><a class="reference internal" href="#dlib.rangess" title="dlib.rangess"><code class="xref py py-class docutils literal"><span class="pre">dlib.rangess</span></code></a></li>
<li><a class="reference internal" href="#dlib.ranking_pair" title="dlib.ranking_pair"><code class="xref py py-class docutils literal"><span class="pre">dlib.ranking_pair</span></code></a></li>
<li><a class="reference internal" href="#dlib.ranking_pairs" title="dlib.ranking_pairs"><code class="xref py py-class docutils literal"><span class="pre">dlib.ranking_pairs</span></code></a></li>
<li><a class="reference internal" href="#dlib.rect_filter" title="dlib.rect_filter"><code class="xref py py-class docutils literal"><span class="pre">dlib.rect_filter</span></code></a></li>
<li><a class="reference internal" href="#dlib.rectangle" title="dlib.rectangle"><code class="xref py py-class docutils literal"><span class="pre">dlib.rectangle</span></code></a></li>
<li><a class="reference internal" href="#dlib.rectangles" title="dlib.rectangles"><code class="xref py py-class docutils literal"><span class="pre">dlib.rectangles</span></code></a></li>
<li><a class="reference internal" href="#dlib.rectangless" title="dlib.rectangless"><code class="xref py py-class docutils literal"><span class="pre">dlib.rectangless</span></code></a></li>
<li><a class="reference internal" href="#dlib.rgb_pixel" title="dlib.rgb_pixel"><code class="xref py py-class docutils literal"><span class="pre">dlib.rgb_pixel</span></code></a></li>
<li><a class="reference internal" href="#dlib.rvm_trainer_histogram_intersection" title="dlib.rvm_trainer_histogram_intersection"><code class="xref py py-class docutils literal"><span class="pre">dlib.rvm_trainer_histogram_intersection</span></code></a></li>
<li><a class="reference internal" href="#dlib.rvm_trainer_linear" title="dlib.rvm_trainer_linear"><code class="xref py py-class docutils literal"><span class="pre">dlib.rvm_trainer_linear</span></code></a></li>
<li><a class="reference internal" href="#dlib.rvm_trainer_radial_basis" title="dlib.rvm_trainer_radial_basis"><code class="xref py py-class docutils literal"><span class="pre">dlib.rvm_trainer_radial_basis</span></code></a></li>
<li><a class="reference internal" href="#dlib.rvm_trainer_sparse_histogram_intersection" title="dlib.rvm_trainer_sparse_histogram_intersection"><code class="xref py py-class docutils literal"><span class="pre">dlib.rvm_trainer_sparse_histogram_intersection</span></code></a></li>
<li><a class="reference internal" href="#dlib.rvm_trainer_sparse_linear" title="dlib.rvm_trainer_sparse_linear"><code class="xref py py-class docutils literal"><span class="pre">dlib.rvm_trainer_sparse_linear</span></code></a></li>
<li><a class="reference internal" href="#dlib.rvm_trainer_sparse_radial_basis" title="dlib.rvm_trainer_sparse_radial_basis"><code class="xref py py-class docutils literal"><span class="pre">dlib.rvm_trainer_sparse_radial_basis</span></code></a></li>
<li><a class="reference internal" href="#dlib.segmenter_params" title="dlib.segmenter_params"><code class="xref py py-class docutils literal"><span class="pre">dlib.segmenter_params</span></code></a></li>
<li><a class="reference internal" href="#dlib.segmenter_test" title="dlib.segmenter_test"><code class="xref py py-class docutils literal"><span class="pre">dlib.segmenter_test</span></code></a></li>
<li><a class="reference internal" href="#dlib.segmenter_type" title="dlib.segmenter_type"><code class="xref py py-class docutils literal"><span class="pre">dlib.segmenter_type</span></code></a></li>
<li><a class="reference internal" href="#dlib.shape_predictor" title="dlib.shape_predictor"><code class="xref py py-class docutils literal"><span class="pre">dlib.shape_predictor</span></code></a></li>
<li><a class="reference internal" href="#dlib.shape_predictor_training_options" title="dlib.shape_predictor_training_options"><code class="xref py py-class docutils literal"><span class="pre">dlib.shape_predictor_training_options</span></code></a></li>
<li><a class="reference internal" href="#dlib.simple_object_detector" title="dlib.simple_object_detector"><code class="xref py py-class docutils literal"><span class="pre">dlib.simple_object_detector</span></code></a></li>
<li><a class="reference internal" href="#dlib.simple_object_detector_training_options" title="dlib.simple_object_detector_training_options"><code class="xref py py-class docutils literal"><span class="pre">dlib.simple_object_detector_training_options</span></code></a></li>
<li><a class="reference internal" href="#dlib.simple_test_results" title="dlib.simple_test_results"><code class="xref py py-class docutils literal"><span class="pre">dlib.simple_test_results</span></code></a></li>
<li><a class="reference internal" href="#dlib.sparse_ranking_pair" title="dlib.sparse_ranking_pair"><code class="xref py py-class docutils literal"><span class="pre">dlib.sparse_ranking_pair</span></code></a></li>
<li><a class="reference internal" href="#dlib.sparse_ranking_pairs" title="dlib.sparse_ranking_pairs"><code class="xref py py-class docutils literal"><span class="pre">dlib.sparse_ranking_pairs</span></code></a></li>
<li><a class="reference internal" href="#dlib.sparse_vector" title="dlib.sparse_vector"><code class="xref py py-class docutils literal"><span class="pre">dlib.sparse_vector</span></code></a></li>
<li><a class="reference internal" href="#dlib.sparse_vectors" title="dlib.sparse_vectors"><code class="xref py py-class docutils literal"><span class="pre">dlib.sparse_vectors</span></code></a></li>
<li><a class="reference internal" href="#dlib.sparse_vectorss" title="dlib.sparse_vectorss"><code class="xref py py-class docutils literal"><span class="pre">dlib.sparse_vectorss</span></code></a></li>
<li><a class="reference internal" href="#dlib.svm_c_trainer_histogram_intersection" title="dlib.svm_c_trainer_histogram_intersection"><code class="xref py py-class docutils literal"><span class="pre">dlib.svm_c_trainer_histogram_intersection</span></code></a></li>
<li><a class="reference internal" href="#dlib.svm_c_trainer_linear" title="dlib.svm_c_trainer_linear"><code class="xref py py-class docutils literal"><span class="pre">dlib.svm_c_trainer_linear</span></code></a></li>
<li><a class="reference internal" href="#dlib.svm_c_trainer_radial_basis" title="dlib.svm_c_trainer_radial_basis"><code class="xref py py-class docutils literal"><span class="pre">dlib.svm_c_trainer_radial_basis</span></code></a></li>
<li><a class="reference internal" href="#dlib.svm_c_trainer_sparse_histogram_intersection" title="dlib.svm_c_trainer_sparse_histogram_intersection"><code class="xref py py-class docutils literal"><span class="pre">dlib.svm_c_trainer_sparse_histogram_intersection</span></code></a></li>
<li><a class="reference internal" href="#dlib.svm_c_trainer_sparse_linear" title="dlib.svm_c_trainer_sparse_linear"><code class="xref py py-class docutils literal"><span class="pre">dlib.svm_c_trainer_sparse_linear</span></code></a></li>
<li><a class="reference internal" href="#dlib.svm_c_trainer_sparse_radial_basis" title="dlib.svm_c_trainer_sparse_radial_basis"><code class="xref py py-class docutils literal"><span class="pre">dlib.svm_c_trainer_sparse_radial_basis</span></code></a></li>
<li><a class="reference internal" href="#dlib.svm_rank_trainer" title="dlib.svm_rank_trainer"><code class="xref py py-class docutils literal"><span class="pre">dlib.svm_rank_trainer</span></code></a></li>
<li><a class="reference internal" href="#dlib.svm_rank_trainer_sparse" title="dlib.svm_rank_trainer_sparse"><code class="xref py py-class docutils literal"><span class="pre">dlib.svm_rank_trainer_sparse</span></code></a></li>
<li><a class="reference internal" href="#dlib.vector" title="dlib.vector"><code class="xref py py-class docutils literal"><span class="pre">dlib.vector</span></code></a></li>
<li><a class="reference internal" href="#dlib.vectors" title="dlib.vectors"><code class="xref py py-class docutils literal"><span class="pre">dlib.vectors</span></code></a></li>
<li><a class="reference internal" href="#dlib.vectorss" title="dlib.vectorss"><code class="xref py py-class docutils literal"><span class="pre">dlib.vectorss</span></code></a></li>
<li><a class="reference internal" href="#dlib.image_dataset_metadata.box" title="dlib.image_dataset_metadata.box"><code class="xref py py-class docutils literal"><span class="pre">dlib.image_dataset_metadata.box</span></code></a></li>
<li><a class="reference internal" href="#dlib.image_dataset_metadata.boxes" title="dlib.image_dataset_metadata.boxes"><code class="xref py py-class docutils literal"><span class="pre">dlib.image_dataset_metadata.boxes</span></code></a></li>
<li><a class="reference internal" href="#dlib.image_dataset_metadata.dataset" title="dlib.image_dataset_metadata.dataset"><code class="xref py py-class docutils literal"><span class="pre">dlib.image_dataset_metadata.dataset</span></code></a></li>
<li><a class="reference internal" href="#dlib.image_dataset_metadata.image" title="dlib.image_dataset_metadata.image"><code class="xref py py-class docutils literal"><span class="pre">dlib.image_dataset_metadata.image</span></code></a></li>
<li><a class="reference internal" href="#dlib.image_dataset_metadata.images" title="dlib.image_dataset_metadata.images"><code class="xref py py-class docutils literal"><span class="pre">dlib.image_dataset_metadata.images</span></code></a></li>
<li><a class="reference internal" href="#dlib.image_dataset_metadata.parts" title="dlib.image_dataset_metadata.parts"><code class="xref py py-class docutils literal"><span class="pre">dlib.image_dataset_metadata.parts</span></code></a></li>
</ul>
</div>
<div class="section" id="functions">
<h1>Functions<a class="headerlink" href="#functions" title="Permalink to this headline">¶</a></h1>
<ul class="simple">
<li><code class="xref py py-func docutils literal"><span class="pre">dlib.DLIB_USE_BLAS()</span></code></li>
<li><code class="xref py py-func docutils literal"><span class="pre">dlib.DLIB_USE_CUDA()</span></code></li>
<li><code class="xref py py-func docutils literal"><span class="pre">dlib.DLIB_USE_LAPACK()</span></code></li>
<li><code class="xref py py-func docutils literal"><span class="pre">dlib.USE_AVX_INSTRUCTIONS()</span></code></li>
<li><code class="xref py py-func docutils literal"><span class="pre">dlib.USE_NEON_INSTRUCTIONS()</span></code></li>
<li><a class="reference internal" href="#dlib.angle_between_lines" title="dlib.angle_between_lines"><code class="xref py py-func docutils literal"><span class="pre">dlib.angle_between_lines()</span></code></a></li>
<li><a class="reference internal" href="#dlib.apply_cca_transform" title="dlib.apply_cca_transform"><code class="xref py py-func docutils literal"><span class="pre">dlib.apply_cca_transform()</span></code></a></li>
<li><a class="reference internal" href="#dlib.as_grayscale" title="dlib.as_grayscale"><code class="xref py py-func docutils literal"><span class="pre">dlib.as_grayscale()</span></code></a></li>
<li><a class="reference internal" href="#dlib.assignment_cost" title="dlib.assignment_cost"><code class="xref py py-func docutils literal"><span class="pre">dlib.assignment_cost()</span></code></a></li>
<li><a class="reference internal" href="#dlib.auto_train_rbf_classifier" title="dlib.auto_train_rbf_classifier"><code class="xref py py-func docutils literal"><span class="pre">dlib.auto_train_rbf_classifier()</span></code></a></li>
<li><a class="reference internal" href="#dlib.cca" title="dlib.cca"><code class="xref py py-func docutils literal"><span class="pre">dlib.cca()</span></code></a></li>
<li><a class="reference internal" href="#dlib.center" title="dlib.center"><code class="xref py py-func docutils literal"><span class="pre">dlib.center()</span></code></a></li>
<li><a class="reference internal" href="#dlib.centered_rect" title="dlib.centered_rect"><code class="xref py py-func docutils literal"><span class="pre">dlib.centered_rect()</span></code></a></li>
<li><a class="reference internal" href="#dlib.centered_rects" title="dlib.centered_rects"><code class="xref py py-func docutils literal"><span class="pre">dlib.centered_rects()</span></code></a></li>
<li><a class="reference internal" href="#dlib.chinese_whispers" title="dlib.chinese_whispers"><code class="xref py py-func docutils literal"><span class="pre">dlib.chinese_whispers()</span></code></a></li>
<li><a class="reference internal" href="#dlib.chinese_whispers_clustering" title="dlib.chinese_whispers_clustering"><code class="xref py py-func docutils literal"><span class="pre">dlib.chinese_whispers_clustering()</span></code></a></li>
<li><a class="reference internal" href="#dlib.convert_image" title="dlib.convert_image"><code class="xref py py-func docutils literal"><span class="pre">dlib.convert_image()</span></code></a></li>
<li><a class="reference internal" href="#dlib.convert_image_scaled" title="dlib.convert_image_scaled"><code class="xref py py-func docutils literal"><span class="pre">dlib.convert_image_scaled()</span></code></a></li>
<li><a class="reference internal" href="#dlib.count_points_between_lines" title="dlib.count_points_between_lines"><code class="xref py py-func docutils literal"><span class="pre">dlib.count_points_between_lines()</span></code></a></li>
<li><a class="reference internal" href="#dlib.count_points_on_side_of_line" title="dlib.count_points_on_side_of_line"><code class="xref py py-func docutils literal"><span class="pre">dlib.count_points_on_side_of_line()</span></code></a></li>
<li><a class="reference internal" href="#dlib.count_steps_without_decrease" title="dlib.count_steps_without_decrease"><code class="xref py py-func docutils literal"><span class="pre">dlib.count_steps_without_decrease()</span></code></a></li>
<li><a class="reference internal" href="#dlib.count_steps_without_decrease_robust" title="dlib.count_steps_without_decrease_robust"><code class="xref py py-func docutils literal"><span class="pre">dlib.count_steps_without_decrease_robust()</span></code></a></li>
<li><a class="reference internal" href="#dlib.cross_validate_ranking_trainer" title="dlib.cross_validate_ranking_trainer"><code class="xref py py-func docutils literal"><span class="pre">dlib.cross_validate_ranking_trainer()</span></code></a></li>
<li><a class="reference internal" href="#dlib.cross_validate_sequence_segmenter" title="dlib.cross_validate_sequence_segmenter"><code class="xref py py-func docutils literal"><span class="pre">dlib.cross_validate_sequence_segmenter()</span></code></a></li>
<li><a class="reference internal" href="#dlib.cross_validate_trainer" title="dlib.cross_validate_trainer"><code class="xref py py-func docutils literal"><span class="pre">dlib.cross_validate_trainer()</span></code></a></li>
<li><a class="reference internal" href="#dlib.cross_validate_trainer_threaded" title="dlib.cross_validate_trainer_threaded"><code class="xref py py-func docutils literal"><span class="pre">dlib.cross_validate_trainer_threaded()</span></code></a></li>
<li><a class="reference internal" href="#dlib.distance_to_line" title="dlib.distance_to_line"><code class="xref py py-func docutils literal"><span class="pre">dlib.distance_to_line()</span></code></a></li>
<li><a class="reference internal" href="#dlib.dot" title="dlib.dot"><code class="xref py py-func docutils literal"><span class="pre">dlib.dot()</span></code></a></li>
<li><a class="reference internal" href="#dlib.equalize_histogram" title="dlib.equalize_histogram"><code class="xref py py-func docutils literal"><span class="pre">dlib.equalize_histogram()</span></code></a></li>
<li><a class="reference internal" href="#dlib.extract_image_4points" title="dlib.extract_image_4points"><code class="xref py py-func docutils literal"><span class="pre">dlib.extract_image_4points()</span></code></a></li>
<li><a class="reference internal" href="#dlib.extract_image_chip" title="dlib.extract_image_chip"><code class="xref py py-func docutils literal"><span class="pre">dlib.extract_image_chip()</span></code></a></li>
<li><a class="reference internal" href="#dlib.extract_image_chips" title="dlib.extract_image_chips"><code class="xref py py-func docutils literal"><span class="pre">dlib.extract_image_chips()</span></code></a></li>
<li><a class="reference internal" href="#dlib.find_bright_keypoints" title="dlib.find_bright_keypoints"><code class="xref py py-func docutils literal"><span class="pre">dlib.find_bright_keypoints()</span></code></a></li>
<li><a class="reference internal" href="#dlib.find_bright_lines" title="dlib.find_bright_lines"><code class="xref py py-func docutils literal"><span class="pre">dlib.find_bright_lines()</span></code></a></li>
<li><a class="reference internal" href="#dlib.find_candidate_object_locations" title="dlib.find_candidate_object_locations"><code class="xref py py-func docutils literal"><span class="pre">dlib.find_candidate_object_locations()</span></code></a></li>
<li><a class="reference internal" href="#dlib.find_dark_keypoints" title="dlib.find_dark_keypoints"><code class="xref py py-func docutils literal"><span class="pre">dlib.find_dark_keypoints()</span></code></a></li>
<li><a class="reference internal" href="#dlib.find_dark_lines" title="dlib.find_dark_lines"><code class="xref py py-func docutils literal"><span class="pre">dlib.find_dark_lines()</span></code></a></li>
<li><a class="reference internal" href="#dlib.find_line_endpoints" title="dlib.find_line_endpoints"><code class="xref py py-func docutils literal"><span class="pre">dlib.find_line_endpoints()</span></code></a></li>
<li><a class="reference internal" href="#dlib.find_max_global" title="dlib.find_max_global"><code class="xref py py-func docutils literal"><span class="pre">dlib.find_max_global()</span></code></a></li>
<li><a class="reference internal" href="#dlib.find_min_global" title="dlib.find_min_global"><code class="xref py py-func docutils literal"><span class="pre">dlib.find_min_global()</span></code></a></li>
<li><a class="reference internal" href="#dlib.find_optimal_rect_filter" title="dlib.find_optimal_rect_filter"><code class="xref py py-func docutils literal"><span class="pre">dlib.find_optimal_rect_filter()</span></code></a></li>
<li><a class="reference internal" href="#dlib.find_peaks" title="dlib.find_peaks"><code class="xref py py-func docutils literal"><span class="pre">dlib.find_peaks()</span></code></a></li>
<li><a class="reference internal" href="#dlib.find_projective_transform" title="dlib.find_projective_transform"><code class="xref py py-func docutils literal"><span class="pre">dlib.find_projective_transform()</span></code></a></li>
<li><a class="reference internal" href="#dlib.gaussian_blur" title="dlib.gaussian_blur"><code class="xref py py-func docutils literal"><span class="pre">dlib.gaussian_blur()</span></code></a></li>
<li><a class="reference internal" href="#dlib.get_face_chip" title="dlib.get_face_chip"><code class="xref py py-func docutils literal"><span class="pre">dlib.get_face_chip()</span></code></a></li>
<li><a class="reference internal" href="#dlib.get_face_chips" title="dlib.get_face_chips"><code class="xref py py-func docutils literal"><span class="pre">dlib.get_face_chips()</span></code></a></li>
<li><a class="reference internal" href="#dlib.get_frontal_face_detector" title="dlib.get_frontal_face_detector"><code class="xref py py-func docutils literal"><span class="pre">dlib.get_frontal_face_detector()</span></code></a></li>
<li><a class="reference internal" href="#dlib.get_histogram" title="dlib.get_histogram"><code class="xref py py-func docutils literal"><span class="pre">dlib.get_histogram()</span></code></a></li>
<li><a class="reference internal" href="#dlib.get_rect" title="dlib.get_rect"><code class="xref py py-func docutils literal"><span class="pre">dlib.get_rect()</span></code></a></li>
<li><a class="reference internal" href="#dlib.grow_rect" title="dlib.grow_rect"><code class="xref py py-func docutils literal"><span class="pre">dlib.grow_rect()</span></code></a></li>
<li><a class="reference internal" href="#dlib.hit_enter_to_continue" title="dlib.hit_enter_to_continue"><code class="xref py py-func docutils literal"><span class="pre">dlib.hit_enter_to_continue()</span></code></a></li>
<li><a class="reference internal" href="#dlib.hysteresis_threshold" title="dlib.hysteresis_threshold"><code class="xref py py-func docutils literal"><span class="pre">dlib.hysteresis_threshold()</span></code></a></li>
<li><a class="reference internal" href="#dlib.intersect" title="dlib.intersect"><code class="xref py py-func docutils literal"><span class="pre">dlib.intersect()</span></code></a></li>
<li><a class="reference internal" href="#dlib.inv" title="dlib.inv"><code class="xref py py-func docutils literal"><span class="pre">dlib.inv()</span></code></a></li>
<li><a class="reference internal" href="#dlib.jet" title="dlib.jet"><code class="xref py py-func docutils literal"><span class="pre">dlib.jet()</span></code></a></li>
<li><a class="reference internal" href="#dlib.jitter_image" title="dlib.jitter_image"><code class="xref py py-func docutils literal"><span class="pre">dlib.jitter_image()</span></code></a></li>
<li><a class="reference internal" href="#dlib.label_connected_blobs" title="dlib.label_connected_blobs"><code class="xref py py-func docutils literal"><span class="pre">dlib.label_connected_blobs()</span></code></a></li>
<li><a class="reference internal" href="#dlib.label_connected_blobs_watershed" title="dlib.label_connected_blobs_watershed"><code class="xref py py-func docutils literal"><span class="pre">dlib.label_connected_blobs_watershed()</span></code></a></li>
<li><a class="reference internal" href="#dlib.length" title="dlib.length"><code class="xref py py-func docutils literal"><span class="pre">dlib.length()</span></code></a></li>
<li><a class="reference internal" href="#dlib.load_grayscale_image" title="dlib.load_grayscale_image"><code class="xref py py-func docutils literal"><span class="pre">dlib.load_grayscale_image()</span></code></a></li>
<li><a class="reference internal" href="#dlib.load_libsvm_formatted_data" title="dlib.load_libsvm_formatted_data"><code class="xref py py-func docutils literal"><span class="pre">dlib.load_libsvm_formatted_data()</span></code></a></li>
<li><a class="reference internal" href="#dlib.load_rgb_image" title="dlib.load_rgb_image"><code class="xref py py-func docutils literal"><span class="pre">dlib.load_rgb_image()</span></code></a></li>
<li><a class="reference internal" href="#dlib.make_bounding_box_regression_training_data" title="dlib.make_bounding_box_regression_training_data"><code class="xref py py-func docutils literal"><span class="pre">dlib.make_bounding_box_regression_training_data()</span></code></a></li>
<li><a class="reference internal" href="#dlib.make_sparse_vector" title="dlib.make_sparse_vector"><code class="xref py py-func docutils literal"><span class="pre">dlib.make_sparse_vector()</span></code></a></li>
<li><a class="reference internal" href="#dlib.max_cost_assignment" title="dlib.max_cost_assignment"><code class="xref py py-func docutils literal"><span class="pre">dlib.max_cost_assignment()</span></code></a></li>
<li><a class="reference internal" href="#dlib.max_index_plus_one" title="dlib.max_index_plus_one"><code class="xref py py-func docutils literal"><span class="pre">dlib.max_index_plus_one()</span></code></a></li>
<li><a class="reference internal" href="#dlib.max_point" title="dlib.max_point"><code class="xref py py-func docutils literal"><span class="pre">dlib.max_point()</span></code></a></li>
<li><a class="reference internal" href="#dlib.max_point_interpolated" title="dlib.max_point_interpolated"><code class="xref py py-func docutils literal"><span class="pre">dlib.max_point_interpolated()</span></code></a></li>
<li><a class="reference internal" href="#dlib.min_barrier_distance" title="dlib.min_barrier_distance"><code class="xref py py-func docutils literal"><span class="pre">dlib.min_barrier_distance()</span></code></a></li>
<li><a class="reference internal" href="#dlib.normalize_image_gradients" title="dlib.normalize_image_gradients"><code class="xref py py-func docutils literal"><span class="pre">dlib.normalize_image_gradients()</span></code></a></li>
<li><a class="reference internal" href="#dlib.num_separable_filters" title="dlib.num_separable_filters"><code class="xref py py-func docutils literal"><span class="pre">dlib.num_separable_filters()</span></code></a></li>
<li><a class="reference internal" href="#dlib.partition_pixels" title="dlib.partition_pixels"><code class="xref py py-func docutils literal"><span class="pre">dlib.partition_pixels()</span></code></a></li>
<li><a class="reference internal" href="#dlib.polygon_area" title="dlib.polygon_area"><code class="xref py py-func docutils literal"><span class="pre">dlib.polygon_area()</span></code></a></li>
<li><a class="reference internal" href="#dlib.probability_that_sequence_is_increasing" title="dlib.probability_that_sequence_is_increasing"><code class="xref py py-func docutils literal"><span class="pre">dlib.probability_that_sequence_is_increasing()</span></code></a></li>
<li><a class="reference internal" href="#dlib.randomly_color_image" title="dlib.randomly_color_image"><code class="xref py py-func docutils literal"><span class="pre">dlib.randomly_color_image()</span></code></a></li>
<li><a class="reference internal" href="#dlib.reduce" title="dlib.reduce"><code class="xref py py-func docutils literal"><span class="pre">dlib.reduce()</span></code></a></li>
<li><a class="reference internal" href="#dlib.remove_incoherent_edge_pixels" title="dlib.remove_incoherent_edge_pixels"><code class="xref py py-func docutils literal"><span class="pre">dlib.remove_incoherent_edge_pixels()</span></code></a></li>
<li><a class="reference internal" href="#dlib.resize_image" title="dlib.resize_image"><code class="xref py py-func docutils literal"><span class="pre">dlib.resize_image()</span></code></a></li>
<li><a class="reference internal" href="#dlib.reverse" title="dlib.reverse"><code class="xref py py-func docutils literal"><span class="pre">dlib.reverse()</span></code></a></li>
<li><a class="reference internal" href="#dlib.save_face_chip" title="dlib.save_face_chip"><code class="xref py py-func docutils literal"><span class="pre">dlib.save_face_chip()</span></code></a></li>
<li><a class="reference internal" href="#dlib.save_face_chips" title="dlib.save_face_chips"><code class="xref py py-func docutils literal"><span class="pre">dlib.save_face_chips()</span></code></a></li>
<li><a class="reference internal" href="#dlib.save_image" title="dlib.save_image"><code class="xref py py-func docutils literal"><span class="pre">dlib.save_image()</span></code></a></li>
<li><a class="reference internal" href="#dlib.save_libsvm_formatted_data" title="dlib.save_libsvm_formatted_data"><code class="xref py py-func docutils literal"><span class="pre">dlib.save_libsvm_formatted_data()</span></code></a></li>
<li><a class="reference internal" href="#dlib.scale_rect" title="dlib.scale_rect"><code class="xref py py-func docutils literal"><span class="pre">dlib.scale_rect()</span></code></a></li>
<li><a class="reference internal" href="#dlib.set_dnn_prefer_smallest_algorithms" title="dlib.set_dnn_prefer_smallest_algorithms"><code class="xref py py-func docutils literal"><span class="pre">dlib.set_dnn_prefer_smallest_algorithms()</span></code></a></li>
<li><a class="reference internal" href="#dlib.shrink_rect" title="dlib.shrink_rect"><code class="xref py py-func docutils literal"><span class="pre">dlib.shrink_rect()</span></code></a></li>
<li><a class="reference internal" href="#dlib.signed_distance_to_line" title="dlib.signed_distance_to_line"><code class="xref py py-func docutils literal"><span class="pre">dlib.signed_distance_to_line()</span></code></a></li>
<li><a class="reference internal" href="#dlib.skeleton" title="dlib.skeleton"><code class="xref py py-func docutils literal"><span class="pre">dlib.skeleton()</span></code></a></li>
<li><a class="reference internal" href="#dlib.sobel_edge_detector" title="dlib.sobel_edge_detector"><code class="xref py py-func docutils literal"><span class="pre">dlib.sobel_edge_detector()</span></code></a></li>
<li><a class="reference internal" href="#dlib.solve_structural_svm_problem" title="dlib.solve_structural_svm_problem"><code class="xref py py-func docutils literal"><span class="pre">dlib.solve_structural_svm_problem()</span></code></a></li>
<li><a class="reference internal" href="#dlib.spatially_filter_image" title="dlib.spatially_filter_image"><code class="xref py py-func docutils literal"><span class="pre">dlib.spatially_filter_image()</span></code></a></li>
<li><a class="reference internal" href="#dlib.spatially_filter_image_separable" title="dlib.spatially_filter_image_separable"><code class="xref py py-func docutils literal"><span class="pre">dlib.spatially_filter_image_separable()</span></code></a></li>
<li><a class="reference internal" href="#dlib.sub_image" title="dlib.sub_image"><code class="xref py py-func docutils literal"><span class="pre">dlib.sub_image()</span></code></a></li>
<li><a class="reference internal" href="#dlib.suppress_non_maximum_edges" title="dlib.suppress_non_maximum_edges"><code class="xref py py-func docutils literal"><span class="pre">dlib.suppress_non_maximum_edges()</span></code></a></li>
<li><a class="reference internal" href="#dlib.test_binary_decision_function" title="dlib.test_binary_decision_function"><code class="xref py py-func docutils literal"><span class="pre">dlib.test_binary_decision_function()</span></code></a></li>
<li><a class="reference internal" href="#dlib.test_ranking_function" title="dlib.test_ranking_function"><code class="xref py py-func docutils literal"><span class="pre">dlib.test_ranking_function()</span></code></a></li>
<li><a class="reference internal" href="#dlib.test_regression_function" title="dlib.test_regression_function"><code class="xref py py-func docutils literal"><span class="pre">dlib.test_regression_function()</span></code></a></li>
<li><a class="reference internal" href="#dlib.test_sequence_segmenter" title="dlib.test_sequence_segmenter"><code class="xref py py-func docutils literal"><span class="pre">dlib.test_sequence_segmenter()</span></code></a></li>
<li><a class="reference internal" href="#dlib.test_shape_predictor" title="dlib.test_shape_predictor"><code class="xref py py-func docutils literal"><span class="pre">dlib.test_shape_predictor()</span></code></a></li>
<li><a class="reference internal" href="#dlib.test_simple_object_detector" title="dlib.test_simple_object_detector"><code class="xref py py-func docutils literal"><span class="pre">dlib.test_simple_object_detector()</span></code></a></li>
<li><a class="reference internal" href="#dlib.threshold_filter_singular_values" title="dlib.threshold_filter_singular_values"><code class="xref py py-func docutils literal"><span class="pre">dlib.threshold_filter_singular_values()</span></code></a></li>
<li><a class="reference internal" href="#dlib.threshold_image" title="dlib.threshold_image"><code class="xref py py-func docutils literal"><span class="pre">dlib.threshold_image()</span></code></a></li>
<li><a class="reference internal" href="#dlib.tile_images" title="dlib.tile_images"><code class="xref py py-func docutils literal"><span class="pre">dlib.tile_images()</span></code></a></li>
<li><a class="reference internal" href="#dlib.train_sequence_segmenter" title="dlib.train_sequence_segmenter"><code class="xref py py-func docutils literal"><span class="pre">dlib.train_sequence_segmenter()</span></code></a></li>
<li><a class="reference internal" href="#dlib.train_shape_predictor" title="dlib.train_shape_predictor"><code class="xref py py-func docutils literal"><span class="pre">dlib.train_shape_predictor()</span></code></a></li>
<li><a class="reference internal" href="#dlib.train_simple_object_detector" title="dlib.train_simple_object_detector"><code class="xref py py-func docutils literal"><span class="pre">dlib.train_simple_object_detector()</span></code></a></li>
<li><a class="reference internal" href="#dlib.transform_image" title="dlib.transform_image"><code class="xref py py-func docutils literal"><span class="pre">dlib.transform_image()</span></code></a></li>
<li><a class="reference internal" href="#dlib.translate_rect" title="dlib.translate_rect"><code class="xref py py-func docutils literal"><span class="pre">dlib.translate_rect()</span></code></a></li>
<li><a class="reference internal" href="#dlib.zero_border_pixels" title="dlib.zero_border_pixels"><code class="xref py py-func docutils literal"><span class="pre">dlib.zero_border_pixels()</span></code></a></li>
<li><a class="reference internal" href="#dlib.cuda.get_device" title="dlib.cuda.get_device"><code class="xref py py-func docutils literal"><span class="pre">dlib.cuda.get_device()</span></code></a></li>
<li><a class="reference internal" href="#dlib.cuda.get_num_devices" title="dlib.cuda.get_num_devices"><code class="xref py py-func docutils literal"><span class="pre">dlib.cuda.get_num_devices()</span></code></a></li>
<li><a class="reference internal" href="#dlib.cuda.set_device" title="dlib.cuda.set_device"><code class="xref py py-func docutils literal"><span class="pre">dlib.cuda.set_device()</span></code></a></li>
<li><a class="reference internal" href="#dlib.image_dataset_metadata.load_image_dataset_metadata" title="dlib.image_dataset_metadata.load_image_dataset_metadata"><code class="xref py py-func docutils literal"><span class="pre">dlib.image_dataset_metadata.load_image_dataset_metadata()</span></code></a></li>
<li><a class="reference internal" href="#dlib.image_dataset_metadata.save_image_dataset_metadata" title="dlib.image_dataset_metadata.save_image_dataset_metadata"><code class="xref py py-func docutils literal"><span class="pre">dlib.image_dataset_metadata.save_image_dataset_metadata()</span></code></a></li>
</ul>
</div>
<div class="section" id="detailed-api-listing">
<h1>Detailed API Listing<a class="headerlink" href="#detailed-api-listing" title="Permalink to this headline">¶</a></h1>
<div class="toctree-wrapper compound">
<ul class="simple">
</ul>
</div>
<span class="target" id="module-dlib"></span><dl class="function">
<dt id="dlib.angle_between_lines">
<code class="descclassname">dlib.</code><code class="descname">angle_between_lines</code><span class="sig-paren">(</span><em>a: dlib.line</em>, <em>b: dlib.line</em><span class="sig-paren">)</span> &rarr; float<a class="headerlink" href="#dlib.angle_between_lines" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>ensures </dt>
<dd><ul class="first last simple">
<li>returns the angle, in degrees, between the given lines.  This is a number in 
the range [0 90].</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="dlib.apply_cca_transform">
<code class="descclassname">dlib.</code><code class="descname">apply_cca_transform</code><span class="sig-paren">(</span><em>m: dlib.matrix</em>, <em>v: dlib.sparse_vector</em><span class="sig-paren">)</span> &rarr; dlib.vector<a class="headerlink" href="#dlib.apply_cca_transform" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>requires    </dt>
<dd><ul class="first last simple">
<li>max_index_plus_one(v) &lt;= m.nr()</li>
</ul>
</dd>
<dt>ensures    </dt>
<dd><ul class="first last simple">
<li>returns trans(m)*v    
(i.e. multiply m by the vector v and return the result)</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="dlib.array">
<em class="property">class </em><code class="descclassname">dlib.</code><code class="descname">array</code><a class="headerlink" href="#dlib.array" title="Permalink to this definition">¶</a></dt>
<dd><p>This object represents a 1D array of floating point numbers. Moreover, it binds directly to the C++ type std::vector&lt;double&gt;.</p>
<dl class="method">
<dt id="dlib.array.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.array.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: dlib.array) -&gt; None</li>
<li>__init__(self: dlib.array, arg0: dlib.array) -&gt; None</li>
</ol>
<p>Copy constructor</p>
<ol class="arabic simple" start="3">
<li>__init__(self: dlib.array, arg0: iterable) -&gt; None</li>
<li>__init__(self: dlib.array, arg0: object) -&gt; None</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="dlib.array.append">
<code class="descname">append</code><span class="sig-paren">(</span><em>self: dlib.array</em>, <em>x: float</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.array.append" title="Permalink to this definition">¶</a></dt>
<dd><p>Add an item to the end of the list</p>
</dd></dl>

<dl class="method">
<dt id="dlib.array.clear">
<code class="descname">clear</code><span class="sig-paren">(</span><em>self: dlib.array</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.array.clear" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dlib.array.count">
<code class="descname">count</code><span class="sig-paren">(</span><em>self: dlib.array</em>, <em>x: float</em><span class="sig-paren">)</span> &rarr; int<a class="headerlink" href="#dlib.array.count" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of times <code class="docutils literal"><span class="pre">x</span></code> appears in the list</p>
</dd></dl>

<dl class="method">
<dt id="dlib.array.extend">
<code class="descname">extend</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.array.extend" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>extend(self: dlib.array, L: dlib.array) -&gt; None</li>
</ol>
<p>Extend the list by appending all the items in the given list</p>
<ol class="arabic simple" start="2">
<li>extend(self: dlib.array, arg0: list) -&gt; None</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="dlib.array.insert">
<code class="descname">insert</code><span class="sig-paren">(</span><em>self: dlib.array</em>, <em>i: int</em>, <em>x: float</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.array.insert" title="Permalink to this definition">¶</a></dt>
<dd><p>Insert an item at a given position.</p>
</dd></dl>

<dl class="method">
<dt id="dlib.array.pop">
<code class="descname">pop</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.array.pop" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>pop(self: dlib.array) -&gt; float</li>
</ol>
<p>Remove and return the last item</p>
<ol class="arabic simple" start="2">
<li>pop(self: dlib.array, i: int) -&gt; float</li>
</ol>
<p>Remove and return the item at index <code class="docutils literal"><span class="pre">i</span></code></p>
</dd></dl>

<dl class="method">
<dt id="dlib.array.remove">
<code class="descname">remove</code><span class="sig-paren">(</span><em>self: dlib.array</em>, <em>x: float</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.array.remove" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove the first item from the list whose value is x. It is an error if there is no such item.</p>
</dd></dl>

<dl class="method">
<dt id="dlib.array.resize">
<code class="descname">resize</code><span class="sig-paren">(</span><em>self: dlib.array</em>, <em>arg0: int</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.array.resize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="dlib.as_grayscale">
<code class="descclassname">dlib.</code><code class="descname">as_grayscale</code><span class="sig-paren">(</span><em>img: array</em><span class="sig-paren">)</span> &rarr; array<a class="headerlink" href="#dlib.as_grayscale" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert an image to 8bit grayscale.  If it&#8217;s already a grayscale image do nothing and just return img.</p>
</dd></dl>

<dl class="function">
<dt id="dlib.assignment_cost">
<code class="descclassname">dlib.</code><code class="descname">assignment_cost</code><span class="sig-paren">(</span><em>cost: dlib.matrix</em>, <em>assignment: list</em><span class="sig-paren">)</span> &rarr; float<a class="headerlink" href="#dlib.assignment_cost" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>requires    </dt>
<dd><ul class="first last">
<li><p class="first">cost.nr() == cost.nc()    
(i.e. the input must be a square matrix)</p>
</li>
<li><dl class="first docutils">
<dt>for all valid i:    </dt>
<dd><ul class="first last simple">
<li>0 &lt;= assignment[i] &lt; cost.nr()</li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
<dt>ensures    </dt>
<dd><ul class="first last">
<li><p class="first">Interprets cost as a cost assignment matrix. That is, cost[i][j]     
represents the cost of assigning i to j.</p>
</li>
<li><p class="first">Interprets assignment as a particular set of assignments. That is,    
i is assigned to assignment[i].</p>
</li>
<li><p class="first">returns the cost of the given assignment. That is, returns    
a number which is:</p>
<blockquote>
<div><p>sum over i: cost[i][assignment[i]]</p>
</div></blockquote>
</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="dlib.auto_train_rbf_classifier">
<code class="descclassname">dlib.</code><code class="descname">auto_train_rbf_classifier</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.auto_train_rbf_classifier" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>auto_train_rbf_classifier(x: dlib.vectors, y: dlib.array, max_runtime_seconds: float, be_verbose: bool=True) -&gt; dlib._normalized_decision_function_radial_basis</li>
</ol>
<dl class="docutils">
<dt>requires </dt>
<dd><ul class="first last simple">
<li>y contains at least 6 examples of each class.  Moreover, every element in y 
is either +1 or -1.</li>
<li>max_runtime_seconds &gt;= 0</li>
<li>len(x) == len(y)</li>
<li>all the vectors in x have the same dimension.</li>
</ul>
</dd>
<dt>ensures </dt>
<dd><ul class="first last simple">
<li>This routine trains a radial basis function SVM on the given binary 
classification training data.  It uses the svm_c_trainer to do this.  It also 
uses find_max_global() and 6-fold cross-validation to automatically determine 
the best settings of the SVM&#8217;s hyper parameters.</li>
<li>Note that we interpret y[i] as the label for the vector x[i].  Therefore, the 
returned function, df, should generally satisfy sign(df(x[i])) == y[i] as 
often as possible.</li>
<li>The hyperparameter search will run for about max_runtime and will print 
messages to the screen as it runs if be_verbose==true.</li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li>auto_train_rbf_classifier(x: numpy.ndarray[(rows,cols),float64], y: numpy.ndarray[float64], max_runtime_seconds: float, be_verbose: bool=True) -&gt; dlib._normalized_decision_function_radial_basis</li>
</ol>
<dl class="docutils">
<dt>requires </dt>
<dd><ul class="first last simple">
<li>y contains at least 6 examples of each class.  Moreover, every element in y 
is either +1 or -1.</li>
<li>max_runtime_seconds &gt;= 0</li>
<li>len(x.shape(0)) == len(y)</li>
<li>x.shape(1) &gt; 0</li>
</ul>
</dd>
<dt>ensures </dt>
<dd><ul class="first last simple">
<li>This routine trains a radial basis function SVM on the given binary 
classification training data.  It uses the svm_c_trainer to do this.  It also 
uses find_max_global() and 6-fold cross-validation to automatically determine 
the best settings of the SVM&#8217;s hyper parameters.</li>
<li>Note that we interpret y[i] as the label for the vector x[i].  Therefore, the 
returned function, df, should generally satisfy sign(df(x[i])) == y[i] as 
often as possible.</li>
<li>The hyperparameter search will run for about max_runtime and will print 
messages to the screen as it runs if be_verbose==true.</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="dlib.cca">
<code class="descclassname">dlib.</code><code class="descname">cca</code><span class="sig-paren">(</span><em>L: dlib.sparse_vectors</em>, <em>R: dlib.sparse_vectors</em>, <em>num_correlations: int</em>, <em>extra_rank: int=5L</em>, <em>q: int=2L</em>, <em>regularization: float=0L</em><span class="sig-paren">)</span> &rarr; dlib.cca_outputs<a class="headerlink" href="#dlib.cca" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>requires    </dt>
<dd><ul class="first last simple">
<li>num_correlations &gt; 0</li>
<li>len(L) &gt; 0</li>
<li>len(R) &gt; 0</li>
<li>len(L) == len(R)</li>
<li>regularization &gt;= 0</li>
<li>L and R must be properly sorted sparse vectors.  This means they must list their  
elements in ascending index order and not contain duplicate index values.  You can use 
make_sparse_vector() to ensure this is true.</li>
</ul>
</dd>
<dt>ensures    </dt>
<dd><ul class="first last">
<li><p class="first">This function performs a canonical correlation analysis between the vectors    
in L and R.  That is, it finds two transformation matrices, Ltrans and    
Rtrans, such that row vectors in the transformed matrices L*Ltrans and    
R*Rtrans are as correlated as possible (note that in this notation we    
interpret L as a matrix with the input vectors in its rows).  Note also that    
this function tries to find transformations which produce num_correlations    
dimensional output vectors.</p>
</li>
<li><p class="first">Note that you can easily apply the transformation to a vector using     
apply_cca_transform().  So for example, like this:</p>
<blockquote>
<div><ul class="simple">
<li>apply_cca_transform(Ltrans, some_sparse_vector)</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">returns a structure containing the Ltrans and Rtrans transformation matrices    
as well as the estimated correlations between elements of the transformed    
vectors.</p>
</li>
<li><p class="first">This function assumes the data vectors in L and R have already been centered    
(i.e. we assume the vectors have zero means).  However, in many cases it is    
fine to use uncentered data with cca().  But if it is important for your    
problem then you should center your data before passing it to cca().</p>
</li>
<li><p class="first">This function works with reduced rank approximations of the L and R matrices.    
This makes it fast when working with large matrices.  In particular, we use    
the dlib::svd_fast() routine to find reduced rank representations of the input    
matrices by calling it as follows: svd_fast(L, U,D,V, num_correlations+extra_rank, q)     
and similarly for R.  This means that you can use the extra_rank and q    
arguments to cca() to influence the accuracy of the reduced rank    
approximation.  However, the default values should work fine for most    
problems.</p>
</li>
<li><p class="first">The dimensions of the output vectors produced by L*#Ltrans or R*#Rtrans are 
ordered such that the dimensions with the highest correlations come first. 
That is, after applying the transforms produced by cca() to a set of vectors 
you will find that dimension 0 has the highest correlation, then dimension 1 
has the next highest, and so on.  This also means that the list of estimated 
correlations returned from cca() will always be listed in decreasing order.</p>
</li>
<li><p class="first">This function performs the ridge regression version of Canonical Correlation    
Analysis when regularization is set to a value &gt; 0.  In particular, larger    
values indicate the solution should be more heavily regularized.  This can be    
useful when the dimensionality of the data is larger than the number of    
samples.</p>
</li>
<li><p class="first">A good discussion of CCA can be found in the paper &#8220;Canonical Correlation    
Analysis&#8221; by David Weenink.  In particular, this function is implemented    
using equations 29 and 30 from his paper.  We also use the idea of doing CCA    
on a reduced rank approximation of L and R as suggested by Paramveer S.    
Dhillon in his paper &#8220;Two Step CCA: A new spectral method for estimating    
vector models of words&#8221;.</p>
</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="dlib.cca_outputs">
<em class="property">class </em><code class="descclassname">dlib.</code><code class="descname">cca_outputs</code><a class="headerlink" href="#dlib.cca_outputs" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="dlib.cca_outputs.Ltrans">
<code class="descname">Ltrans</code><a class="headerlink" href="#dlib.cca_outputs.Ltrans" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.cca_outputs.Rtrans">
<code class="descname">Rtrans</code><a class="headerlink" href="#dlib.cca_outputs.Rtrans" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.cca_outputs.__init__">
<code class="descname">__init__</code><a class="headerlink" href="#dlib.cca_outputs.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__init__(...) initializes x; see help(type(x)) for signature</p>
</dd></dl>

<dl class="attribute">
<dt id="dlib.cca_outputs.correlations">
<code class="descname">correlations</code><a class="headerlink" href="#dlib.cca_outputs.correlations" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="dlib.center">
<code class="descclassname">dlib.</code><code class="descname">center</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.center" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p class="first">center(rect: dlib.rectangle) -&gt; dlib.point</p>
<blockquote>
<div><p>returns the center of the given rectangle</p>
</div></blockquote>
</li>
<li><p class="first">center(rect: dlib.drectangle) -&gt; dlib.dpoint</p>
<blockquote>
<div><p>returns the center of the given rectangle</p>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="function">
<dt id="dlib.centered_rect">
<code class="descclassname">dlib.</code><code class="descname">centered_rect</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.centered_rect" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>centered_rect(p: dlib.point, width: int, height: int) -&gt; dlib.rectangle</li>
<li>centered_rect(p: dlib.dpoint, width: int, height: int) -&gt; dlib.rectangle</li>
<li>centered_rect(rect: dlib.rectangle, width: int, height: int) -&gt; dlib.rectangle</li>
<li>centered_rect(rect: dlib.drectangle, width: int, height: int) -&gt; dlib.rectangle</li>
</ol>
</dd></dl>

<dl class="function">
<dt id="dlib.centered_rects">
<code class="descclassname">dlib.</code><code class="descname">centered_rects</code><span class="sig-paren">(</span><em>pts: dlib.points</em>, <em>width: int</em>, <em>height: int</em><span class="sig-paren">)</span> &rarr; dlib.rectangles<a class="headerlink" href="#dlib.centered_rects" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="dlib.chinese_whispers">
<code class="descclassname">dlib.</code><code class="descname">chinese_whispers</code><span class="sig-paren">(</span><em>edges: list</em><span class="sig-paren">)</span> &rarr; list<a class="headerlink" href="#dlib.chinese_whispers" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a graph with vertices represented as numbers indexed from 0, this algorithm takes a list of edges and returns back a list that contains a labels (found clusters) for each vertex. Edges are tuples with either 2 elements (integers presenting indexes of connected vertices) or 3 elements, where additional one element is float which presents distance weight of the edge). Offers direct access to dlib::chinese_whispers.</p>
</dd></dl>

<dl class="function">
<dt id="dlib.chinese_whispers_clustering">
<code class="descclassname">dlib.</code><code class="descname">chinese_whispers_clustering</code><span class="sig-paren">(</span><em>descriptors: list</em>, <em>threshold: float</em><span class="sig-paren">)</span> &rarr; list<a class="headerlink" href="#dlib.chinese_whispers_clustering" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a list of descriptors and returns a list that contains a label for each descriptor. Clustering is done using dlib::chinese_whispers.</p>
</dd></dl>

<dl class="class">
<dt id="dlib.chip_details">
<em class="property">class </em><code class="descclassname">dlib.</code><code class="descname">chip_details</code><a class="headerlink" href="#dlib.chip_details" title="Permalink to this definition">¶</a></dt>
<dd><p>WHAT THIS OBJECT REPRESENTS 
This object describes where an image chip is to be extracted from within 
another image.  In particular, it specifies that the image chip is 
contained within the rectangle self.rect and that prior to extraction the 
image should be rotated counter-clockwise by self.angle radians.  Finally, 
the extracted chip should have self.rows rows and self.cols columns in it 
regardless of the shape of self.rect.  This means that the extracted chip 
will be stretched to fit via bilinear interpolation when necessary.</p>
<dl class="method">
<dt id="dlib.chip_details.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.chip_details.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: dlib.chip_details, rect: dlib.drectangle) -&gt; None</li>
<li>__init__(self: dlib.chip_details, rect: dlib.rectangle) -&gt; None</li>
</ol>
<dl class="docutils">
<dt>ensures </dt>
<dd><ul class="first last simple">
<li>self.rect == <a href="#id1"><span class="problematic" id="id2">rect_</span></a></li>
<li>self.angle == 0</li>
<li>self.rows == rect.height()</li>
<li>self.cols == rect.width()</li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="3">
<li>__init__(self: dlib.chip_details, rect: dlib.drectangle, size: int) -&gt; None</li>
<li>__init__(self: dlib.chip_details, rect: dlib.rectangle, size: int) -&gt; None</li>
</ol>
<dl class="docutils">
<dt>ensures </dt>
<dd><ul class="first last simple">
<li>self.rect == rect</li>
<li>self.angle == 0</li>
<li>self.rows and self.cols is set such that the total size of the chip is as close 
to size as possible but still matches the aspect ratio of rect.</li>
<li>As long as size and the aspect ratio of of rect stays constant then 
self.rows and self.cols will always have the same values.  This means 
that, for example, if you want all your chips to have the same dimensions 
then ensure that size is always the same and also that rect always has 
the same aspect ratio.  Otherwise the calculated values of self.rows and 
self.cols may be different for different chips.  Alternatively, you can 
use the chip_details constructor below that lets you specify the exact 
values for rows and cols.</li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="5">
<li>__init__(self: dlib.chip_details, rect: dlib.drectangle, size: int, angle: float) -&gt; None</li>
<li>__init__(self: dlib.chip_details, rect: dlib.rectangle, size: int, angle: float) -&gt; None</li>
</ol>
<dl class="docutils">
<dt>ensures </dt>
<dd><ul class="first last simple">
<li>self.rect == rect</li>
<li>self.angle == angle</li>
<li>self.rows and self.cols is set such that the total size of the chip is as 
close to size as possible but still matches the aspect ratio of rect.</li>
<li>As long as size and the aspect ratio of of rect stays constant then 
self.rows and self.cols will always have the same values.  This means 
that, for example, if you want all your chips to have the same dimensions 
then ensure that size is always the same and also that rect always has 
the same aspect ratio.  Otherwise the calculated values of self.rows and 
self.cols may be different for different chips.  Alternatively, you can 
use the chip_details constructor below that lets you specify the exact 
values for rows and cols.</li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="7">
<li>__init__(self: dlib.chip_details, rect: dlib.drectangle, dims: dlib.chip_dims) -&gt; None</li>
<li>__init__(self: dlib.chip_details, rect: dlib.rectangle, dims: dlib.chip_dims) -&gt; None</li>
</ol>
<dl class="docutils">
<dt>ensures </dt>
<dd><ul class="first last simple">
<li>self.rect == rect</li>
<li>self.angle == 0</li>
<li>self.rows == dims.rows</li>
<li>self.cols == dims.cols</li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="9">
<li>__init__(self: dlib.chip_details, rect: dlib.drectangle, dims: dlib.chip_dims, angle: float) -&gt; None</li>
<li>__init__(self: dlib.chip_details, rect: dlib.rectangle, dims: dlib.chip_dims, angle: float) -&gt; None</li>
</ol>
<dl class="docutils">
<dt>ensures </dt>
<dd><ul class="first last simple">
<li>self.rect == rect</li>
<li>self.angle == angle</li>
<li>self.rows == dims.rows</li>
<li>self.cols == dims.cols</li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="11">
<li>__init__(self: dlib.chip_details, chip_points: dlib.dpoints, img_points: dlib.dpoints, dims: dlib.chip_dims) -&gt; None</li>
<li>__init__(self: dlib.chip_details, chip_points: dlib.points, img_points: dlib.points, dims: dlib.chip_dims) -&gt; None</li>
</ol>
<dl class="docutils">
<dt>requires </dt>
<dd><ul class="first last simple">
<li>len(chip_points) == len(img_points)</li>
<li>len(chip_points) &gt;= 2</li>
</ul>
</dd>
<dt>ensures </dt>
<dd><ul class="first last simple">
<li>The chip will be extracted such that the pixel locations chip_points[i] 
in the chip are mapped to img_points[i] in the original image by a 
similarity transform.  That is, if you know the pixelwize mapping you 
want between the chip and the original image then you use this function 
of chip_details constructor to define the mapping.</li>
<li>self.rows == dims.rows</li>
<li>self.cols == dims.cols</li>
<li>self.rect and self.angle are computed based on the given size of the output chip 
(specified by dims) and the similarity transform between the chip and 
image (specified by chip_points and img_points).</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="dlib.chip_details.angle">
<code class="descname">angle</code><a class="headerlink" href="#dlib.chip_details.angle" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.chip_details.cols">
<code class="descname">cols</code><a class="headerlink" href="#dlib.chip_details.cols" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.chip_details.rect">
<code class="descname">rect</code><a class="headerlink" href="#dlib.chip_details.rect" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.chip_details.rows">
<code class="descname">rows</code><a class="headerlink" href="#dlib.chip_details.rows" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="dlib.chip_dims">
<em class="property">class </em><code class="descclassname">dlib.</code><code class="descname">chip_dims</code><a class="headerlink" href="#dlib.chip_dims" title="Permalink to this definition">¶</a></dt>
<dd><p>WHAT THIS OBJECT REPRESENTS 
This is a simple tool for passing in a pair of row and column values to the 
chip_details constructor.</p>
<dl class="method">
<dt id="dlib.chip_dims.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: dlib.chip_dims</em>, <em>rows: int</em>, <em>cols: int</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.chip_dims.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.chip_dims.cols">
<code class="descname">cols</code><a class="headerlink" href="#dlib.chip_dims.cols" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.chip_dims.rows">
<code class="descname">rows</code><a class="headerlink" href="#dlib.chip_dims.rows" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="dlib.cnn_face_detection_model_v1">
<em class="property">class </em><code class="descclassname">dlib.</code><code class="descname">cnn_face_detection_model_v1</code><a class="headerlink" href="#dlib.cnn_face_detection_model_v1" title="Permalink to this definition">¶</a></dt>
<dd><p>This object detects human faces in an image.  The constructor loads the face detection model from a file. You can download a pre-trained model from <a class="reference external" href="http://dlib.net/files/mmod_human_face_detector.dat.bz2">http://dlib.net/files/mmod_human_face_detector.dat.bz2</a>.</p>
<dl class="method">
<dt id="dlib.cnn_face_detection_model_v1.__call__">
<code class="descname">__call__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.cnn_face_detection_model_v1.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__call__(self: dlib.cnn_face_detection_model_v1, imgs: list, upsample_num_times: int=0L, batch_size: int=128L) -&gt; std::vector&lt;std::vector&lt;dlib::mmod_rect, std::allocator&lt;dlib::mmod_rect&gt; &gt;, std::allocator&lt;std::vector&lt;dlib::mmod_rect, std::allocator&lt;dlib::mmod_rect&gt; &gt; &gt; &gt;</li>
</ol>
<p>takes a list of images as input returning a 2d list of mmod rectangles</p>
<ol class="arabic simple" start="2">
<li>__call__(self: dlib.cnn_face_detection_model_v1, img: array, upsample_num_times: int=0L) -&gt; std::vector&lt;dlib::mmod_rect, std::allocator&lt;dlib::mmod_rect&gt; &gt;</li>
</ol>
<dl class="docutils">
<dt>Find faces in an image using a deep learning model.</dt>
<dd><ul class="first last simple">
<li>Upsamples the image upsample_num_times before running the face 
detector.</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dlib.cnn_face_detection_model_v1.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: dlib.cnn_face_detection_model_v1</em>, <em>filename: unicode</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.cnn_face_detection_model_v1.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="dlib.convert_image">
<code class="descclassname">dlib.</code><code class="descname">convert_image</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.convert_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>convert_image(img: numpy.ndarray[(rows,cols),uint8], dtype: unicode) -&gt; array</li>
<li>convert_image(img: numpy.ndarray[(rows,cols),uint16], dtype: unicode) -&gt; array</li>
<li>convert_image(img: numpy.ndarray[(rows,cols),uint32], dtype: unicode) -&gt; array</li>
<li>convert_image(img: numpy.ndarray[(rows,cols),uint64], dtype: unicode) -&gt; array</li>
<li>convert_image(img: numpy.ndarray[(rows,cols),int8], dtype: unicode) -&gt; array</li>
<li>convert_image(img: numpy.ndarray[(rows,cols),int16], dtype: unicode) -&gt; array</li>
<li>convert_image(img: numpy.ndarray[(rows,cols),int32], dtype: unicode) -&gt; array</li>
<li>convert_image(img: numpy.ndarray[(rows,cols),int64], dtype: unicode) -&gt; array</li>
<li>convert_image(img: numpy.ndarray[(rows,cols),float32], dtype: unicode) -&gt; array</li>
<li>convert_image(img: numpy.ndarray[(rows,cols),float64], dtype: unicode) -&gt; array</li>
<li>convert_image(img: numpy.ndarray[(rows,cols,3),uint8], dtype: unicode) -&gt; array</li>
</ol>
<dl class="docutils">
<dt>Converts an image to a target pixel type.  dtype must be a string containing one of the following: </dt>
<dd>uint8, int8, uint16, int16, uint32, int32, uint64, int64, float32, float, float64, double, or rgb_pixel</dd>
</dl>
<p>When converting from a color space with more than 255 values the pixel intensity is 
saturated at the minimum and maximum pixel values of the target pixel type.  For 
example, if you convert a float valued image to uint8 then float values will be 
truncated to integers and values larger than 255 are converted to 255 while values less 
than 0 are converted to 0.</p>
</dd></dl>

<dl class="function">
<dt id="dlib.convert_image_scaled">
<code class="descclassname">dlib.</code><code class="descname">convert_image_scaled</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.convert_image_scaled" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>convert_image_scaled(img: numpy.ndarray[(rows,cols),uint8], dtype: unicode, thresh: float=4L) -&gt; array</li>
<li>convert_image_scaled(img: numpy.ndarray[(rows,cols),uint16], dtype: unicode, thresh: float=4L) -&gt; array</li>
<li>convert_image_scaled(img: numpy.ndarray[(rows,cols),uint32], dtype: unicode, thresh: float=4L) -&gt; array</li>
<li>convert_image_scaled(img: numpy.ndarray[(rows,cols),uint64], dtype: unicode, thresh: float=4L) -&gt; array</li>
<li>convert_image_scaled(img: numpy.ndarray[(rows,cols),int8], dtype: unicode, thresh: float=4L) -&gt; array</li>
<li>convert_image_scaled(img: numpy.ndarray[(rows,cols),int16], dtype: unicode, thresh: float=4L) -&gt; array</li>
<li>convert_image_scaled(img: numpy.ndarray[(rows,cols),int32], dtype: unicode, thresh: float=4L) -&gt; array</li>
<li>convert_image_scaled(img: numpy.ndarray[(rows,cols),int64], dtype: unicode, thresh: float=4L) -&gt; array</li>
<li>convert_image_scaled(img: numpy.ndarray[(rows,cols),float32], dtype: unicode, thresh: float=4L) -&gt; array</li>
<li>convert_image_scaled(img: numpy.ndarray[(rows,cols),float64], dtype: unicode, thresh: float=4L) -&gt; array</li>
<li>convert_image_scaled(img: numpy.ndarray[(rows,cols,3),uint8], dtype: unicode, thresh: float=4L) -&gt; array</li>
</ol>
<dl class="docutils">
<dt>requires </dt>
<dd><ul class="first last simple">
<li>thresh &gt; 0</li>
</ul>
</dd>
<dt>ensures </dt>
<dd><ul class="first last">
<li><p class="first">Converts an image to a target pixel type.  dtype must be a string containing one of the following: 
uint8, int8, uint16, int16, uint32, int32, uint64, int64, float32, float, float64, double, or rgb_pixel</p>
<p>The contents of img will be scaled to fit the dynamic range of the target 
pixel type.  The thresh parameter is used to filter source pixel values which 
are outliers.  These outliers will saturate at the edge of the destination 
image&#8217;s dynamic range.</p>
</li>
<li><dl class="first docutils">
<dt>Specifically, for all valid r and c: </dt>
<dd><ul class="first last">
<li><p class="first">We scale img[r][c] into the dynamic range of the target pixel type.  This 
is done using the mean and standard deviation of img. Call the mean M and 
the standard deviation D.  Then the scaling from source to destination is 
performed using the following mapping:</p>
<blockquote>
<div><p>let SRC_UPPER  = min(M + thresh*D, max(img)) 
let SRC_LOWER  = max(M - thresh*D, min(img)) 
let DEST_UPPER = max value possible for the selected dtype.  
let DEST_LOWER = min value possible for the selected dtype.</p>
<p>MAPPING: [SRC_LOWER, SRC_UPPER] -&gt; [DEST_LOWER, DEST_UPPER]</p>
</div></blockquote>
<p>Where this mapping is a linear mapping of values from the left range 
into the right range of values.  Source pixel values outside the left 
range are modified to be at the appropriate end of the range.</p>
</li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="dlib.correlation_tracker">
<em class="property">class </em><code class="descclassname">dlib.</code><code class="descname">correlation_tracker</code><a class="headerlink" href="#dlib.correlation_tracker" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a tool for tracking moving objects in a video stream.  You give it 
the bounding box of an object in the first frame and it attempts to track the 
object in the box from frame to frame.  
This tool is an implementation of the method described in the following paper:</p>
<blockquote>
<div>Danelljan, Martin, et al. &#8216;Accurate scale estimation for robust visual 
tracking.&#8217; Proceedings of the British Machine Vision Conference BMVC. 2014.</div></blockquote>
<dl class="method">
<dt id="dlib.correlation_tracker.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: dlib.correlation_tracker</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.correlation_tracker.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dlib.correlation_tracker.get_position">
<code class="descname">get_position</code><span class="sig-paren">(</span><em>self: dlib.correlation_tracker</em><span class="sig-paren">)</span> &rarr; dlib.drectangle<a class="headerlink" href="#dlib.correlation_tracker.get_position" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the predicted position of the object under track.</p>
</dd></dl>

<dl class="method">
<dt id="dlib.correlation_tracker.start_track">
<code class="descname">start_track</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.correlation_tracker.start_track" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p class="first">start_track(self: dlib.correlation_tracker, image: array, bounding_box: dlib.drectangle) -&gt; None</p>
<blockquote>
<div><dl class="docutils">
<dt>requires </dt>
<dd><ul class="first last simple">
<li>image is a numpy ndarray containing either an 8bit grayscale or RGB image.</li>
<li>bounding_box.is_empty() == false</li>
</ul>
</dd>
<dt>ensures </dt>
<dd><ul class="first last simple">
<li>This object will start tracking the thing inside the bounding box in the 
given image.  That is, if you call update() with subsequent video frames 
then it will try to keep track of the position of the object inside bounding_box.</li>
<li>#get_position() == bounding_box</li>
</ul>
</dd>
</dl>
</div></blockquote>
</li>
<li><p class="first">start_track(self: dlib.correlation_tracker, image: array, bounding_box: dlib.rectangle) -&gt; None</p>
<blockquote>
<div><dl class="docutils">
<dt>requires </dt>
<dd><ul class="first last simple">
<li>image is a numpy ndarray containing either an 8bit grayscale or RGB image.</li>
<li>bounding_box.is_empty() == false</li>
</ul>
</dd>
<dt>ensures </dt>
<dd><ul class="first last simple">
<li>This object will start tracking the thing inside the bounding box in the 
given image.  That is, if you call update() with subsequent video frames 
then it will try to keep track of the position of the object inside bounding_box.</li>
<li>#get_position() == bounding_box</li>
</ul>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="dlib.correlation_tracker.update">
<code class="descname">update</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.correlation_tracker.update" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p class="first">update(self: dlib.correlation_tracker, image: array) -&gt; float</p>
<blockquote>
<div><dl class="docutils">
<dt>requires </dt>
<dd><ul class="first last simple">
<li>image is a numpy ndarray containing either an 8bit grayscale or RGB image.</li>
<li>get_position().is_empty() == false 
(i.e. you must have started tracking by calling start_track())</li>
</ul>
</dd>
<dt>ensures </dt>
<dd><ul class="first last simple">
<li>performs: return update(img, get_position())</li>
</ul>
</dd>
</dl>
</div></blockquote>
</li>
<li><p class="first">update(self: dlib.correlation_tracker, image: array, guess: dlib.drectangle) -&gt; float</p>
<blockquote>
<div><dl class="docutils">
<dt>requires </dt>
<dd><ul class="first last simple">
<li>image is a numpy ndarray containing either an 8bit grayscale or RGB image.</li>
<li>get_position().is_empty() == false 
(i.e. you must have started tracking by calling start_track())</li>
</ul>
</dd>
<dt>ensures </dt>
<dd><ul class="first last simple">
<li>When searching for the object in img, we search in the area around the 
provided guess.</li>
<li>#get_position() == the new predicted location of the object in img.  This 
location will be a copy of guess that has been translated and scaled 
appropriately based on the content of img so that it, hopefully, bounds 
the object in img.</li>
<li>Returns the peak to side-lobe ratio.  This is a number that measures how 
confident the tracker is that the object is inside #get_position(). 
Larger values indicate higher confidence.</li>
</ul>
</dd>
</dl>
</div></blockquote>
</li>
<li><p class="first">update(self: dlib.correlation_tracker, image: array, guess: dlib.rectangle) -&gt; float</p>
<blockquote>
<div><dl class="docutils">
<dt>requires </dt>
<dd><ul class="first last simple">
<li>image is a numpy ndarray containing either an 8bit grayscale or RGB image.</li>
<li>get_position().is_empty() == false 
(i.e. you must have started tracking by calling start_track())</li>
</ul>
</dd>
<dt>ensures </dt>
<dd><ul class="first last simple">
<li>When searching for the object in img, we search in the area around the 
provided guess.</li>
<li>#get_position() == the new predicted location of the object in img.  This 
location will be a copy of guess that has been translated and scaled 
appropriately based on the content of img so that it, hopefully, bounds 
the object in img.</li>
<li>Returns the peak to side-lobe ratio.  This is a number that measures how 
confident the tracker is that the object is inside #get_position(). 
Larger values indicate higher confidence.</li>
</ul>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="dlib.count_points_between_lines">
<code class="descclassname">dlib.</code><code class="descname">count_points_between_lines</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.count_points_between_lines" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>count_points_between_lines(l1: dlib.line, l2: dlib.line, reference_point: dlib.dpoint, pts: dlib.points) -&gt; float</li>
<li>count_points_between_lines(l1: dlib.line, l2: dlib.line, reference_point: dlib.dpoint, pts: dlib.dpoints) -&gt; float</li>
</ol>
<dl class="docutils">
<dt>ensures </dt>
<dd><ul class="first last simple">
<li>Counts and returns the number of points in pts that are between lines l1 and 
l2.  Since a pair of lines will, in the general case, divide the plane into 4 
regions, we identify the region of interest as the one that contains the 
reference_point.  Therefore, this function counts the number of points in pts 
that appear in the same region as reference_point.</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="dlib.count_points_on_side_of_line">
<code class="descclassname">dlib.</code><code class="descname">count_points_on_side_of_line</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.count_points_on_side_of_line" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>count_points_on_side_of_line(l: dlib.line, reference_point: dlib.dpoint, pts: dlib.points, dist_thresh_min: float=0L, dist_thresh_max: float=inf) -&gt; int</li>
<li>count_points_on_side_of_line(l: dlib.line, reference_point: dlib.dpoint, pts: dlib.dpoints, dist_thresh_min: float=0L, dist_thresh_max: float=inf) -&gt; int</li>
</ol>
<dl class="docutils">
<dt>ensures </dt>
<dd><ul class="first last simple">
<li>Returns a count of how many points in pts have a distance from the line l 
that is in the range [dist_thresh_min, dist_thresh_max].  This distance is a 
signed value that indicates how far a point is from the line. Moreover, if 
the point is on the same side as reference_point then the distance is 
positive, otherwise it is negative.  So for example, If this range is [0, 
infinity] then this function counts how many points are on the same side of l 
as reference_point.</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="dlib.count_steps_without_decrease">
<code class="descclassname">dlib.</code><code class="descname">count_steps_without_decrease</code><span class="sig-paren">(</span><em>time_series: object</em>, <em>probability_of_decrease: float=0.51</em><span class="sig-paren">)</span> &rarr; int<a class="headerlink" href="#dlib.count_steps_without_decrease" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>requires </dt>
<dd><ul class="first last simple">
<li>time_series must be a one dimensional array of real numbers.</li>
<li>0.5 &lt; probability_of_decrease &lt; 1</li>
</ul>
</dd>
<dt>ensures </dt>
<dd><ul class="first last simple">
<li>If you think of the contents of time_series as a potentially noisy time 
series, then this function returns a count of how long the time series has 
gone without noticeably decreasing in value.  It does this by scanning along 
the elements, starting from the end (i.e. time_series[-1]) to the beginning, 
and checking how many elements you need to examine before you are confident 
that the series has been decreasing in value.  Here, &#8220;confident of decrease&#8221; 
means the probability of decrease is &gt;= probability_of_decrease.</li>
<li>Setting probability_of_decrease to 0.51 means we count until we see even a 
small hint of decrease, whereas a larger value of 0.99 would return a larger 
count since it keeps going until it is nearly certain the time series is 
decreasing.</li>
<li>The max possible output from this function is len(time_series).</li>
<li>The implementation of this function is done using the dlib::running_gradient 
object, which is a tool that finds the least squares fit of a line to the 
time series and the confidence interval around the slope of that line.  That 
can then be used in a simple statistical test to determine if the slope is 
positive or negative.</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="dlib.count_steps_without_decrease_robust">
<code class="descclassname">dlib.</code><code class="descname">count_steps_without_decrease_robust</code><span class="sig-paren">(</span><em>time_series: object</em>, <em>probability_of_decrease: float=0.51</em>, <em>quantile_discard: float=0.1</em><span class="sig-paren">)</span> &rarr; int<a class="headerlink" href="#dlib.count_steps_without_decrease_robust" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>requires </dt>
<dd><ul class="first last simple">
<li>time_series must be a one dimensional array of real numbers.</li>
<li>0.5 &lt; probability_of_decrease &lt; 1</li>
<li>0 &lt;= quantile_discard &lt;= 1</li>
</ul>
</dd>
<dt>ensures </dt>
<dd><ul class="first last simple">
<li>This function behaves just like 
count_steps_without_decrease(time_series,probability_of_decrease) except that 
it ignores values in the time series that are in the upper quantile_discard 
quantile.  So for example, if the quantile discard is 0.1 then the 10% 
largest values in the time series are ignored.</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="dlib.cross_validate_ranking_trainer">
<code class="descclassname">dlib.</code><code class="descname">cross_validate_ranking_trainer</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.cross_validate_ranking_trainer" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>cross_validate_ranking_trainer(trainer: dlib.svm_rank_trainer, samples: dlib.ranking_pairs, folds: int) -&gt; ranking_test</li>
<li>cross_validate_ranking_trainer(trainer: dlib.svm_rank_trainer_sparse, samples: dlib.sparse_ranking_pairs, folds: int) -&gt; ranking_test</li>
</ol>
</dd></dl>

<dl class="function">
<dt id="dlib.cross_validate_sequence_segmenter">
<code class="descclassname">dlib.</code><code class="descname">cross_validate_sequence_segmenter</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.cross_validate_sequence_segmenter" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>cross_validate_sequence_segmenter(samples: dlib.vectorss, segments: dlib.rangess, folds: int, params: dlib.segmenter_params=&lt;BIO,highFeats,signed,win=5,threads=4,eps=0.1,cache=40,non-verbose,C=100&gt;) -&gt; dlib.segmenter_test</li>
<li>cross_validate_sequence_segmenter(samples: dlib.sparse_vectorss, segments: dlib.rangess, folds: int, params: dlib.segmenter_params=&lt;BIO,highFeats,signed,win=5,threads=4,eps=0.1,cache=40,non-verbose,C=100&gt;) -&gt; dlib.segmenter_test</li>
</ol>
</dd></dl>

<dl class="function">
<dt id="dlib.cross_validate_trainer">
<code class="descclassname">dlib.</code><code class="descname">cross_validate_trainer</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.cross_validate_trainer" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>cross_validate_trainer(trainer: dlib.svm_c_trainer_radial_basis, x: dlib.vectors, y: dlib.array, folds: int) -&gt; dlib._binary_test</li>
<li>cross_validate_trainer(trainer: dlib.svm_c_trainer_sparse_radial_basis, x: dlib.sparse_vectors, y: dlib.array, folds: int) -&gt; dlib._binary_test</li>
<li>cross_validate_trainer(trainer: dlib.svm_c_trainer_histogram_intersection, x: dlib.vectors, y: dlib.array, folds: int) -&gt; dlib._binary_test</li>
<li>cross_validate_trainer(trainer: dlib.svm_c_trainer_sparse_histogram_intersection, x: dlib.sparse_vectors, y: dlib.array, folds: int) -&gt; dlib._binary_test</li>
<li>cross_validate_trainer(trainer: dlib.svm_c_trainer_linear, x: dlib.vectors, y: dlib.array, folds: int) -&gt; dlib._binary_test</li>
<li>cross_validate_trainer(trainer: dlib.svm_c_trainer_sparse_linear, x: dlib.sparse_vectors, y: dlib.array, folds: int) -&gt; dlib._binary_test</li>
<li>cross_validate_trainer(trainer: dlib.rvm_trainer_radial_basis, x: dlib.vectors, y: dlib.array, folds: int) -&gt; dlib._binary_test</li>
<li>cross_validate_trainer(trainer: dlib.rvm_trainer_sparse_radial_basis, x: dlib.sparse_vectors, y: dlib.array, folds: int) -&gt; dlib._binary_test</li>
<li>cross_validate_trainer(trainer: dlib.rvm_trainer_histogram_intersection, x: dlib.vectors, y: dlib.array, folds: int) -&gt; dlib._binary_test</li>
<li>cross_validate_trainer(trainer: dlib.rvm_trainer_sparse_histogram_intersection, x: dlib.sparse_vectors, y: dlib.array, folds: int) -&gt; dlib._binary_test</li>
<li>cross_validate_trainer(trainer: dlib.rvm_trainer_linear, x: dlib.vectors, y: dlib.array, folds: int) -&gt; dlib._binary_test</li>
<li>cross_validate_trainer(trainer: dlib.rvm_trainer_sparse_linear, x: dlib.sparse_vectors, y: dlib.array, folds: int) -&gt; dlib._binary_test</li>
</ol>
</dd></dl>

<dl class="function">
<dt id="dlib.cross_validate_trainer_threaded">
<code class="descclassname">dlib.</code><code class="descname">cross_validate_trainer_threaded</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.cross_validate_trainer_threaded" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>cross_validate_trainer_threaded(trainer: dlib.svm_c_trainer_radial_basis, x: dlib.vectors, y: dlib.array, folds: int, num_threads: int) -&gt; dlib._binary_test</li>
<li>cross_validate_trainer_threaded(trainer: dlib.svm_c_trainer_sparse_radial_basis, x: dlib.sparse_vectors, y: dlib.array, folds: int, num_threads: int) -&gt; dlib._binary_test</li>
<li>cross_validate_trainer_threaded(trainer: dlib.svm_c_trainer_histogram_intersection, x: dlib.vectors, y: dlib.array, folds: int, num_threads: int) -&gt; dlib._binary_test</li>
<li>cross_validate_trainer_threaded(trainer: dlib.svm_c_trainer_sparse_histogram_intersection, x: dlib.sparse_vectors, y: dlib.array, folds: int, num_threads: int) -&gt; dlib._binary_test</li>
<li>cross_validate_trainer_threaded(trainer: dlib.svm_c_trainer_linear, x: dlib.vectors, y: dlib.array, folds: int, num_threads: int) -&gt; dlib._binary_test</li>
<li>cross_validate_trainer_threaded(trainer: dlib.svm_c_trainer_sparse_linear, x: dlib.sparse_vectors, y: dlib.array, folds: int, num_threads: int) -&gt; dlib._binary_test</li>
<li>cross_validate_trainer_threaded(trainer: dlib.rvm_trainer_radial_basis, x: dlib.vectors, y: dlib.array, folds: int, num_threads: int) -&gt; dlib._binary_test</li>
<li>cross_validate_trainer_threaded(trainer: dlib.rvm_trainer_sparse_radial_basis, x: dlib.sparse_vectors, y: dlib.array, folds: int, num_threads: int) -&gt; dlib._binary_test</li>
<li>cross_validate_trainer_threaded(trainer: dlib.rvm_trainer_histogram_intersection, x: dlib.vectors, y: dlib.array, folds: int, num_threads: int) -&gt; dlib._binary_test</li>
<li>cross_validate_trainer_threaded(trainer: dlib.rvm_trainer_sparse_histogram_intersection, x: dlib.sparse_vectors, y: dlib.array, folds: int, num_threads: int) -&gt; dlib._binary_test</li>
<li>cross_validate_trainer_threaded(trainer: dlib.rvm_trainer_linear, x: dlib.vectors, y: dlib.array, folds: int, num_threads: int) -&gt; dlib._binary_test</li>
<li>cross_validate_trainer_threaded(trainer: dlib.rvm_trainer_sparse_linear, x: dlib.sparse_vectors, y: dlib.array, folds: int, num_threads: int) -&gt; dlib._binary_test</li>
</ol>
</dd></dl>

<dl class="function">
<dt id="dlib.distance_to_line">
<code class="descclassname">dlib.</code><code class="descname">distance_to_line</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.distance_to_line" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>distance_to_line(l: dlib.line, p: dlib.point) -&gt; float</li>
<li>distance_to_line(l: dlib.line, p: dlib.dpoint) -&gt; float</li>
</ol>
<p>returns abs(signed_distance_to_line(l,p))</p>
</dd></dl>

<dl class="function">
<dt id="dlib.dot">
<code class="descclassname">dlib.</code><code class="descname">dot</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.dot" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>dot(arg0: dlib.vector, arg1: dlib.vector) -&gt; float</li>
</ol>
<p>Compute the dot product between two dense column vectors.</p>
<ol class="arabic simple" start="2">
<li>dot(a: dlib.point, b: dlib.point) -&gt; int</li>
</ol>
<p>Returns the dot product of the points a and b.</p>
<ol class="arabic simple" start="3">
<li>dot(a: dlib.dpoint, b: dlib.dpoint) -&gt; float</li>
</ol>
<p>Returns the dot product of the points a and b.</p>
</dd></dl>

<dl class="class">
<dt id="dlib.dpoint">
<em class="property">class </em><code class="descclassname">dlib.</code><code class="descname">dpoint</code><a class="headerlink" href="#dlib.dpoint" title="Permalink to this definition">¶</a></dt>
<dd><p>This object represents a single point of floating point coordinates that maps directly to a dlib::dpoint.</p>
<dl class="method">
<dt id="dlib.dpoint.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.dpoint.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: dlib.dpoint, x: float, y: float) -&gt; None</li>
<li>__init__(self: dlib.dpoint, p: dlib.point) -&gt; None</li>
<li>__init__(self: dlib.dpoint, v: numpy.ndarray[int64]) -&gt; None</li>
<li>__init__(self: dlib.dpoint, v: numpy.ndarray[float32]) -&gt; None</li>
<li>__init__(self: dlib.dpoint, v: numpy.ndarray[float64]) -&gt; None</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="dlib.dpoint.normalize">
<code class="descname">normalize</code><span class="sig-paren">(</span><em>self: dlib.dpoint</em><span class="sig-paren">)</span> &rarr; dlib.dpoint<a class="headerlink" href="#dlib.dpoint.normalize" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a unit normalized copy of this vector.</p>
</dd></dl>

<dl class="attribute">
<dt id="dlib.dpoint.x">
<code class="descname">x</code><a class="headerlink" href="#dlib.dpoint.x" title="Permalink to this definition">¶</a></dt>
<dd><p>The x-coordinate of the dpoint.</p>
</dd></dl>

<dl class="attribute">
<dt id="dlib.dpoint.y">
<code class="descname">y</code><a class="headerlink" href="#dlib.dpoint.y" title="Permalink to this definition">¶</a></dt>
<dd><p>The y-coordinate of the dpoint.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="dlib.dpoints">
<em class="property">class </em><code class="descclassname">dlib.</code><code class="descname">dpoints</code><a class="headerlink" href="#dlib.dpoints" title="Permalink to this definition">¶</a></dt>
<dd><p>An array of dpoint objects.</p>
<dl class="method">
<dt id="dlib.dpoints.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.dpoints.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: dlib.dpoints) -&gt; None</li>
<li>__init__(self: dlib.dpoints, arg0: dlib.dpoints) -&gt; None</li>
</ol>
<p>Copy constructor</p>
<ol class="arabic simple" start="3">
<li>__init__(self: dlib.dpoints, arg0: iterable) -&gt; None</li>
<li>__init__(self: dlib.dpoints, initial_size: int) -&gt; None</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="dlib.dpoints.append">
<code class="descname">append</code><span class="sig-paren">(</span><em>self: dlib.dpoints</em>, <em>x: dlib.dpoint</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.dpoints.append" title="Permalink to this definition">¶</a></dt>
<dd><p>Add an item to the end of the list</p>
</dd></dl>

<dl class="method">
<dt id="dlib.dpoints.clear">
<code class="descname">clear</code><span class="sig-paren">(</span><em>self: dlib.dpoints</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.dpoints.clear" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dlib.dpoints.count">
<code class="descname">count</code><span class="sig-paren">(</span><em>self: dlib.dpoints</em>, <em>x: dlib.dpoint</em><span class="sig-paren">)</span> &rarr; int<a class="headerlink" href="#dlib.dpoints.count" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of times <code class="docutils literal"><span class="pre">x</span></code> appears in the list</p>
</dd></dl>

<dl class="method">
<dt id="dlib.dpoints.extend">
<code class="descname">extend</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.dpoints.extend" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>extend(self: dlib.dpoints, L: dlib.dpoints) -&gt; None</li>
</ol>
<p>Extend the list by appending all the items in the given list</p>
<ol class="arabic simple" start="2">
<li>extend(self: dlib.dpoints, arg0: list) -&gt; None</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="dlib.dpoints.insert">
<code class="descname">insert</code><span class="sig-paren">(</span><em>self: dlib.dpoints</em>, <em>i: int</em>, <em>x: dlib.dpoint</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.dpoints.insert" title="Permalink to this definition">¶</a></dt>
<dd><p>Insert an item at a given position.</p>
</dd></dl>

<dl class="method">
<dt id="dlib.dpoints.pop">
<code class="descname">pop</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.dpoints.pop" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>pop(self: dlib.dpoints) -&gt; dlib.dpoint</li>
</ol>
<p>Remove and return the last item</p>
<ol class="arabic simple" start="2">
<li>pop(self: dlib.dpoints, i: int) -&gt; dlib.dpoint</li>
</ol>
<p>Remove and return the item at index <code class="docutils literal"><span class="pre">i</span></code></p>
</dd></dl>

<dl class="method">
<dt id="dlib.dpoints.remove">
<code class="descname">remove</code><span class="sig-paren">(</span><em>self: dlib.dpoints</em>, <em>x: dlib.dpoint</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.dpoints.remove" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove the first item from the list whose value is x. It is an error if there is no such item.</p>
</dd></dl>

<dl class="method">
<dt id="dlib.dpoints.resize">
<code class="descname">resize</code><span class="sig-paren">(</span><em>self: dlib.dpoints</em>, <em>arg0: int</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.dpoints.resize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="dlib.drectangle">
<em class="property">class </em><code class="descclassname">dlib.</code><code class="descname">drectangle</code><a class="headerlink" href="#dlib.drectangle" title="Permalink to this definition">¶</a></dt>
<dd><p>This object represents a rectangular area of an image with floating point coordinates.</p>
<dl class="method">
<dt id="dlib.drectangle.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.drectangle.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: dlib.drectangle, left: float, top: float, right: float, bottom: float) -&gt; None</li>
<li>__init__(self: dlib.drectangle, rect: dlib.rectangle) -&gt; None</li>
<li>__init__(self: dlib.drectangle, rect: dlib.drectangle) -&gt; None</li>
<li>__init__(self: dlib.drectangle) -&gt; None</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="dlib.drectangle.area">
<code class="descname">area</code><span class="sig-paren">(</span><em>self: dlib.drectangle</em><span class="sig-paren">)</span> &rarr; float<a class="headerlink" href="#dlib.drectangle.area" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dlib.drectangle.bl_corner">
<code class="descname">bl_corner</code><span class="sig-paren">(</span><em>self: dlib.drectangle</em><span class="sig-paren">)</span> &rarr; dlib.dpoint<a class="headerlink" href="#dlib.drectangle.bl_corner" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the bottom left corner of the rectangle.</p>
</dd></dl>

<dl class="method">
<dt id="dlib.drectangle.bottom">
<code class="descname">bottom</code><span class="sig-paren">(</span><em>self: dlib.drectangle</em><span class="sig-paren">)</span> &rarr; float<a class="headerlink" href="#dlib.drectangle.bottom" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dlib.drectangle.br_corner">
<code class="descname">br_corner</code><span class="sig-paren">(</span><em>self: dlib.drectangle</em><span class="sig-paren">)</span> &rarr; dlib.dpoint<a class="headerlink" href="#dlib.drectangle.br_corner" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the bottom right corner of the rectangle.</p>
</dd></dl>

<dl class="method">
<dt id="dlib.drectangle.center">
<code class="descname">center</code><span class="sig-paren">(</span><em>self: dlib.drectangle</em><span class="sig-paren">)</span> &rarr; dlib.point<a class="headerlink" href="#dlib.drectangle.center" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dlib.drectangle.contains">
<code class="descname">contains</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.drectangle.contains" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>contains(self: dlib.drectangle, point: dlib.point) -&gt; bool</li>
<li>contains(self: dlib.drectangle, point: dlib.dpoint) -&gt; bool</li>
<li>contains(self: dlib.drectangle, x: int, y: int) -&gt; bool</li>
<li>contains(self: dlib.drectangle, rectangle: dlib.drectangle) -&gt; bool</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="dlib.drectangle.dcenter">
<code class="descname">dcenter</code><span class="sig-paren">(</span><em>self: dlib.drectangle</em><span class="sig-paren">)</span> &rarr; dlib.point<a class="headerlink" href="#dlib.drectangle.dcenter" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dlib.drectangle.height">
<code class="descname">height</code><span class="sig-paren">(</span><em>self: dlib.drectangle</em><span class="sig-paren">)</span> &rarr; float<a class="headerlink" href="#dlib.drectangle.height" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dlib.drectangle.intersect">
<code class="descname">intersect</code><span class="sig-paren">(</span><em>self: dlib.drectangle</em>, <em>rectangle: dlib.drectangle</em><span class="sig-paren">)</span> &rarr; dlib.drectangle<a class="headerlink" href="#dlib.drectangle.intersect" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dlib.drectangle.is_empty">
<code class="descname">is_empty</code><span class="sig-paren">(</span><em>self: dlib.drectangle</em><span class="sig-paren">)</span> &rarr; bool<a class="headerlink" href="#dlib.drectangle.is_empty" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dlib.drectangle.left">
<code class="descname">left</code><span class="sig-paren">(</span><em>self: dlib.drectangle</em><span class="sig-paren">)</span> &rarr; float<a class="headerlink" href="#dlib.drectangle.left" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dlib.drectangle.right">
<code class="descname">right</code><span class="sig-paren">(</span><em>self: dlib.drectangle</em><span class="sig-paren">)</span> &rarr; float<a class="headerlink" href="#dlib.drectangle.right" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dlib.drectangle.tl_corner">
<code class="descname">tl_corner</code><span class="sig-paren">(</span><em>self: dlib.drectangle</em><span class="sig-paren">)</span> &rarr; dlib.dpoint<a class="headerlink" href="#dlib.drectangle.tl_corner" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the top left corner of the rectangle.</p>
</dd></dl>

<dl class="method">
<dt id="dlib.drectangle.top">
<code class="descname">top</code><span class="sig-paren">(</span><em>self: dlib.drectangle</em><span class="sig-paren">)</span> &rarr; float<a class="headerlink" href="#dlib.drectangle.top" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dlib.drectangle.tr_corner">
<code class="descname">tr_corner</code><span class="sig-paren">(</span><em>self: dlib.drectangle</em><span class="sig-paren">)</span> &rarr; dlib.dpoint<a class="headerlink" href="#dlib.drectangle.tr_corner" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the top right corner of the rectangle.</p>
</dd></dl>

<dl class="method">
<dt id="dlib.drectangle.width">
<code class="descname">width</code><span class="sig-paren">(</span><em>self: dlib.drectangle</em><span class="sig-paren">)</span> &rarr; float<a class="headerlink" href="#dlib.drectangle.width" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="dlib.equalize_histogram">
<code class="descclassname">dlib.</code><code class="descname">equalize_histogram</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.equalize_histogram" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>equalize_histogram(img: numpy.ndarray[(rows,cols),uint8]) -&gt; numpy.ndarray[(rows,cols),uint8]</li>
<li>equalize_histogram(img: numpy.ndarray[(rows,cols),uint16]) -&gt; numpy.ndarray[(rows,cols),uint16]</li>
</ol>
<p>Returns a histogram equalized version of img.</p>
</dd></dl>

<dl class="function">
<dt id="dlib.extract_image_4points">
<code class="descclassname">dlib.</code><code class="descname">extract_image_4points</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.extract_image_4points" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>extract_image_4points(img: numpy.ndarray[(rows,cols),uint8], corners: list, rows: int, columns: int) -&gt; numpy.ndarray[(rows,cols),uint8]</li>
<li>extract_image_4points(img: numpy.ndarray[(rows,cols),uint16], corners: list, rows: int, columns: int) -&gt; numpy.ndarray[(rows,cols),uint16]</li>
<li>extract_image_4points(img: numpy.ndarray[(rows,cols),uint32], corners: list, rows: int, columns: int) -&gt; numpy.ndarray[(rows,cols),uint32]</li>
<li>extract_image_4points(img: numpy.ndarray[(rows,cols),uint64], corners: list, rows: int, columns: int) -&gt; numpy.ndarray[(rows,cols),uint64]</li>
<li>extract_image_4points(img: numpy.ndarray[(rows,cols),int8], corners: list, rows: int, columns: int) -&gt; numpy.ndarray[(rows,cols),int8]</li>
<li>extract_image_4points(img: numpy.ndarray[(rows,cols),int16], corners: list, rows: int, columns: int) -&gt; numpy.ndarray[(rows,cols),int16]</li>
<li>extract_image_4points(img: numpy.ndarray[(rows,cols),int32], corners: list, rows: int, columns: int) -&gt; numpy.ndarray[(rows,cols),int32]</li>
<li>extract_image_4points(img: numpy.ndarray[(rows,cols),int64], corners: list, rows: int, columns: int) -&gt; numpy.ndarray[(rows,cols),int64]</li>
<li>extract_image_4points(img: numpy.ndarray[(rows,cols),float32], corners: list, rows: int, columns: int) -&gt; numpy.ndarray[(rows,cols),float32]</li>
<li>extract_image_4points(img: numpy.ndarray[(rows,cols),float64], corners: list, rows: int, columns: int) -&gt; numpy.ndarray[(rows,cols),float64]</li>
<li>extract_image_4points(img: numpy.ndarray[(rows,cols,3),uint8], corners: list, rows: int, columns: int) -&gt; numpy.ndarray[(rows,cols,3),uint8]</li>
</ol>
<dl class="docutils">
<dt>requires </dt>
<dd><ul class="first last simple">
<li>corners is a list of dpoint or line objects.</li>
<li>len(corners) == 4</li>
<li>rows &gt;= 0</li>
<li>columns &gt;= 0</li>
</ul>
</dd>
<dt>ensures </dt>
<dd><ul class="first last">
<li><p class="first">The returned image has the given number of rows and columns.</p>
</li>
<li><dl class="first docutils">
<dt>if (corners contains dpoints) then </dt>
<dd><ul class="first last simple">
<li>The 4 points in corners define a convex quadrilateral and this function 
extracts that part of the input image img and returns it.  Therefore, 
each corner of the quadrilateral is associated to a corner of the 
extracted image and bilinear interpolation and a projective mapping is 
used to transform the pixels in the quadrilateral into the output image. 
To determine which corners of the quadrilateral map to which corners of 
the returned image we fit the tightest possible rectangle to the 
quadrilateral and map its vertices to their nearest rectangle corners. 
These corners are then trivially mapped to the output image (i.e.  upper 
left corner to upper left corner, upper right corner to upper right 
corner, etc.).</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>else </dt>
<dd><ul class="first last simple">
<li>This routine finds the 4 intersecting points of the given lines which 
form a convex quadrilateral and uses them as described above to extract 
an image.   i.e. It just then calls: extract_image_4points(img, 
intersections_between_lines, rows, columns).</li>
<li>If no convex quadrilateral can be made from the given lines then this 
routine throws no_convex_quadrilateral.</li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="dlib.extract_image_chip">
<code class="descclassname">dlib.</code><code class="descname">extract_image_chip</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.extract_image_chip" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p class="first">extract_image_chip(img: numpy.ndarray[(rows,cols),uint8], chip_location: dlib.chip_details) -&gt; numpy.ndarray[(rows,cols),uint8]</p>
</li>
<li><p class="first">extract_image_chip(img: numpy.ndarray[(rows,cols),uint16], chip_location: dlib.chip_details) -&gt; numpy.ndarray[(rows,cols),uint16]</p>
</li>
<li><p class="first">extract_image_chip(img: numpy.ndarray[(rows,cols),uint32], chip_location: dlib.chip_details) -&gt; numpy.ndarray[(rows,cols),uint32]</p>
</li>
<li><p class="first">extract_image_chip(img: numpy.ndarray[(rows,cols),uint64], chip_location: dlib.chip_details) -&gt; numpy.ndarray[(rows,cols),uint64]</p>
</li>
<li><p class="first">extract_image_chip(img: numpy.ndarray[(rows,cols),int8], chip_location: dlib.chip_details) -&gt; numpy.ndarray[(rows,cols),int8]</p>
</li>
<li><p class="first">extract_image_chip(img: numpy.ndarray[(rows,cols),int16], chip_location: dlib.chip_details) -&gt; numpy.ndarray[(rows,cols),int16]</p>
</li>
<li><p class="first">extract_image_chip(img: numpy.ndarray[(rows,cols),int32], chip_location: dlib.chip_details) -&gt; numpy.ndarray[(rows,cols),int32]</p>
</li>
<li><p class="first">extract_image_chip(img: numpy.ndarray[(rows,cols),int64], chip_location: dlib.chip_details) -&gt; numpy.ndarray[(rows,cols),int64]</p>
</li>
<li><p class="first">extract_image_chip(img: numpy.ndarray[(rows,cols),float32], chip_location: dlib.chip_details) -&gt; numpy.ndarray[(rows,cols),float32]</p>
</li>
<li><p class="first">extract_image_chip(img: numpy.ndarray[(rows,cols),float64], chip_location: dlib.chip_details) -&gt; numpy.ndarray[(rows,cols),float64]</p>
</li>
<li><p class="first">extract_image_chip(img: numpy.ndarray[(rows,cols,3),uint8], chip_location: dlib.chip_details) -&gt; numpy.ndarray[(rows,cols,3),uint8]</p>
<p>This routine is just like extract_image_chips() except it takes a single 
chip_details object and returns a single chip image rather than a list of images.</p>
</li>
</ol>
</dd></dl>

<dl class="function">
<dt id="dlib.extract_image_chips">
<code class="descclassname">dlib.</code><code class="descname">extract_image_chips</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.extract_image_chips" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>extract_image_chips(img: numpy.ndarray[(rows,cols),uint8], chip_locations: list) -&gt; list</li>
<li>extract_image_chips(img: numpy.ndarray[(rows,cols),uint16], chip_locations: list) -&gt; list</li>
<li>extract_image_chips(img: numpy.ndarray[(rows,cols),uint32], chip_locations: list) -&gt; list</li>
<li>extract_image_chips(img: numpy.ndarray[(rows,cols),uint64], chip_locations: list) -&gt; list</li>
<li>extract_image_chips(img: numpy.ndarray[(rows,cols),int8], chip_locations: list) -&gt; list</li>
<li>extract_image_chips(img: numpy.ndarray[(rows,cols),int16], chip_locations: list) -&gt; list</li>
<li>extract_image_chips(img: numpy.ndarray[(rows,cols),int32], chip_locations: list) -&gt; list</li>
<li>extract_image_chips(img: numpy.ndarray[(rows,cols),int64], chip_locations: list) -&gt; list</li>
<li>extract_image_chips(img: numpy.ndarray[(rows,cols),float32], chip_locations: list) -&gt; list</li>
<li>extract_image_chips(img: numpy.ndarray[(rows,cols),float64], chip_locations: list) -&gt; list</li>
<li>extract_image_chips(img: numpy.ndarray[(rows,cols,3),uint8], chip_locations: list) -&gt; list</li>
</ol>
<dl class="docutils">
<dt>requires </dt>
<dd><ul class="first last">
<li><dl class="first docutils">
<dt>for all valid i:  </dt>
<dd><ul class="first last simple">
<li>chip_locations[i].rect.is_empty() == false</li>
<li>chip_locations[i].rows*chip_locations[i].cols != 0</li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
<dt>ensures </dt>
<dd><ul class="first last">
<li><p class="first">This function extracts &#8220;chips&#8221; from an image.  That is, it takes a list of 
rectangular sub-windows (i.e. chips) within an image and extracts those 
sub-windows, storing each into its own image.  It also scales and rotates the 
image chips according to the instructions inside each chip_details object. 
It uses bilinear interpolation.</p>
</li>
<li><p class="first">The extracted image chips are returned in a python list of numpy arrays.  The 
length of the returned array is len(chip_locations).</p>
</li>
<li><dl class="first docutils">
<dt>Let CHIPS be the returned array, then we have: </dt>
<dd><ul class="first last">
<li><dl class="first docutils">
<dt>for all valid i: </dt>
<dd><ul class="first last simple">
<li>#CHIPS[i] == The image chip extracted from the position 
chip_locations[i].rect in img.</li>
<li>#CHIPS[i].shape(0) == chip_locations[i].rows</li>
<li>#CHIPS[i].shape(1) == chip_locations[i].cols</li>
<li>The image will have been rotated counter-clockwise by 
chip_locations[i].angle radians, around the center of 
chip_locations[i].rect, before the chip was extracted.</li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</li>
<li><p class="first">Any pixels in an image chip that go outside img are set to 0 (i.e. black).</p>
</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="dlib.face_recognition_model_v1">
<em class="property">class </em><code class="descclassname">dlib.</code><code class="descname">face_recognition_model_v1</code><a class="headerlink" href="#dlib.face_recognition_model_v1" title="Permalink to this definition">¶</a></dt>
<dd><p>This object maps human faces into 128D vectors where pictures of the same person are mapped near to each other and pictures of different people are mapped far apart.  The constructor loads the face recognition model from a file. The model file is available here: <a class="reference external" href="http://dlib.net/files/dlib_face_recognition_resnet_model_v1.dat.bz2">http://dlib.net/files/dlib_face_recognition_resnet_model_v1.dat.bz2</a></p>
<dl class="method">
<dt id="dlib.face_recognition_model_v1.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: dlib.face_recognition_model_v1</em>, <em>arg0: unicode</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.face_recognition_model_v1.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dlib.face_recognition_model_v1.compute_face_descriptor">
<code class="descname">compute_face_descriptor</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.face_recognition_model_v1.compute_face_descriptor" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>compute_face_descriptor(self: dlib.face_recognition_model_v1, img: numpy.ndarray[(rows,cols,3),uint8], face: dlib.full_object_detection, num_jitters: int=0L, padding: float=0.25) -&gt; dlib.vector</li>
</ol>
<p>Takes an image and a full_object_detection that references a face in that image and converts it into a 128D face descriptor. If num_jitters&gt;1 then each face will be randomly jittered slightly num_jitters times, each run through the 128D projection, and the average used as the face descriptor. Optionally allows to override default padding of 0.25 around the face.</p>
<ol class="arabic simple" start="2">
<li>compute_face_descriptor(self: dlib.face_recognition_model_v1, img: numpy.ndarray[(rows,cols,3),uint8], num_jitters: int=0L) -&gt; dlib.vector</li>
</ol>
<p>Takes an aligned face image of size 150x150 and converts it into a 128D face descriptor.Note that the alignment should be done in the same way dlib.get_face_chip does it.If num_jitters&gt;1 then image will be randomly jittered slightly num_jitters times, each run through the 128D projection, and the average used as the face descriptor.</p>
<ol class="arabic simple" start="3">
<li>compute_face_descriptor(self: dlib.face_recognition_model_v1, img: numpy.ndarray[(rows,cols,3),uint8], faces: dlib.full_object_detections, num_jitters: int=0L, padding: float=0.25) -&gt; dlib.vectors</li>
</ol>
<p>Takes an image and an array of full_object_detections that reference faces in that image and converts them into 128D face descriptors.  If num_jitters&gt;1 then each face will be randomly jittered slightly num_jitters times, each run through the 128D projection, and the average used as the face descriptor. Optionally allows to override default padding of 0.25 around the face.</p>
<ol class="arabic simple" start="4">
<li>compute_face_descriptor(self: dlib.face_recognition_model_v1, batch_img: List[numpy.ndarray[(rows,cols,3),uint8]], batch_faces: List[dlib.full_object_detections], num_jitters: int=0L, padding: float=0.25) -&gt; dlib.vectorss</li>
</ol>
<p>Takes an array of images and an array of arrays of full_object_detections. <cite>batch_faces[i]</cite> must be an array of full_object_detections corresponding to the image <cite>batch_img[i]</cite>, referencing faces in that image. Every face will be converted into 128D face descriptors.  If num_jitters&gt;1 then each face will be randomly jittered slightly num_jitters times, each run through the 128D projection, and the average used as the face descriptor. Optionally allows to override default padding of 0.25 around the face.</p>
<ol class="arabic simple" start="5">
<li>compute_face_descriptor(self: dlib.face_recognition_model_v1, batch_img: List[numpy.ndarray[(rows,cols,3),uint8]], num_jitters: int=0L) -&gt; dlib.vectors</li>
</ol>
<p>Takes an array of aligned images of faces of size 150_x_150.Note that the alignment should be done in the same way dlib.get_face_chip does it.Every face will be converted into 128D face descriptors.  If num_jitters&gt;1 then each face will be randomly jittered slightly num_jitters times, each run through the 128D projection, and the average used as the face descriptor.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="dlib.fhog_object_detector">
<em class="property">class </em><code class="descclassname">dlib.</code><code class="descname">fhog_object_detector</code><a class="headerlink" href="#dlib.fhog_object_detector" title="Permalink to this definition">¶</a></dt>
<dd><p>This object represents a sliding window histogram-of-oriented-gradients based object detector.</p>
<dl class="method">
<dt id="dlib.fhog_object_detector.__call__">
<code class="descname">__call__</code><span class="sig-paren">(</span><em>self: dlib.fhog_object_detector</em>, <em>image: array</em>, <em>upsample_num_times: int=0L</em><span class="sig-paren">)</span> &rarr; dlib.rectangles<a class="headerlink" href="#dlib.fhog_object_detector.__call__" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>requires </dt>
<dd><ul class="first last simple">
<li>image is a numpy ndarray containing either an 8bit grayscale or RGB 
image.</li>
<li>upsample_num_times &gt;= 0</li>
</ul>
</dd>
<dt>ensures </dt>
<dd><ul class="first last simple">
<li>This function runs the object detector on the input image and returns 
a list of detections.</li>
<li>Upsamples the image upsample_num_times before running the basic 
detector.</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dlib.fhog_object_detector.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: dlib.fhog_object_detector</em>, <em>arg0: unicode</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.fhog_object_detector.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Loads an object detector from a file that contains the output of the 
train_simple_object_detector() routine or a serialized C++ object of type
object_detector&lt;scan_fhog_pyramid&lt;pyramid_down&lt;6&gt;&gt;&gt;.</p>
</dd></dl>

<dl class="attribute">
<dt id="dlib.fhog_object_detector.detection_window_height">
<code class="descname">detection_window_height</code><a class="headerlink" href="#dlib.fhog_object_detector.detection_window_height" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.fhog_object_detector.detection_window_width">
<code class="descname">detection_window_width</code><a class="headerlink" href="#dlib.fhog_object_detector.detection_window_width" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.fhog_object_detector.num_detectors">
<code class="descname">num_detectors</code><a class="headerlink" href="#dlib.fhog_object_detector.num_detectors" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dlib.fhog_object_detector.run">
<code class="descname">run</code><span class="sig-paren">(</span><em>self: dlib.fhog_object_detector</em>, <em>image: array</em>, <em>upsample_num_times: int=0L</em>, <em>adjust_threshold: float=0.0</em><span class="sig-paren">)</span> &rarr; tuple<a class="headerlink" href="#dlib.fhog_object_detector.run" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>requires </dt>
<dd><ul class="first last simple">
<li>image is a numpy ndarray containing either an 8bit grayscale or RGB 
image.</li>
<li>upsample_num_times &gt;= 0</li>
</ul>
</dd>
<dt>ensures </dt>
<dd><ul class="first last simple">
<li>This function runs the object detector on the input image and returns 
a tuple of (list of detections, list of scores, list of weight_indices).</li>
<li>Upsamples the image upsample_num_times before running the basic 
detector.</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dlib.fhog_object_detector.run_multiple">
<code class="descname">run_multiple</code><span class="sig-paren">(</span><em>detectors: list</em>, <em>image: array</em>, <em>upsample_num_times: int=0L</em>, <em>adjust_threshold: float=0.0</em><span class="sig-paren">)</span> &rarr; tuple<a class="headerlink" href="#dlib.fhog_object_detector.run_multiple" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>requires </dt>
<dd><ul class="first last simple">
<li>detectors is a list of detectors.</li>
<li>image is a numpy ndarray containing either an 8bit grayscale or RGB 
image.</li>
<li>upsample_num_times &gt;= 0</li>
</ul>
</dd>
<dt>ensures </dt>
<dd><ul class="first last simple">
<li>This function runs the list of object detectors at once on the input image and returns 
a tuple of (list of detections, list of scores, list of weight_indices).</li>
<li>Upsamples the image upsample_num_times before running the basic 
detector.</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dlib.fhog_object_detector.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>self: dlib.fhog_object_detector</em>, <em>detector_output_filename: unicode</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.fhog_object_detector.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save a simple_object_detector to the provided path.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="dlib.find_bright_keypoints">
<code class="descclassname">dlib.</code><code class="descname">find_bright_keypoints</code><span class="sig-paren">(</span><em>xx: numpy.ndarray[(rows,cols),float32], xy: numpy.ndarray[(rows,cols),float32], yy: numpy.ndarray[(rows,cols),float32]</em><span class="sig-paren">)</span> &rarr; numpy.ndarray[(rows,cols),float32]<a class="headerlink" href="#dlib.find_bright_keypoints" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>requires </dt>
<dd><ul class="first last simple">
<li>xx, xy, and yy all have the same dimensions.</li>
</ul>
</dd>
<dt>ensures </dt>
<dd><ul class="first last">
<li><p class="first">This routine finds bright &#8220;keypoints&#8221; in an image.  In general, these are 
bright/white localized blobs.  It does this by computing the determinant of 
the image Hessian at each location and storing this value into the returned 
image if both eigenvalues of the Hessian are negative.  If either eigenvalue 
is positive then the output value for that pixel is 0.  I.e.</p>
<blockquote>
<div><ul>
<li><p class="first">Let OUT denote the returned image.</p>
</li>
<li><dl class="first docutils">
<dt>for all valid r,c: </dt>
<dd><ul class="first last simple">
<li>OUT[r][c] == a number &gt;= 0 and larger values indicate the 
presence of a keypoint at this pixel location.</li>
</ul>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">We assume that xx, xy, and yy are the 3 second order gradients of the image 
in question.  You can obtain these gradients using the image_gradients class.</p>
</li>
<li><p class="first">The output image will have the same dimensions as the input images.</p>
</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="dlib.find_bright_lines">
<code class="descclassname">dlib.</code><code class="descname">find_bright_lines</code><span class="sig-paren">(</span><em>xx: numpy.ndarray[(rows,cols),float32], xy: numpy.ndarray[(rows,cols),float32], yy: numpy.ndarray[(rows,cols),float32]</em><span class="sig-paren">)</span> &rarr; tuple<a class="headerlink" href="#dlib.find_bright_lines" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>requires </dt>
<dd><ul class="first last simple">
<li>xx, xy, and yy all have the same dimensions.</li>
</ul>
</dd>
<dt>ensures </dt>
<dd><ul class="first last">
<li><p class="first">This routine is similar to sobel_edge_detector(), except instead of finding 
an edge it finds a bright/white line.  For example, the border between a 
black piece of paper and a white table is an edge, but a curve drawn with a 
pencil on a piece of paper makes a line.  Therefore, the output of this 
routine is a vector field encoded in the horz and vert images, which are 
returned in a tuple where the first element is horz and the second is vert.</p>
<p>The vector obtains a large magnitude when centered on a bright line in an image and the 
direction of the vector is perpendicular to the line.  To be very precise, 
each vector points in the direction of greatest change in second derivative 
and the magnitude of the vector encodes the derivative magnitude in that 
direction.  Moreover, if the second derivative is positive then the output 
vector is zero.  This zeroing if positive gradients causes the output to be 
sensitive only to bright lines surrounded by darker pixels.</p>
</li>
<li><p class="first">We assume that xx, xy, and yy are the 3 second order gradients of the image 
in question.  You can obtain these gradients using the image_gradients class.</p>
</li>
<li><p class="first">The output images will have the same dimensions as the input images.</p>
</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="dlib.find_candidate_object_locations">
<code class="descclassname">dlib.</code><code class="descname">find_candidate_object_locations</code><span class="sig-paren">(</span><em>image: array</em>, <em>rects: list</em>, <em>kvals: tuple=(50L</em>, <em>200L</em>, <em>3L)</em>, <em>min_size: int=20L</em>, <em>max_merging_iterations: int=50L</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.find_candidate_object_locations" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns found candidate objects
requires</p>
<blockquote>
<div><ul class="simple">
<li>image == an image object which is a numpy ndarray</li>
<li>len(kvals) == 3</li>
<li>kvals should be a tuple that specifies the range of k values to use.  In
particular, it should take the form (start, end, num) where num &gt; 0.</li>
</ul>
</div></blockquote>
<dl class="docutils">
<dt>ensures</dt>
<dd><ul class="first last">
<li><p class="first">This function takes an input image and generates a set of candidate
rectangles which are expected to bound any objects in the image.  It does
this by running a version of the segment_image() routine on the image and
then reports rectangles containing each of the segments as well as rectangles
containing unions of adjacent segments.  The basic idea is described in the
paper:</p>
<blockquote>
<div><p>Segmentation as Selective Search for Object Recognition by Koen E. A. van de Sande, et al.</p>
</div></blockquote>
<p>Note that this function deviates from what is described in the paper slightly. 
See the code for details.</p>
</li>
<li><p class="first">The basic segmentation is performed kvals[2] times, each time with the k parameter
(see segment_image() and the Felzenszwalb paper for details on k) set to a different
value from the range of numbers linearly spaced between kvals[0] to kvals[1].</p>
</li>
<li><p class="first">When doing the basic segmentations prior to any box merging, we discard all
rectangles that have an area &lt; min_size.  Therefore, all outputs and
subsequent merged rectangles are built out of rectangles that contain at
least min_size pixels.  Note that setting min_size to a smaller value than
you might otherwise be interested in using can be useful since it allows a
larger number of possible merged boxes to be created.</p>
</li>
<li><p class="first">There are max_merging_iterations rounds of neighboring blob merging.
Therefore, this parameter has some effect on the number of output rectangles
you get, with larger values of the parameter giving more output rectangles.</p>
</li>
<li><p class="first">This function appends the output rectangles into #rects.  This means that any
rectangles in rects before this function was called will still be in there
after it terminates.  Note further that #rects will not contain any duplicate
rectangles.  That is, for all valid i and j where i != j it will be true
that:</p>
<blockquote>
<div><ul class="simple">
<li>#rects[i] != rects[j]</li>
</ul>
</div></blockquote>
</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="dlib.find_dark_keypoints">
<code class="descclassname">dlib.</code><code class="descname">find_dark_keypoints</code><span class="sig-paren">(</span><em>xx: numpy.ndarray[(rows,cols),float32], xy: numpy.ndarray[(rows,cols),float32], yy: numpy.ndarray[(rows,cols),float32]</em><span class="sig-paren">)</span> &rarr; numpy.ndarray[(rows,cols),float32]<a class="headerlink" href="#dlib.find_dark_keypoints" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>requires </dt>
<dd><ul class="first last simple">
<li>xx, xy, and yy all have the same dimensions.</li>
</ul>
</dd>
<dt>ensures </dt>
<dd><ul class="first last">
<li><p class="first">This routine finds dark &#8220;keypoints&#8221; in an image.  In general, these are 
dark localized blobs.  It does this by computing the determinant of 
the image Hessian at each location and storing this value into the returned 
image if both eigenvalues of the Hessian are negative.  If either eigenvalue 
is negative then the output value for that pixel is 0.  I.e.</p>
<blockquote>
<div><ul>
<li><p class="first">Let OUT denote the returned image.</p>
</li>
<li><dl class="first docutils">
<dt>for all valid r,c: </dt>
<dd><ul class="first last simple">
<li>OUT[r][c] == a number &gt;= 0 and larger values indicate the 
presence of a keypoint at this pixel location.</li>
</ul>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">We assume that xx, xy, and yy are the 3 second order gradients of the image 
in question.  You can obtain these gradients using the image_gradients class.</p>
</li>
<li><p class="first">The output image will have the same dimensions as the input images.</p>
</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="dlib.find_dark_lines">
<code class="descclassname">dlib.</code><code class="descname">find_dark_lines</code><span class="sig-paren">(</span><em>xx: numpy.ndarray[(rows,cols),float32], xy: numpy.ndarray[(rows,cols),float32], yy: numpy.ndarray[(rows,cols),float32]</em><span class="sig-paren">)</span> &rarr; tuple<a class="headerlink" href="#dlib.find_dark_lines" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>requires </dt>
<dd><ul class="first last simple">
<li>xx, xy, and yy all have the same dimensions.</li>
</ul>
</dd>
<dt>ensures </dt>
<dd><ul class="first last">
<li><p class="first">This routine is similar to sobel_edge_detector(), except instead of finding 
an edge it finds a dark line.  For example, the border between a black piece 
of paper and a white table is an edge, but a curve drawn with a pencil on a 
piece of paper makes a line.  Therefore, the output of this routine is a 
vector field encoded in the horz and vert images, which are returned in a 
tuple where the first element is horz and the second is vert.</p>
<p>The vector obtains a large magnitude when centered on a dark line in an image 
and the direction of the vector is perpendicular to the line.  To be very 
precise, each vector points in the direction of greatest change in second 
derivative and the magnitude of the vector encodes the derivative magnitude 
in that direction.  Moreover, if the second derivative is negative then the 
output vector is zero.  This zeroing if negative gradients causes the output 
to be sensitive only to dark lines surrounded by darker pixels.</p>
</li>
<li><p class="first">We assume that xx, xy, and yy are the 3 second order gradients of the image 
in question.  You can obtain these gradients using the image_gradients class.</p>
</li>
<li><p class="first">The output images will have the same dimensions as the input images.</p>
</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="dlib.find_line_endpoints">
<code class="descclassname">dlib.</code><code class="descname">find_line_endpoints</code><span class="sig-paren">(</span><em>img: numpy.ndarray[(rows,cols),uint8]</em><span class="sig-paren">)</span> &rarr; dlib.points<a class="headerlink" href="#dlib.find_line_endpoints" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>requires </dt>
<dd><ul class="first last simple">
<li>all pixels in img are set to either 255 or 0. 
(i.e. it must be a binary image)</li>
</ul>
</dd>
<dt>ensures </dt>
<dd><ul class="first last simple">
<li>This routine finds endpoints of lines in a thinned binary image.  For 
example, if the image was produced by skeleton() or something like a Canny 
edge detector then you can use find_line_endpoints() to find the pixels 
sitting on the ends of lines.</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="dlib.find_max_global">
<code class="descclassname">dlib.</code><code class="descname">find_max_global</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.find_max_global" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>find_max_global(f: object, bound1: list, bound2: list, is_integer_variable: list, num_function_calls: int, solver_epsilon: float=0L) -&gt; tuple</li>
</ol>
<dl class="docutils">
<dt>requires </dt>
<dd><ul class="first last simple">
<li>len(bound1) == len(bound2) == len(is_integer_variable)</li>
<li>for all valid i: bound1[i] != bound2[i]</li>
<li>solver_epsilon &gt;= 0</li>
<li>f() is a real valued multi-variate function.  It must take scalar real 
numbers as its arguments and the number of arguments must be len(bound1).</li>
</ul>
</dd>
<dt>ensures </dt>
<dd><ul class="first last">
<li><p class="first">This function performs global optimization on the given f() function. 
The goal is to maximize the following objective function:</p>
<blockquote>
<div><p>f(x)</p>
</div></blockquote>
<dl class="docutils">
<dt>subject to the constraints: </dt>
<dd><p class="first last">min(bound1[i],bound2[i]) &lt;= x[i] &lt;= max(bound1[i],bound2[i]) 
if (is_integer_variable[i]) then x[i] is an integer value (but still 
represented with float type).</p>
</dd>
</dl>
</li>
<li><p class="first">find_max_global() runs until it has called f() num_function_calls times. 
Then it returns the best x it has found along with the corresponding output 
of f().  That is, it returns (best_x_seen,f(best_x_seen)).  Here best_x_seen 
is a list containing the best arguments to f() this function has found.</p>
</li>
<li><p class="first">find_max_global() uses a global optimization method based on a combination of 
non-parametric global function modeling and quadratic trust region modeling 
to efficiently find a global maximizer.  It usually does a good job with a 
relatively small number of calls to f().  For more information on how it 
works read the documentation for dlib&#8217;s global_function_search object. 
However, one notable element is the solver epsilon, which you can adjust.</p>
<p>The search procedure will only attempt to find a global maximizer to at most 
solver_epsilon accuracy.  Once a local maximizer is found to that accuracy 
the search will focus entirely on finding other maxima elsewhere rather than 
on further improving the current local optima found so far.  That is, once a 
local maxima is identified to about solver_epsilon accuracy, the algorithm 
will spend all its time exploring the function to find other local maxima to 
investigate.  An epsilon of 0 means it will keep solving until it reaches 
full floating point precision.  Larger values will cause it to switch to pure 
global exploration sooner and therefore might be more effective if your 
objective function has many local maxima and you don&#8217;t care about a super 
high precision solution.</p>
</li>
<li><dl class="first docutils">
<dt>Any variables that satisfy the following conditions are optimized on a log-scale: </dt>
<dd><ul class="first last simple">
<li>The lower bound on the variable is &gt; 0</li>
<li>The ratio of the upper bound to lower bound is &gt; 1000</li>
<li>The variable is not an integer variable</li>
</ul>
</dd>
</dl>
<p>We do this because it&#8217;s common to optimize machine learning models that have 
parameters with bounds in a range such as [1e-5 to 1e10] (e.g. the SVM C 
parameter) and it&#8217;s much more appropriate to optimize these kinds of 
variables on a log scale.  So we transform them by applying log() to 
them and then undo the transform via exp() before invoking the function 
being optimized.  Therefore, this transformation is invisible to the user 
supplied functions.  In most cases, it improves the efficiency of the 
optimizer.</p>
</li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li>find_max_global(f: object, bound1: list, bound2: list, num_function_calls: int, solver_epsilon: float=0L) -&gt; tuple</li>
</ol>
<p>This function simply calls the other version of find_max_global() with is_integer_variable set to False for all variables.</p>
</dd></dl>

<dl class="function">
<dt id="dlib.find_min_global">
<code class="descclassname">dlib.</code><code class="descname">find_min_global</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.find_min_global" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>find_min_global(f: object, bound1: list, bound2: list, is_integer_variable: list, num_function_calls: int, solver_epsilon: float=0L) -&gt; tuple</li>
</ol>
<p>This function is just like find_max_global(), except it performs minimization rather than maximization.</p>
<ol class="arabic simple" start="2">
<li>find_min_global(f: object, bound1: list, bound2: list, num_function_calls: int, solver_epsilon: float=0L) -&gt; tuple</li>
</ol>
<p>This function simply calls the other version of find_min_global() with is_integer_variable set to False for all variables.</p>
</dd></dl>

<dl class="function">
<dt id="dlib.find_optimal_rect_filter">
<code class="descclassname">dlib.</code><code class="descname">find_optimal_rect_filter</code><span class="sig-paren">(</span><em>rects: std::vector&lt;dlib::rectangle</em>, <em>std::allocator&lt;dlib::rectangle&gt; &gt;</em>, <em>smoothness: float=1L</em><span class="sig-paren">)</span> &rarr; dlib.rect_filter<a class="headerlink" href="#dlib.find_optimal_rect_filter" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>requires </dt>
<dd><ul class="first last simple">
<li>rects.size() &gt; 4</li>
<li>smoothness &gt;= 0</li>
</ul>
</dd>
<dt>ensures </dt>
<dd><ul class="first last">
<li><p class="first">This function finds the &#8220;optimal&#8221; settings of a rect_filter based on recorded 
measurement data stored in rects.  Here we assume that rects is a complete 
track history of some object&#8217;s measured positions.  Essentially, what we do 
is find the rect_filter that minimizes the following objective function:</p>
<blockquote>
<div><p>sum of abs(predicted_location[i] - measured_location[i]) + smoothness*abs(filtered_location[i]-filtered_location[i-1]) 
Where i is a time index.</p>
</div></blockquote>
<p>The sum runs over all the data in rects.  So what we do is find the 
filter settings that produce smooth filtered trajectories but also produce 
filtered outputs that are as close to the measured positions as possible. 
The larger the value of smoothness the less jittery the filter outputs will 
be, but they might become biased or laggy if smoothness is set really high.</p>
</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="dlib.find_peaks">
<code class="descclassname">dlib.</code><code class="descname">find_peaks</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.find_peaks" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>find_peaks(img: numpy.ndarray[(rows,cols),float32], non_max_suppression_radius: float, thresh: float) -&gt; dlib.points</li>
<li>find_peaks(img: numpy.ndarray[(rows,cols),float64], non_max_suppression_radius: float, thresh: float) -&gt; dlib.points</li>
<li>find_peaks(img: numpy.ndarray[(rows,cols),uint8], non_max_suppression_radius: float, thresh: int) -&gt; dlib.points</li>
<li>find_peaks(img: numpy.ndarray[(rows,cols),uint16], non_max_suppression_radius: float, thresh: int) -&gt; dlib.points</li>
<li>find_peaks(img: numpy.ndarray[(rows,cols),uint32], non_max_suppression_radius: float, thresh: int) -&gt; dlib.points</li>
<li>find_peaks(img: numpy.ndarray[(rows,cols),uint64], non_max_suppression_radius: float, thresh: int) -&gt; dlib.points</li>
<li>find_peaks(img: numpy.ndarray[(rows,cols),int8], non_max_suppression_radius: float, thresh: int) -&gt; dlib.points</li>
<li>find_peaks(img: numpy.ndarray[(rows,cols),int16], non_max_suppression_radius: float, thresh: int) -&gt; dlib.points</li>
<li>find_peaks(img: numpy.ndarray[(rows,cols),int32], non_max_suppression_radius: float, thresh: int) -&gt; dlib.points</li>
<li>find_peaks(img: numpy.ndarray[(rows,cols),int64], non_max_suppression_radius: float, thresh: int) -&gt; dlib.points</li>
</ol>
<dl class="docutils">
<dt>requires </dt>
<dd><ul class="first last simple">
<li>non_max_suppression_radius &gt;= 0</li>
</ul>
</dd>
<dt>ensures </dt>
<dd><ul class="first last">
<li><p class="first">Scans the given image and finds all pixels with values &gt;= thresh that are 
also local maximums within their 8-connected neighborhood of the image.  Such 
pixels are collected, sorted in decreasing order of their pixel values, and 
then non-maximum suppression is applied to this list of points using the 
given non_max_suppression_radius.  The final list of peaks is then returned.</p>
<dl class="docutils">
<dt>Therefore, the returned list, V, will have these properties: </dt>
<dd><ul class="first last simple">
<li>len(V) == the number of peaks found in the image.</li>
<li>When measured in image coordinates, no elements of V are within 
non_max_suppression_radius distance of each other.  That is, for all valid i!=j 
it is true that length(V[i]-V[j]) &gt; non_max_suppression_radius.</li>
<li>For each element of V, that element has the maximum pixel value of all 
pixels in the ball centered on that pixel with radius 
non_max_suppression_radius.</li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="11">
<li>find_peaks(img: numpy.ndarray[(rows,cols),float32], non_max_suppression_radius: float=0L) -&gt; dlib.points</li>
<li>find_peaks(img: numpy.ndarray[(rows,cols),float64], non_max_suppression_radius: float=0L) -&gt; dlib.points</li>
<li>find_peaks(img: numpy.ndarray[(rows,cols),uint8], non_max_suppression_radius: float=0L) -&gt; dlib.points</li>
<li>find_peaks(img: numpy.ndarray[(rows,cols),uint16], non_max_suppression_radius: float=0L) -&gt; dlib.points</li>
<li>find_peaks(img: numpy.ndarray[(rows,cols),uint32], non_max_suppression_radius: float=0L) -&gt; dlib.points</li>
<li>find_peaks(img: numpy.ndarray[(rows,cols),uint64], non_max_suppression_radius: float=0L) -&gt; dlib.points</li>
<li>find_peaks(img: numpy.ndarray[(rows,cols),int8], non_max_suppression_radius: float=0L) -&gt; dlib.points</li>
<li>find_peaks(img: numpy.ndarray[(rows,cols),int16], non_max_suppression_radius: float=0L) -&gt; dlib.points</li>
<li>find_peaks(img: numpy.ndarray[(rows,cols),int32], non_max_suppression_radius: float=0L) -&gt; dlib.points</li>
<li>find_peaks(img: numpy.ndarray[(rows,cols),int64], non_max_suppression_radius: float=0L) -&gt; dlib.points</li>
</ol>
<p>performs: return find_peaks(img, non_max_suppression_radius, partition_pixels(img))</p>
</dd></dl>

<dl class="function">
<dt id="dlib.find_projective_transform">
<code class="descclassname">dlib.</code><code class="descname">find_projective_transform</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.find_projective_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>find_projective_transform(from_points: dlib.dpoints, to_points: dlib.dpoints) -&gt; dlib.point_transform_projective</li>
</ol>
<dl class="docutils">
<dt>requires </dt>
<dd><ul class="first last simple">
<li>len(from_points) == len(to_points)</li>
<li>len(from_points) &gt;= 4</li>
</ul>
</dd>
<dt>ensures </dt>
<dd><ul class="first last">
<li><dl class="first docutils">
<dt>returns a point_transform_projective object, T, such that for all valid i: </dt>
<dd><p class="first last">length(T(from_points[i]) - to_points[i])</p>
</dd>
</dl>
<p>is minimized as often as possible.  That is, this function finds the projective 
transform that maps points in from_points to points in to_points.  If no 
projective transform exists which performs this mapping exactly then the one 
which minimizes the mean squared error is selected.</p>
</li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li>find_projective_transform(from_points: numpy.ndarray[(rows,cols),float32], to_points: numpy.ndarray[(rows,cols),float32]) -&gt; dlib.point_transform_projective</li>
</ol>
<dl class="docutils">
<dt>requires </dt>
<dd><ul class="first last simple">
<li>from_points and to_points have two columns and the same number of rows. 
Moreover, they have at least 4 rows.</li>
</ul>
</dd>
<dt>ensures </dt>
<dd><ul class="first last">
<li><dl class="first docutils">
<dt>returns a point_transform_projective object, T, such that for all valid i: </dt>
<dd><p class="first last">length(T(dpoint(from_points[i])) - dpoint(to_points[i]))</p>
</dd>
</dl>
<p>is minimized as often as possible.  That is, this function finds the projective 
transform that maps points in from_points to points in to_points.  If no 
projective transform exists which performs this mapping exactly then the one 
which minimizes the mean squared error is selected.</p>
</li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="3">
<li>find_projective_transform(from_points: numpy.ndarray[(rows,cols),float64], to_points: numpy.ndarray[(rows,cols),float64]) -&gt; dlib.point_transform_projective</li>
</ol>
<dl class="docutils">
<dt>requires </dt>
<dd><ul class="first last simple">
<li>from_points and to_points have two columns and the same number of rows. 
Moreover, they have at least 4 rows.</li>
</ul>
</dd>
<dt>ensures </dt>
<dd><ul class="first last">
<li><dl class="first docutils">
<dt>returns a point_transform_projective object, T, such that for all valid i: </dt>
<dd><p class="first last">length(T(dpoint(from_points[i])) - dpoint(to_points[i]))</p>
</dd>
</dl>
<p>is minimized as often as possible.  That is, this function finds the projective 
transform that maps points in from_points to points in to_points.  If no 
projective transform exists which performs this mapping exactly then the one 
which minimizes the mean squared error is selected.</p>
</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="dlib.full_object_detection">
<em class="property">class </em><code class="descclassname">dlib.</code><code class="descname">full_object_detection</code><a class="headerlink" href="#dlib.full_object_detection" title="Permalink to this definition">¶</a></dt>
<dd><p>This object represents the location of an object in an image along with the     positions of each of its constituent parts.</p>
<dl class="method">
<dt id="dlib.full_object_detection.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: dlib.full_object_detection</em>, <em>arg0: dlib.rectangle</em>, <em>arg1: list</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.full_object_detection.__init__" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>requires </dt>
<dd><ul class="first last simple">
<li>rect: dlib rectangle</li>
<li>parts: list of dlib points</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="dlib.full_object_detection.num_parts">
<code class="descname">num_parts</code><a class="headerlink" href="#dlib.full_object_detection.num_parts" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of parts of the object.</p>
</dd></dl>

<dl class="method">
<dt id="dlib.full_object_detection.part">
<code class="descname">part</code><span class="sig-paren">(</span><em>self: dlib.full_object_detection</em>, <em>idx: int</em><span class="sig-paren">)</span> &rarr; dlib.point<a class="headerlink" href="#dlib.full_object_detection.part" title="Permalink to this definition">¶</a></dt>
<dd><p>A single part of the object as a dlib point.</p>
</dd></dl>

<dl class="method">
<dt id="dlib.full_object_detection.parts">
<code class="descname">parts</code><span class="sig-paren">(</span><em>self: dlib.full_object_detection</em><span class="sig-paren">)</span> &rarr; dlib.points<a class="headerlink" href="#dlib.full_object_detection.parts" title="Permalink to this definition">¶</a></dt>
<dd><p>A vector of dlib points representing all of the parts.</p>
</dd></dl>

<dl class="attribute">
<dt id="dlib.full_object_detection.rect">
<code class="descname">rect</code><a class="headerlink" href="#dlib.full_object_detection.rect" title="Permalink to this definition">¶</a></dt>
<dd><p>Bounding box from the underlying detector. Parts can be outside box if appropriate.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="dlib.full_object_detections">
<em class="property">class </em><code class="descclassname">dlib.</code><code class="descname">full_object_detections</code><a class="headerlink" href="#dlib.full_object_detections" title="Permalink to this definition">¶</a></dt>
<dd><p>An array of full_object_detection objects.</p>
<dl class="method">
<dt id="dlib.full_object_detections.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.full_object_detections.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: dlib.full_object_detections) -&gt; None</li>
<li>__init__(self: dlib.full_object_detections, arg0: dlib.full_object_detections) -&gt; None</li>
</ol>
<p>Copy constructor</p>
<ol class="arabic simple" start="3">
<li>__init__(self: dlib.full_object_detections, arg0: iterable) -&gt; None</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="dlib.full_object_detections.append">
<code class="descname">append</code><span class="sig-paren">(</span><em>self: dlib.full_object_detections</em>, <em>x: dlib.full_object_detection</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.full_object_detections.append" title="Permalink to this definition">¶</a></dt>
<dd><p>Add an item to the end of the list</p>
</dd></dl>

<dl class="method">
<dt id="dlib.full_object_detections.clear">
<code class="descname">clear</code><span class="sig-paren">(</span><em>self: dlib.full_object_detections</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.full_object_detections.clear" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dlib.full_object_detections.count">
<code class="descname">count</code><span class="sig-paren">(</span><em>self: dlib.full_object_detections</em>, <em>x: dlib.full_object_detection</em><span class="sig-paren">)</span> &rarr; int<a class="headerlink" href="#dlib.full_object_detections.count" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of times <code class="docutils literal"><span class="pre">x</span></code> appears in the list</p>
</dd></dl>

<dl class="method">
<dt id="dlib.full_object_detections.extend">
<code class="descname">extend</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.full_object_detections.extend" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>extend(self: dlib.full_object_detections, L: dlib.full_object_detections) -&gt; None</li>
</ol>
<p>Extend the list by appending all the items in the given list</p>
<ol class="arabic simple" start="2">
<li>extend(self: dlib.full_object_detections, arg0: list) -&gt; None</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="dlib.full_object_detections.insert">
<code class="descname">insert</code><span class="sig-paren">(</span><em>self: dlib.full_object_detections</em>, <em>i: int</em>, <em>x: dlib.full_object_detection</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.full_object_detections.insert" title="Permalink to this definition">¶</a></dt>
<dd><p>Insert an item at a given position.</p>
</dd></dl>

<dl class="method">
<dt id="dlib.full_object_detections.pop">
<code class="descname">pop</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.full_object_detections.pop" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>pop(self: dlib.full_object_detections) -&gt; dlib.full_object_detection</li>
</ol>
<p>Remove and return the last item</p>
<ol class="arabic simple" start="2">
<li>pop(self: dlib.full_object_detections, i: int) -&gt; dlib.full_object_detection</li>
</ol>
<p>Remove and return the item at index <code class="docutils literal"><span class="pre">i</span></code></p>
</dd></dl>

<dl class="method">
<dt id="dlib.full_object_detections.remove">
<code class="descname">remove</code><span class="sig-paren">(</span><em>self: dlib.full_object_detections</em>, <em>x: dlib.full_object_detection</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.full_object_detections.remove" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove the first item from the list whose value is x. It is an error if there is no such item.</p>
</dd></dl>

<dl class="method">
<dt id="dlib.full_object_detections.resize">
<code class="descname">resize</code><span class="sig-paren">(</span><em>self: dlib.full_object_detections</em>, <em>arg0: int</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.full_object_detections.resize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="dlib.function_evaluation">
<em class="property">class </em><code class="descclassname">dlib.</code><code class="descname">function_evaluation</code><a class="headerlink" href="#dlib.function_evaluation" title="Permalink to this definition">¶</a></dt>
<dd><p>This object records the output of a real valued function in response to
some input.</p>
<p>In particular, if you have a function F(x) then the function_evaluation is
simply a struct that records x and the scalar value F(x).</p>
<dl class="method">
<dt id="dlib.function_evaluation.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.function_evaluation.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: dlib.function_evaluation, x: dlib.vector, y: float) -&gt; None</li>
<li>__init__(self: dlib.function_evaluation, x: list, y: float) -&gt; None</li>
</ol>
</dd></dl>

<dl class="attribute">
<dt id="dlib.function_evaluation.x">
<code class="descname">x</code><a class="headerlink" href="#dlib.function_evaluation.x" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.function_evaluation.y">
<code class="descname">y</code><a class="headerlink" href="#dlib.function_evaluation.y" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="dlib.function_evaluation_request">
<em class="property">class </em><code class="descclassname">dlib.</code><code class="descname">function_evaluation_request</code><a class="headerlink" href="#dlib.function_evaluation_request" title="Permalink to this definition">¶</a></dt>
<dd><p>See: <a class="reference external" href="http://dlib.net/dlib/global_optimization/global_function_search_abstract.h.html">http://dlib.net/dlib/global_optimization/global_function_search_abstract.h.html</a></p>
<dl class="attribute">
<dt id="dlib.function_evaluation_request.__init__">
<code class="descname">__init__</code><a class="headerlink" href="#dlib.function_evaluation_request.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__init__(...) initializes x; see help(type(x)) for signature</p>
</dd></dl>

<dl class="attribute">
<dt id="dlib.function_evaluation_request.function_idx">
<code class="descname">function_idx</code><a class="headerlink" href="#dlib.function_evaluation_request.function_idx" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.function_evaluation_request.has_been_evaluated">
<code class="descname">has_been_evaluated</code><a class="headerlink" href="#dlib.function_evaluation_request.has_been_evaluated" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dlib.function_evaluation_request.set">
<code class="descname">set</code><span class="sig-paren">(</span><em>self: dlib.function_evaluation_request</em>, <em>arg0: float</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.function_evaluation_request.set" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.function_evaluation_request.x">
<code class="descname">x</code><a class="headerlink" href="#dlib.function_evaluation_request.x" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="dlib.function_spec">
<em class="property">class </em><code class="descclassname">dlib.</code><code class="descname">function_spec</code><a class="headerlink" href="#dlib.function_spec" title="Permalink to this definition">¶</a></dt>
<dd><p>See: <a class="reference external" href="http://dlib.net/dlib/global_optimization/global_function_search_abstract.h.html">http://dlib.net/dlib/global_optimization/global_function_search_abstract.h.html</a></p>
<dl class="method">
<dt id="dlib.function_spec.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.function_spec.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: dlib.function_spec, bound1: dlib.vector, bound2: dlib.vector) -&gt; None</li>
<li>__init__(self: dlib.function_spec, bound1: dlib.vector, bound2: dlib.vector, is_integer: List[bool]) -&gt; None</li>
<li>__init__(self: dlib.function_spec, bound1: list, bound2: list) -&gt; None</li>
<li>__init__(self: dlib.function_spec, bound1: list, bound2: list, is_integer: list) -&gt; None</li>
</ol>
</dd></dl>

<dl class="attribute">
<dt id="dlib.function_spec.is_integer_variable">
<code class="descname">is_integer_variable</code><a class="headerlink" href="#dlib.function_spec.is_integer_variable" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.function_spec.lower">
<code class="descname">lower</code><a class="headerlink" href="#dlib.function_spec.lower" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.function_spec.upper">
<code class="descname">upper</code><a class="headerlink" href="#dlib.function_spec.upper" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="dlib.gaussian_blur">
<code class="descclassname">dlib.</code><code class="descname">gaussian_blur</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.gaussian_blur" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>gaussian_blur(img: numpy.ndarray[(rows,cols,3),uint8], sigma: float, max_size: int=1000L) -&gt; tuple</li>
<li>gaussian_blur(img: numpy.ndarray[(rows,cols),uint8], sigma: float, max_size: int=1000L) -&gt; tuple</li>
<li>gaussian_blur(img: numpy.ndarray[(rows,cols),uint16], sigma: float, max_size: int=1000L) -&gt; tuple</li>
<li>gaussian_blur(img: numpy.ndarray[(rows,cols),uint32], sigma: float, max_size: int=1000L) -&gt; tuple</li>
<li>gaussian_blur(img: numpy.ndarray[(rows,cols),float32], sigma: float, max_size: int=1000L) -&gt; tuple</li>
<li>gaussian_blur(img: numpy.ndarray[(rows,cols),float64], sigma: float, max_size: int=1000L) -&gt; tuple</li>
</ol>
<dl class="docutils">
<dt>requires </dt>
<dd><ul class="first last simple">
<li>sigma &gt; 0</li>
<li>max_size &gt; 0</li>
<li>max_size is an odd number</li>
</ul>
</dd>
<dt>ensures </dt>
<dd><ul class="first last">
<li><p class="first">Filters img with a Gaussian filter of sigma width.  The actual spatial filter will 
be applied to pixel blocks that are at most max_size wide and max_size tall (note that 
this function will automatically select a smaller block size as appropriate).  The  
results are returned.  We also return a rectangle which indicates what pixels 
in the returned image are considered non-border pixels and therefore contain 
output from the filter.  E.g.</p>
<blockquote>
<div><ul class="simple">
<li>filtered_img,rect = gaussian_blur(img)</li>
</ul>
</div></blockquote>
<p>would give you the filtered image and the rectangle in question.</p>
</li>
<li><p class="first">The filter is applied to each color channel independently.</p>
</li>
<li><p class="first">Pixels close enough to the edge of img to not have the filter still fit  
inside the image are set to zero.</p>
</li>
<li><p class="first">The returned image has the same dimensions as the input image.</p>
</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="dlib.get_face_chip">
<code class="descclassname">dlib.</code><code class="descname">get_face_chip</code><span class="sig-paren">(</span><em>img: numpy.ndarray[(rows,cols,3),uint8], face: dlib.full_object_detection, size: int=150L, padding: float=0.25</em><span class="sig-paren">)</span> &rarr; numpy.ndarray[(rows,cols,3),uint8]<a class="headerlink" href="#dlib.get_face_chip" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes an image and a full_object_detection that references a face in that image and returns the face as a Numpy array representing the image.  The face will be rotated upright and scaled to 150x150 pixels or with the optional specified size and padding.</p>
</dd></dl>

<dl class="function">
<dt id="dlib.get_face_chips">
<code class="descclassname">dlib.</code><code class="descname">get_face_chips</code><span class="sig-paren">(</span><em>img: numpy.ndarray[(rows,cols,3),uint8], faces: dlib.full_object_detections, size: int=150L, padding: float=0.25</em><span class="sig-paren">)</span> &rarr; list<a class="headerlink" href="#dlib.get_face_chips" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes an image and a full_object_detections object that reference faces in that image and returns the faces as a list of Numpy arrays representing the image.  The faces will be rotated upright and scaled to 150x150 pixels or with the optional specified size and padding.</p>
</dd></dl>

<dl class="function">
<dt id="dlib.get_frontal_face_detector">
<code class="descclassname">dlib.</code><code class="descname">get_frontal_face_detector</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &rarr; dlib::object_detector&lt;dlib::scan_fhog_pyramid&lt;dlib::pyramid_down&lt;6u&gt;, dlib::default_fhog_feature_extractor&gt; &gt;<a class="headerlink" href="#dlib.get_frontal_face_detector" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the default face detector</p>
</dd></dl>

<dl class="function">
<dt id="dlib.get_histogram">
<code class="descclassname">dlib.</code><code class="descname">get_histogram</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.get_histogram" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>get_histogram(img: numpy.ndarray[(rows,cols),uint8], hist_size: int) -&gt; numpy.ndarray[uint64]</li>
<li>get_histogram(img: numpy.ndarray[(rows,cols),uint16], hist_size: int) -&gt; numpy.ndarray[uint64]</li>
<li>get_histogram(img: numpy.ndarray[(rows,cols),uint32], hist_size: int) -&gt; numpy.ndarray[uint64]</li>
<li>get_histogram(img: numpy.ndarray[(rows,cols),uint64], hist_size: int) -&gt; numpy.ndarray[uint64]</li>
</ol>
<dl class="docutils">
<dt>ensures </dt>
<dd><ul class="first last">
<li><p class="first">Returns a numpy array, HIST, that contains a histogram of the pixels in img. 
In particular, we will have:</p>
<blockquote>
<div><ul>
<li><p class="first">len(HIST) == hist_size</p>
</li>
<li><dl class="first docutils">
<dt>for all valid i:  </dt>
<dd><ul class="first last simple">
<li>HIST[i] == the number of times a pixel with intensity i appears in img.</li>
</ul>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="dlib.get_rect">
<code class="descclassname">dlib.</code><code class="descname">get_rect</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.get_rect" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>get_rect(img: array) -&gt; dlib.rectangle</li>
</ol>
<p>returns a rectangle(0,0,img.shape(1)-1,img.shape(0)-1).  Therefore, it is the rectangle that bounds the image.</p>
<ol class="arabic simple" start="2">
<li>get_rect(ht: dlib.hough_transform) -&gt; dlib.rectangle</li>
</ol>
<p>returns a rectangle(0,0,ht.size()-1,ht.size()-1).  Therefore, it is the rectangle that bounds the Hough transform image.</p>
</dd></dl>

<dl class="class">
<dt id="dlib.global_function_search">
<em class="property">class </em><code class="descclassname">dlib.</code><code class="descname">global_function_search</code><a class="headerlink" href="#dlib.global_function_search" title="Permalink to this definition">¶</a></dt>
<dd><p>See: <a class="reference external" href="http://dlib.net/dlib/global_optimization/global_function_search_abstract.h.html">http://dlib.net/dlib/global_optimization/global_function_search_abstract.h.html</a></p>
<dl class="method">
<dt id="dlib.global_function_search.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.global_function_search.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: dlib.global_function_search, function: dlib.function_spec) -&gt; None</li>
<li>__init__(self: dlib.global_function_search, functions: list) -&gt; None</li>
<li>__init__(self: dlib.global_function_search, functions: list, initial_function_evals: list, relative_noise_magnitude: float) -&gt; None</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="dlib.global_function_search.get_best_function_eval">
<code class="descname">get_best_function_eval</code><span class="sig-paren">(</span><em>self: dlib.global_function_search</em><span class="sig-paren">)</span> &rarr; tuple<a class="headerlink" href="#dlib.global_function_search.get_best_function_eval" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dlib.global_function_search.get_function_evaluations">
<code class="descname">get_function_evaluations</code><span class="sig-paren">(</span><em>self: dlib.global_function_search</em><span class="sig-paren">)</span> &rarr; tuple<a class="headerlink" href="#dlib.global_function_search.get_function_evaluations" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dlib.global_function_search.get_monte_carlo_upper_bound_sample_num">
<code class="descname">get_monte_carlo_upper_bound_sample_num</code><span class="sig-paren">(</span><em>self: dlib.global_function_search</em><span class="sig-paren">)</span> &rarr; int<a class="headerlink" href="#dlib.global_function_search.get_monte_carlo_upper_bound_sample_num" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dlib.global_function_search.get_next_x">
<code class="descname">get_next_x</code><span class="sig-paren">(</span><em>self: dlib.global_function_search</em><span class="sig-paren">)</span> &rarr; dlib.function_evaluation_request<a class="headerlink" href="#dlib.global_function_search.get_next_x" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dlib.global_function_search.get_pure_random_search_probability">
<code class="descname">get_pure_random_search_probability</code><span class="sig-paren">(</span><em>self: dlib.global_function_search</em><span class="sig-paren">)</span> &rarr; float<a class="headerlink" href="#dlib.global_function_search.get_pure_random_search_probability" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dlib.global_function_search.get_relative_noise_magnitude">
<code class="descname">get_relative_noise_magnitude</code><span class="sig-paren">(</span><em>self: dlib.global_function_search</em><span class="sig-paren">)</span> &rarr; float<a class="headerlink" href="#dlib.global_function_search.get_relative_noise_magnitude" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dlib.global_function_search.get_solver_epsilon">
<code class="descname">get_solver_epsilon</code><span class="sig-paren">(</span><em>self: dlib.global_function_search</em><span class="sig-paren">)</span> &rarr; float<a class="headerlink" href="#dlib.global_function_search.get_solver_epsilon" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dlib.global_function_search.num_functions">
<code class="descname">num_functions</code><span class="sig-paren">(</span><em>self: dlib.global_function_search</em><span class="sig-paren">)</span> &rarr; int<a class="headerlink" href="#dlib.global_function_search.num_functions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dlib.global_function_search.set_monte_carlo_upper_bound_sample_num">
<code class="descname">set_monte_carlo_upper_bound_sample_num</code><span class="sig-paren">(</span><em>self: dlib.global_function_search</em>, <em>num: int</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.global_function_search.set_monte_carlo_upper_bound_sample_num" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dlib.global_function_search.set_pure_random_search_probability">
<code class="descname">set_pure_random_search_probability</code><span class="sig-paren">(</span><em>self: dlib.global_function_search</em>, <em>prob: float</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.global_function_search.set_pure_random_search_probability" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dlib.global_function_search.set_relative_noise_magnitude">
<code class="descname">set_relative_noise_magnitude</code><span class="sig-paren">(</span><em>self: dlib.global_function_search</em>, <em>value: float</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.global_function_search.set_relative_noise_magnitude" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dlib.global_function_search.set_seed">
<code class="descname">set_seed</code><span class="sig-paren">(</span><em>self: dlib.global_function_search</em>, <em>seed: int</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.global_function_search.set_seed" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dlib.global_function_search.set_solver_epsilon">
<code class="descname">set_solver_epsilon</code><span class="sig-paren">(</span><em>self: dlib.global_function_search</em>, <em>eps: float</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.global_function_search.set_solver_epsilon" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="dlib.grow_rect">
<code class="descclassname">dlib.</code><code class="descname">grow_rect</code><span class="sig-paren">(</span><em>rect: dlib.rectangle</em>, <em>num: int</em><span class="sig-paren">)</span> &rarr; dlib.rectangle<a class="headerlink" href="#dlib.grow_rect" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>return shrink_rect(rect, -num) 
(i.e. grows the given rectangle by expanding its border by num)</li>
</ul>
</dd></dl>

<dl class="function">
<dt id="dlib.hit_enter_to_continue">
<code class="descclassname">dlib.</code><code class="descname">hit_enter_to_continue</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.hit_enter_to_continue" title="Permalink to this definition">¶</a></dt>
<dd><p>Asks the user to hit enter to continue and pauses until they do so.</p>
</dd></dl>

<dl class="class">
<dt id="dlib.hough_transform">
<em class="property">class </em><code class="descclassname">dlib.</code><code class="descname">hough_transform</code><a class="headerlink" href="#dlib.hough_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>This object is a tool for computing the line finding version of the Hough transform 
given some kind of edge detection image as input.  It also allows the edge pixels 
to be weighted such that higher weighted edge pixels contribute correspondingly 
more to the output of the Hough transform, allowing stronger edges to create 
correspondingly stronger line detections in the final Hough transform.</p>
<dl class="method">
<dt id="dlib.hough_transform.__call__">
<code class="descname">__call__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.hough_transform.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__call__(self: dlib.hough_transform, img: numpy.ndarray[(rows,cols),uint8], box: dlib.rectangle) -&gt; numpy.ndarray[(rows,cols),float32]</li>
<li>__call__(self: dlib.hough_transform, img: numpy.ndarray[(rows,cols),uint16], box: dlib.rectangle) -&gt; numpy.ndarray[(rows,cols),float32]</li>
<li>__call__(self: dlib.hough_transform, img: numpy.ndarray[(rows,cols),uint32], box: dlib.rectangle) -&gt; numpy.ndarray[(rows,cols),float32]</li>
<li>__call__(self: dlib.hough_transform, img: numpy.ndarray[(rows,cols),uint64], box: dlib.rectangle) -&gt; numpy.ndarray[(rows,cols),float32]</li>
<li>__call__(self: dlib.hough_transform, img: numpy.ndarray[(rows,cols),int8], box: dlib.rectangle) -&gt; numpy.ndarray[(rows,cols),float32]</li>
<li>__call__(self: dlib.hough_transform, img: numpy.ndarray[(rows,cols),int16], box: dlib.rectangle) -&gt; numpy.ndarray[(rows,cols),float32]</li>
<li>__call__(self: dlib.hough_transform, img: numpy.ndarray[(rows,cols),int32], box: dlib.rectangle) -&gt; numpy.ndarray[(rows,cols),float32]</li>
<li>__call__(self: dlib.hough_transform, img: numpy.ndarray[(rows,cols),int64], box: dlib.rectangle) -&gt; numpy.ndarray[(rows,cols),float32]</li>
<li>__call__(self: dlib.hough_transform, img: numpy.ndarray[(rows,cols),float32], box: dlib.rectangle) -&gt; numpy.ndarray[(rows,cols),float32]</li>
<li>__call__(self: dlib.hough_transform, img: numpy.ndarray[(rows,cols),float64], box: dlib.rectangle) -&gt; numpy.ndarray[(rows,cols),float32]</li>
</ol>
<dl class="docutils">
<dt>requires </dt>
<dd><ul class="first last simple">
<li>box.width() == size</li>
<li>box.height() == size</li>
</ul>
</dd>
<dt>ensures </dt>
<dd><ul class="first last simple">
<li>Computes the Hough transform of the part of img contained within box. 
In particular, we do a grayscale version of the Hough transform where any 
non-zero pixel in img is treated as a potential component of a line and 
accumulated into the returned Hough accumulator image.  However, rather than 
adding 1 to each relevant accumulator bin we add the value of the pixel 
in img to each Hough accumulator bin.  This means that, if all the 
pixels in img are 0 or 1 then this routine performs a normal Hough 
transform.  However, if some pixels have larger values then they will be 
weighted correspondingly more in the resulting Hough transform.</li>
<li>The returned hough transform image will be size rows by size columns.</li>
<li>The returned image is the Hough transform of the part of img contained in 
box.  Each point in the Hough image corresponds to a line in the input box. 
In particular, the line for hough_image[y][x] is given by get_line(point(x,y)).  
Also, when viewing the Hough image, the x-axis gives the angle of the line 
and the y-axis the distance of the line from the center of the box.  The 
conversion between Hough coordinates and angle and pixel distance can be 
obtained by calling get_line_properties().</li>
</ul>
</dd>
</dl>
<ol class="arabic" start="11">
<li><p class="first">__call__(self: dlib.hough_transform, img: numpy.ndarray[(rows,cols),uint8]) -&gt; numpy.ndarray[(rows,cols),float32]</p>
</li>
<li><p class="first">__call__(self: dlib.hough_transform, img: numpy.ndarray[(rows,cols),uint16]) -&gt; numpy.ndarray[(rows,cols),float32]</p>
</li>
<li><p class="first">__call__(self: dlib.hough_transform, img: numpy.ndarray[(rows,cols),uint32]) -&gt; numpy.ndarray[(rows,cols),float32]</p>
</li>
<li><p class="first">__call__(self: dlib.hough_transform, img: numpy.ndarray[(rows,cols),uint64]) -&gt; numpy.ndarray[(rows,cols),float32]</p>
</li>
<li><p class="first">__call__(self: dlib.hough_transform, img: numpy.ndarray[(rows,cols),int8]) -&gt; numpy.ndarray[(rows,cols),float32]</p>
</li>
<li><p class="first">__call__(self: dlib.hough_transform, img: numpy.ndarray[(rows,cols),int16]) -&gt; numpy.ndarray[(rows,cols),float32]</p>
</li>
<li><p class="first">__call__(self: dlib.hough_transform, img: numpy.ndarray[(rows,cols),int32]) -&gt; numpy.ndarray[(rows,cols),float32]</p>
</li>
<li><p class="first">__call__(self: dlib.hough_transform, img: numpy.ndarray[(rows,cols),int64]) -&gt; numpy.ndarray[(rows,cols),float32]</p>
</li>
<li><p class="first">__call__(self: dlib.hough_transform, img: numpy.ndarray[(rows,cols),float32]) -&gt; numpy.ndarray[(rows,cols),float32]</p>
</li>
<li><p class="first">__call__(self: dlib.hough_transform, img: numpy.ndarray[(rows,cols),float64]) -&gt; numpy.ndarray[(rows,cols),float32]</p>
<p>simply performs: return self(img, get_rect(img)).  That is, just runs the hough transform on the whole input image.</p>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="dlib.hough_transform.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: dlib.hough_transform</em>, <em>size_: int</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.hough_transform.__init__" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>requires </dt>
<dd><ul class="first last simple">
<li><a href="#id3"><span class="problematic" id="id4">size_</span></a> &gt; 0</li>
</ul>
</dd>
<dt>ensures </dt>
<dd><ul class="first last simple">
<li>This object will compute Hough transforms that are <a href="#id5"><span class="problematic" id="id6">size_</span></a> by <a href="#id7"><span class="problematic" id="id8">size_</span></a> pixels.   
This is in terms of both the Hough accumulator array size as well as the 
input image size.</li>
<li>size() == <a href="#id9"><span class="problematic" id="id10">size_</span></a></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dlib.hough_transform.find_pixels_voting_for_lines">
<code class="descname">find_pixels_voting_for_lines</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.hough_transform.find_pixels_voting_for_lines" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>find_pixels_voting_for_lines(self: dlib.hough_transform, img: numpy.ndarray[(rows,cols),uint8], box: dlib.rectangle, hough_points: dlib.points, angle_window_size: int=1L, radius_window_size: int=1L) -&gt; list</li>
<li>find_pixels_voting_for_lines(self: dlib.hough_transform, img: numpy.ndarray[(rows,cols),uint16], box: dlib.rectangle, hough_points: dlib.points, angle_window_size: int=1L, radius_window_size: int=1L) -&gt; list</li>
<li>find_pixels_voting_for_lines(self: dlib.hough_transform, img: numpy.ndarray[(rows,cols),uint32], box: dlib.rectangle, hough_points: dlib.points, angle_window_size: int=1L, radius_window_size: int=1L) -&gt; list</li>
<li>find_pixels_voting_for_lines(self: dlib.hough_transform, img: numpy.ndarray[(rows,cols),uint64], box: dlib.rectangle, hough_points: dlib.points, angle_window_size: int=1L, radius_window_size: int=1L) -&gt; list</li>
<li>find_pixels_voting_for_lines(self: dlib.hough_transform, img: numpy.ndarray[(rows,cols),int8], box: dlib.rectangle, hough_points: dlib.points, angle_window_size: int=1L, radius_window_size: int=1L) -&gt; list</li>
<li>find_pixels_voting_for_lines(self: dlib.hough_transform, img: numpy.ndarray[(rows,cols),int16], box: dlib.rectangle, hough_points: dlib.points, angle_window_size: int=1L, radius_window_size: int=1L) -&gt; list</li>
<li>find_pixels_voting_for_lines(self: dlib.hough_transform, img: numpy.ndarray[(rows,cols),int32], box: dlib.rectangle, hough_points: dlib.points, angle_window_size: int=1L, radius_window_size: int=1L) -&gt; list</li>
<li>find_pixels_voting_for_lines(self: dlib.hough_transform, img: numpy.ndarray[(rows,cols),int64], box: dlib.rectangle, hough_points: dlib.points, angle_window_size: int=1L, radius_window_size: int=1L) -&gt; list</li>
<li>find_pixels_voting_for_lines(self: dlib.hough_transform, img: numpy.ndarray[(rows,cols),float32], box: dlib.rectangle, hough_points: dlib.points, angle_window_size: int=1L, radius_window_size: int=1L) -&gt; list</li>
<li>find_pixels_voting_for_lines(self: dlib.hough_transform, img: numpy.ndarray[(rows,cols),float64], box: dlib.rectangle, hough_points: dlib.points, angle_window_size: int=1L, radius_window_size: int=1L) -&gt; list</li>
</ol>
<dl class="docutils">
<dt>requires </dt>
<dd><ul class="first last">
<li><p class="first">box.width() == size</p>
</li>
<li><p class="first">box.height() == size</p>
</li>
<li><dl class="first docutils">
<dt>for all valid i: </dt>
<dd><ul class="first last simple">
<li>rectangle(0,0,size-1,size-1).contains(hough_points[i]) == true 
(i.e. hough_points must contain points in the output Hough transform 
space generated by this object.)</li>
</ul>
</dd>
</dl>
</li>
<li><p class="first">angle_window_size &gt;= 1</p>
</li>
<li><p class="first">radius_window_size &gt;= 1</p>
</li>
</ul>
</dd>
<dt>ensures </dt>
<dd><ul class="first last">
<li><p class="first">This function computes the Hough transform of the part of img contained 
within box.  It does the same computation as __call__() defined above, 
except instead of accumulating into an image we create an explicit list 
of all the points in img that contributed to each line (i.e each point in 
the Hough image). To do this we take a list of Hough points as input and 
only record hits on these specifically identified Hough points.  A 
typical use of find_pixels_voting_for_lines() is to first run the normal 
Hough transform using __call__(), then find the lines you are interested 
in, and then call find_pixels_voting_for_lines() to determine which 
pixels in the input image belong to those lines.</p>
</li>
<li><p class="first">This routine returns a vector, CONSTITUENT_POINTS, with the following 
properties:</p>
<blockquote>
<div><ul>
<li><p class="first">CONSTITUENT_POINTS.size == hough_points.size</p>
</li>
<li><dl class="first docutils">
<dt>for all valid i: </dt>
<dd><ul class="first last simple">
<li>Let HP[i] = centered_rect(hough_points[i], angle_window_size, radius_window_size)</li>
<li>Any point in img with a non-zero value that lies on a line 
corresponding to one of the Hough points in HP[i] is added to 
CONSTITUENT_POINTS[i].  Therefore, when this routine finishes, 
#CONSTITUENT_POINTS[i] will contain all the points in img that 
voted for the lines associated with the Hough accumulator bins in 
HP[i].</li>
<li>#CONSTITUENT_POINTS[i].size == the number of points in img that 
voted for any of the lines HP[i] in Hough space.  Note, however, 
that if angle_window_size or radius_window_size are made so large 
that HP[i] overlaps HP[j] for i!=j then the overlapping regions 
of Hough space are assigned to HP[i] or HP[j] arbitrarily. 
That is, we treat HP[i] and HP[j] as disjoint even if their boxes 
overlap.  In this case, the overlapping region is assigned to 
either HP[i] or HP[j] in an arbitrary manner.</li>
</ul>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
</li>
</ul>
</dd>
</dl>
<ol class="arabic" start="11">
<li><p class="first">find_pixels_voting_for_lines(self: dlib.hough_transform, img: numpy.ndarray[(rows,cols),uint8], hough_points: dlib.points, angle_window_size: int=1L, radius_window_size: int=1L) -&gt; list</p>
</li>
<li><p class="first">find_pixels_voting_for_lines(self: dlib.hough_transform, img: numpy.ndarray[(rows,cols),uint16], hough_points: dlib.points, angle_window_size: int=1L, radius_window_size: int=1L) -&gt; list</p>
</li>
<li><p class="first">find_pixels_voting_for_lines(self: dlib.hough_transform, img: numpy.ndarray[(rows,cols),uint32], hough_points: dlib.points, angle_window_size: int=1L, radius_window_size: int=1L) -&gt; list</p>
</li>
<li><p class="first">find_pixels_voting_for_lines(self: dlib.hough_transform, img: numpy.ndarray[(rows,cols),uint64], hough_points: dlib.points, angle_window_size: int=1L, radius_window_size: int=1L) -&gt; list</p>
</li>
<li><p class="first">find_pixels_voting_for_lines(self: dlib.hough_transform, img: numpy.ndarray[(rows,cols),int8], hough_points: dlib.points, angle_window_size: int=1L, radius_window_size: int=1L) -&gt; list</p>
</li>
<li><p class="first">find_pixels_voting_for_lines(self: dlib.hough_transform, img: numpy.ndarray[(rows,cols),int16], hough_points: dlib.points, angle_window_size: int=1L, radius_window_size: int=1L) -&gt; list</p>
</li>
<li><p class="first">find_pixels_voting_for_lines(self: dlib.hough_transform, img: numpy.ndarray[(rows,cols),int32], hough_points: dlib.points, angle_window_size: int=1L, radius_window_size: int=1L) -&gt; list</p>
</li>
<li><p class="first">find_pixels_voting_for_lines(self: dlib.hough_transform, img: numpy.ndarray[(rows,cols),int64], hough_points: dlib.points, angle_window_size: int=1L, radius_window_size: int=1L) -&gt; list</p>
</li>
<li><p class="first">find_pixels_voting_for_lines(self: dlib.hough_transform, img: numpy.ndarray[(rows,cols),float32], hough_points: dlib.points, angle_window_size: int=1L, radius_window_size: int=1L) -&gt; list</p>
</li>
<li><p class="first">find_pixels_voting_for_lines(self: dlib.hough_transform, img: numpy.ndarray[(rows,cols),float64], hough_points: dlib.points, angle_window_size: int=1L, radius_window_size: int=1L) -&gt; list</p>
<p>performs: return find_pixels_voting_for_lines(img, get_rect(img), hough_points, angle_window_size, radius_window_size);</p>
</li>
</ol>
<p>That is, just runs the routine on the whole input image.</p>
</dd></dl>

<dl class="method">
<dt id="dlib.hough_transform.find_strong_hough_points">
<code class="descname">find_strong_hough_points</code><span class="sig-paren">(</span><em>self: dlib.hough_transform, himg: numpy.ndarray[(rows,cols),float32], hough_count_thresh: float, angle_nms_thresh: float, radius_nms_thresh: float</em><span class="sig-paren">)</span> &rarr; dlib.points<a class="headerlink" href="#dlib.hough_transform.find_strong_hough_points" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>requires </dt>
<dd><ul class="first last simple">
<li>himg has size() rows and columns.</li>
<li>angle_nms_thresh &gt;= 0</li>
<li>radius_nms_thresh &gt;= 0</li>
</ul>
</dd>
<dt>ensures </dt>
<dd><ul class="first last simple">
<li>This routine finds strong lines in a Hough transform and performs 
non-maximum suppression on the detected lines.  Recall that each point in 
Hough space is associated with a line. Therefore, this routine finds all 
the pixels in himg (a Hough transform image) with values &gt;= 
hough_count_thresh and performs non-maximum suppression on the 
identified list of pixels.  It does this by discarding lines that are 
within angle_nms_thresh degrees of a stronger line or within 
radius_nms_thresh distance (in terms of radius as defined by 
get_line_properties()) to a stronger Hough point.</li>
<li>The identified lines are returned as a list of coordinates in himg.</li>
<li>The returned points are sorted so that points with larger Hough transform 
values come first.</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dlib.hough_transform.get_best_hough_point">
<code class="descname">get_best_hough_point</code><span class="sig-paren">(</span><em>self: dlib.hough_transform, p: dlib.point, himg: numpy.ndarray[(rows,cols),float32]</em><span class="sig-paren">)</span> &rarr; dlib.point<a class="headerlink" href="#dlib.hough_transform.get_best_hough_point" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>requires </dt>
<dd><ul class="first last simple">
<li>himg has size rows and columns.</li>
<li>rectangle(0,0,size-1,size-1).contains(p) == true</li>
</ul>
</dd>
<dt>ensures </dt>
<dd><ul class="first last simple">
<li>This function interprets himg as a Hough image and p as a point in the 
original image space.  Given this, it finds the maximum scoring line that 
passes though p.  That is, it checks all the Hough accumulator bins in 
himg corresponding to lines though p and returns the location with the 
largest score.</li>
<li>returns a point X such that get_rect(himg).contains(X) == true</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dlib.hough_transform.get_line">
<code class="descname">get_line</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.hough_transform.get_line" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>get_line(self: dlib.hough_transform, p: dlib.point) -&gt; dlib.line</li>
<li>get_line(self: dlib.hough_transform, p: dlib.dpoint) -&gt; dlib.line</li>
</ol>
<dl class="docutils">
<dt>requires </dt>
<dd><ul class="first last simple">
<li>rectangle(0,0,size-1,size-1).contains(p) == true 
(i.e. p must be a point inside the Hough accumulator array)</li>
</ul>
</dd>
<dt>ensures </dt>
<dd><ul class="first last simple">
<li>returns the line segment in the original image space corresponding 
to Hough transform point p.</li>
<li>The returned points are inside rectangle(0,0,size-1,size-1).</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dlib.hough_transform.get_line_angle_in_degrees">
<code class="descname">get_line_angle_in_degrees</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.hough_transform.get_line_angle_in_degrees" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>get_line_angle_in_degrees(self: dlib.hough_transform, p: dlib.point) -&gt; float</li>
<li>get_line_angle_in_degrees(self: dlib.hough_transform, p: dlib.dpoint) -&gt; float</li>
</ol>
<dl class="docutils">
<dt>requires </dt>
<dd><ul class="first last simple">
<li>rectangle(0,0,size-1,size-1).contains(p) == true 
(i.e. p must be a point inside the Hough accumulator array)</li>
</ul>
</dd>
<dt>ensures </dt>
<dd><ul class="first last simple">
<li>returns the angle, in degrees, of the line corresponding to the Hough 
transform point p.</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dlib.hough_transform.get_line_properties">
<code class="descname">get_line_properties</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.hough_transform.get_line_properties" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>get_line_properties(self: dlib.hough_transform, p: dlib.point) -&gt; tuple</li>
<li>get_line_properties(self: dlib.hough_transform, p: dlib.dpoint) -&gt; tuple</li>
</ol>
<dl class="docutils">
<dt>requires </dt>
<dd><ul class="first last simple">
<li>rectangle(0,0,size-1,size-1).contains(p) == true 
(i.e. p must be a point inside the Hough accumulator array)</li>
</ul>
</dd>
<dt>ensures </dt>
<dd><ul class="first last simple">
<li>Converts a point in the Hough transform space into an angle, in degrees, 
and a radius, measured in pixels from the center of the input image.</li>
<li>let ANGLE_IN_DEGREES == the angle of the line corresponding to the Hough 
transform point p.  Moreover: -90 &lt;= ANGLE_IN_DEGREES &lt; 90.</li>
<li>RADIUS == the distance from the center of the input image, measured in 
pixels, and the line corresponding to the Hough transform point p. 
Moreover: -sqrt(size*size/2) &lt;= RADIUS &lt;= sqrt(size*size/2)</li>
<li>returns a tuple of (ANGLE_IN_DEGREES, RADIUS)</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="dlib.hough_transform.size">
<code class="descname">size</code><a class="headerlink" href="#dlib.hough_transform.size" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the size of the Hough transforms generated by this object.  In particular, this object creates Hough transform images that are size by size pixels in size.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="dlib.hysteresis_threshold">
<code class="descclassname">dlib.</code><code class="descname">hysteresis_threshold</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.hysteresis_threshold" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>hysteresis_threshold(img: numpy.ndarray[(rows,cols),uint8], lower_thresh: int, upper_thresh: int) -&gt; numpy.ndarray[(rows,cols),uint8]</li>
<li>hysteresis_threshold(img: numpy.ndarray[(rows,cols),uint16], lower_thresh: int, upper_thresh: int) -&gt; numpy.ndarray[(rows,cols),uint8]</li>
<li>hysteresis_threshold(img: numpy.ndarray[(rows,cols),uint32], lower_thresh: int, upper_thresh: int) -&gt; numpy.ndarray[(rows,cols),uint8]</li>
<li>hysteresis_threshold(img: numpy.ndarray[(rows,cols),uint64], lower_thresh: int, upper_thresh: int) -&gt; numpy.ndarray[(rows,cols),uint8]</li>
<li>hysteresis_threshold(img: numpy.ndarray[(rows,cols),int8], lower_thresh: int, upper_thresh: int) -&gt; numpy.ndarray[(rows,cols),uint8]</li>
<li>hysteresis_threshold(img: numpy.ndarray[(rows,cols),int16], lower_thresh: int, upper_thresh: int) -&gt; numpy.ndarray[(rows,cols),uint8]</li>
<li>hysteresis_threshold(img: numpy.ndarray[(rows,cols),int32], lower_thresh: int, upper_thresh: int) -&gt; numpy.ndarray[(rows,cols),uint8]</li>
<li>hysteresis_threshold(img: numpy.ndarray[(rows,cols),int64], lower_thresh: int, upper_thresh: int) -&gt; numpy.ndarray[(rows,cols),uint8]</li>
<li>hysteresis_threshold(img: numpy.ndarray[(rows,cols),float32], lower_thresh: float, upper_thresh: float) -&gt; numpy.ndarray[(rows,cols),uint8]</li>
<li>hysteresis_threshold(img: numpy.ndarray[(rows,cols),float64], lower_thresh: float, upper_thresh: float) -&gt; numpy.ndarray[(rows,cols),uint8]</li>
</ol>
<p>Applies hysteresis thresholding to img and returns the results.  In particular, 
pixels in img with values &gt;= upper_thresh have an output value of 255 and all 
others have a value of 0 unless they are &gt;= lower_thresh and are connected to a 
pixel with a value &gt;= upper_thresh, in which case they have a value of 255.  Here 
pixels are connected if there is a path between them composed of pixels that would 
receive an output of 255.</p>
<ol class="arabic simple" start="11">
<li>hysteresis_threshold(img: numpy.ndarray[(rows,cols),uint8]) -&gt; numpy.ndarray[(rows,cols),uint8]</li>
<li>hysteresis_threshold(img: numpy.ndarray[(rows,cols),uint16]) -&gt; numpy.ndarray[(rows,cols),uint8]</li>
<li>hysteresis_threshold(img: numpy.ndarray[(rows,cols),uint32]) -&gt; numpy.ndarray[(rows,cols),uint8]</li>
<li>hysteresis_threshold(img: numpy.ndarray[(rows,cols),uint64]) -&gt; numpy.ndarray[(rows,cols),uint8]</li>
<li>hysteresis_threshold(img: numpy.ndarray[(rows,cols),int8]) -&gt; numpy.ndarray[(rows,cols),uint8]</li>
<li>hysteresis_threshold(img: numpy.ndarray[(rows,cols),int16]) -&gt; numpy.ndarray[(rows,cols),uint8]</li>
<li>hysteresis_threshold(img: numpy.ndarray[(rows,cols),int32]) -&gt; numpy.ndarray[(rows,cols),uint8]</li>
<li>hysteresis_threshold(img: numpy.ndarray[(rows,cols),int64]) -&gt; numpy.ndarray[(rows,cols),uint8]</li>
<li>hysteresis_threshold(img: numpy.ndarray[(rows,cols),float32]) -&gt; numpy.ndarray[(rows,cols),uint8]</li>
<li>hysteresis_threshold(img: numpy.ndarray[(rows,cols),float64]) -&gt; numpy.ndarray[(rows,cols),uint8]</li>
</ol>
<p>performs: return hysteresis_threshold(img, t1, t2) where the thresholds 
are first obtained by calling [t1, t2]=partition_pixels(img).</p>
</dd></dl>

<dl class="class">
<dt id="dlib.image_gradients">
<em class="property">class </em><code class="descclassname">dlib.</code><code class="descname">image_gradients</code><a class="headerlink" href="#dlib.image_gradients" title="Permalink to this definition">¶</a></dt>
<dd><p>This class is a tool for computing first and second derivatives of an 
image.  It does this by fitting a quadratic surface around each pixel and 
then computing the gradients of that quadratic surface.  For the details 
see the paper:</p>
<blockquote>
<div>Quadratic models for curved line detection in SAR CCD by Davis E. King 
and Rhonda D. Phillips</div></blockquote>
<p>This technique gives very accurate gradient estimates and is also very fast 
since the entire gradient estimation procedure, for each type of gradient, 
is accomplished by cross-correlating the image with a single separable 
filter.  This means you can compute gradients at very large scales (e.g. by 
fitting the quadratic to a large window, like a 99x99 window) and it still 
runs very quickly.</p>
<dl class="method">
<dt id="dlib.image_gradients.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.image_gradients.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: dlib.image_gradients, scale: int) -&gt; None</li>
</ol>
<p>Creates this class with the provided scale. i.e. get_scale()==scale. 
scale must be &gt;= 1.</p>
<ol class="arabic simple" start="2">
<li>__init__(self: dlib.image_gradients) -&gt; None</li>
</ol>
<p>Creates this class with a scale of 1. i.e. get_scale()==1</p>
</dd></dl>

<dl class="method">
<dt id="dlib.image_gradients.get_scale">
<code class="descname">get_scale</code><span class="sig-paren">(</span><em>self: dlib.image_gradients</em><span class="sig-paren">)</span> &rarr; int<a class="headerlink" href="#dlib.image_gradients.get_scale" title="Permalink to this definition">¶</a></dt>
<dd><p>When we estimate a gradient we do so by fitting a quadratic filter to a window of size 
get_scale()*2+1 centered on each pixel.  Therefore, the scale parameter controls the size 
of gradients we will find.  For example, a very large scale will cause the gradient_xx() 
to be insensitive to high frequency noise in the image while smaller scales would be more 
sensitive to such fluctuations in the image.</p>
</dd></dl>

<dl class="method">
<dt id="dlib.image_gradients.get_x_filter">
<code class="descname">get_x_filter</code><span class="sig-paren">(</span><em>self: dlib.image_gradients</em><span class="sig-paren">)</span> &rarr; numpy.ndarray[(rows,cols),float32]<a class="headerlink" href="#dlib.image_gradients.get_x_filter" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Returns the filter used by the indicated derivative to compute the image gradient. 
That is, the output gradients are found by cross correlating the returned filter with 
the input image.</li>
<li>The returned filter has get_scale()*2+1 rows and columns.</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="dlib.image_gradients.get_xx_filter">
<code class="descname">get_xx_filter</code><span class="sig-paren">(</span><em>self: dlib.image_gradients</em><span class="sig-paren">)</span> &rarr; numpy.ndarray[(rows,cols),float32]<a class="headerlink" href="#dlib.image_gradients.get_xx_filter" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Returns the filter used by the indicated derivative to compute the image gradient. 
That is, the output gradients are found by cross correlating the returned filter with 
the input image.</li>
<li>The returned filter has get_scale()*2+1 rows and columns.</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="dlib.image_gradients.get_xy_filter">
<code class="descname">get_xy_filter</code><span class="sig-paren">(</span><em>self: dlib.image_gradients</em><span class="sig-paren">)</span> &rarr; numpy.ndarray[(rows,cols),float32]<a class="headerlink" href="#dlib.image_gradients.get_xy_filter" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Returns the filter used by the indicated derivative to compute the image gradient. 
That is, the output gradients are found by cross correlating the returned filter with 
the input image.</li>
<li>The returned filter has get_scale()*2+1 rows and columns.</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="dlib.image_gradients.get_y_filter">
<code class="descname">get_y_filter</code><span class="sig-paren">(</span><em>self: dlib.image_gradients</em><span class="sig-paren">)</span> &rarr; numpy.ndarray[(rows,cols),float32]<a class="headerlink" href="#dlib.image_gradients.get_y_filter" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Returns the filter used by the indicated derivative to compute the image gradient. 
That is, the output gradients are found by cross correlating the returned filter with 
the input image.</li>
<li>The returned filter has get_scale()*2+1 rows and columns.</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="dlib.image_gradients.get_yy_filter">
<code class="descname">get_yy_filter</code><span class="sig-paren">(</span><em>self: dlib.image_gradients</em><span class="sig-paren">)</span> &rarr; numpy.ndarray[(rows,cols),float32]<a class="headerlink" href="#dlib.image_gradients.get_yy_filter" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Returns the filter used by the indicated derivative to compute the image gradient. 
That is, the output gradients are found by cross correlating the returned filter with 
the input image.</li>
<li>The returned filter has get_scale()*2+1 rows and columns.</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="dlib.image_gradients.gradient_x">
<code class="descname">gradient_x</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.image_gradients.gradient_x" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>gradient_x(self: dlib.image_gradients, img: numpy.ndarray[(rows,cols),uint8]) -&gt; tuple</li>
<li>gradient_x(self: dlib.image_gradients, img: numpy.ndarray[(rows,cols),float32]) -&gt; tuple</li>
</ol>
<ul class="simple">
<li>Let VALID_AREA = shrink_rect(get_rect(img),get_scale()).</li>
<li>This routine computes the requested gradient of img at each location in VALID_AREA. 
The gradients are returned in a new image of the same dimensions as img.  All pixels 
outside VALID_AREA are set to 0.  VALID_AREA is also returned.  I.e. we return a tuple 
where the first element is the gradient image and the second is VALID_AREA.</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="dlib.image_gradients.gradient_xx">
<code class="descname">gradient_xx</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.image_gradients.gradient_xx" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>gradient_xx(self: dlib.image_gradients, img: numpy.ndarray[(rows,cols),uint8]) -&gt; tuple</li>
<li>gradient_xx(self: dlib.image_gradients, img: numpy.ndarray[(rows,cols),float32]) -&gt; tuple</li>
</ol>
<ul class="simple">
<li>Let VALID_AREA = shrink_rect(get_rect(img),get_scale()).</li>
<li>This routine computes the requested gradient of img at each location in VALID_AREA. 
The gradients are returned in a new image of the same dimensions as img.  All pixels 
outside VALID_AREA are set to 0.  VALID_AREA is also returned.  I.e. we return a tuple 
where the first element is the gradient image and the second is VALID_AREA.</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="dlib.image_gradients.gradient_xy">
<code class="descname">gradient_xy</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.image_gradients.gradient_xy" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>gradient_xy(self: dlib.image_gradients, img: numpy.ndarray[(rows,cols),uint8]) -&gt; tuple</li>
<li>gradient_xy(self: dlib.image_gradients, img: numpy.ndarray[(rows,cols),float32]) -&gt; tuple</li>
</ol>
<ul class="simple">
<li>Let VALID_AREA = shrink_rect(get_rect(img),get_scale()).</li>
<li>This routine computes the requested gradient of img at each location in VALID_AREA. 
The gradients are returned in a new image of the same dimensions as img.  All pixels 
outside VALID_AREA are set to 0.  VALID_AREA is also returned.  I.e. we return a tuple 
where the first element is the gradient image and the second is VALID_AREA.</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="dlib.image_gradients.gradient_y">
<code class="descname">gradient_y</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.image_gradients.gradient_y" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>gradient_y(self: dlib.image_gradients, img: numpy.ndarray[(rows,cols),uint8]) -&gt; tuple</li>
<li>gradient_y(self: dlib.image_gradients, img: numpy.ndarray[(rows,cols),float32]) -&gt; tuple</li>
</ol>
<ul class="simple">
<li>Let VALID_AREA = shrink_rect(get_rect(img),get_scale()).</li>
<li>This routine computes the requested gradient of img at each location in VALID_AREA. 
The gradients are returned in a new image of the same dimensions as img.  All pixels 
outside VALID_AREA are set to 0.  VALID_AREA is also returned.  I.e. we return a tuple 
where the first element is the gradient image and the second is VALID_AREA.</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="dlib.image_gradients.gradient_yy">
<code class="descname">gradient_yy</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.image_gradients.gradient_yy" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>gradient_yy(self: dlib.image_gradients, img: numpy.ndarray[(rows,cols),uint8]) -&gt; tuple</li>
<li>gradient_yy(self: dlib.image_gradients, img: numpy.ndarray[(rows,cols),float32]) -&gt; tuple</li>
</ol>
<ul class="simple">
<li>Let VALID_AREA = shrink_rect(get_rect(img),get_scale()).</li>
<li>This routine computes the requested gradient of img at each location in VALID_AREA. 
The gradients are returned in a new image of the same dimensions as img.  All pixels 
outside VALID_AREA are set to 0.  VALID_AREA is also returned.  I.e. we return a tuple 
where the first element is the gradient image and the second is VALID_AREA.</li>
</ul>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="dlib.image_window">
<em class="property">class </em><code class="descclassname">dlib.</code><code class="descname">image_window</code><a class="headerlink" href="#dlib.image_window" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a GUI window capable of showing images on the screen.</p>
<dl class="method">
<dt id="dlib.image_window.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.image_window.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: dlib.image_window) -&gt; None</li>
<li>__init__(self: dlib.image_window, arg0: dlib.fhog_object_detector) -&gt; None</li>
<li>__init__(self: dlib.image_window, arg0: dlib.simple_object_detector) -&gt; None</li>
<li>__init__(self: dlib.image_window, arg0: dlib.fhog_object_detector, arg1: unicode) -&gt; None</li>
<li>__init__(self: dlib.image_window, arg0: dlib.simple_object_detector, arg1: unicode) -&gt; None</li>
<li>__init__(self: dlib.image_window, arg0: numpy.ndarray[(rows,cols),uint8]) -&gt; None</li>
<li>__init__(self: dlib.image_window, arg0: numpy.ndarray[(rows,cols),uint16]) -&gt; None</li>
<li>__init__(self: dlib.image_window, arg0: numpy.ndarray[(rows,cols),uint32]) -&gt; None</li>
<li>__init__(self: dlib.image_window, arg0: numpy.ndarray[(rows,cols),uint64]) -&gt; None</li>
<li>__init__(self: dlib.image_window, arg0: numpy.ndarray[(rows,cols),int8]) -&gt; None</li>
<li>__init__(self: dlib.image_window, arg0: numpy.ndarray[(rows,cols),int16]) -&gt; None</li>
<li>__init__(self: dlib.image_window, arg0: numpy.ndarray[(rows,cols),int32]) -&gt; None</li>
<li>__init__(self: dlib.image_window, arg0: numpy.ndarray[(rows,cols),int64]) -&gt; None</li>
<li>__init__(self: dlib.image_window, arg0: numpy.ndarray[(rows,cols),float32]) -&gt; None</li>
<li>__init__(self: dlib.image_window, arg0: numpy.ndarray[(rows,cols),float64]) -&gt; None</li>
<li>__init__(self: dlib.image_window, arg0: numpy.ndarray[(rows,cols,3),uint8]) -&gt; None</li>
</ol>
<p>Create an image window that displays the given numpy image.</p>
<ol class="arabic simple" start="17">
<li>__init__(self: dlib.image_window, arg0: numpy.ndarray[(rows,cols),uint8], arg1: unicode) -&gt; None</li>
<li>__init__(self: dlib.image_window, arg0: numpy.ndarray[(rows,cols),uint16], arg1: unicode) -&gt; None</li>
<li>__init__(self: dlib.image_window, arg0: numpy.ndarray[(rows,cols),uint32], arg1: unicode) -&gt; None</li>
<li>__init__(self: dlib.image_window, arg0: numpy.ndarray[(rows,cols),uint64], arg1: unicode) -&gt; None</li>
<li>__init__(self: dlib.image_window, arg0: numpy.ndarray[(rows,cols),int8], arg1: unicode) -&gt; None</li>
<li>__init__(self: dlib.image_window, arg0: numpy.ndarray[(rows,cols),int16], arg1: unicode) -&gt; None</li>
<li>__init__(self: dlib.image_window, arg0: numpy.ndarray[(rows,cols),int32], arg1: unicode) -&gt; None</li>
<li>__init__(self: dlib.image_window, arg0: numpy.ndarray[(rows,cols),int64], arg1: unicode) -&gt; None</li>
<li>__init__(self: dlib.image_window, arg0: numpy.ndarray[(rows,cols),float32], arg1: unicode) -&gt; None</li>
<li>__init__(self: dlib.image_window, arg0: numpy.ndarray[(rows,cols),float64], arg1: unicode) -&gt; None</li>
<li>__init__(self: dlib.image_window, arg0: numpy.ndarray[(rows,cols,3),uint8], arg1: unicode) -&gt; None</li>
</ol>
<p>Create an image window that displays the given numpy image and also has the given title.</p>
</dd></dl>

<dl class="method">
<dt id="dlib.image_window.add_overlay">
<code class="descname">add_overlay</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.image_window.add_overlay" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>add_overlay(self: dlib.image_window, rectangles: dlib.rectangles, color: dlib.rgb_pixel=rgb_pixel(255,0,0)) -&gt; None</li>
</ol>
<p>Add a list of rectangles to the image_window. They will be displayed as red boxes by default, but the color can be passed.</p>
<ol class="arabic simple" start="2">
<li>add_overlay(self: dlib.image_window, rectangle: dlib.rectangle, color: dlib.rgb_pixel=rgb_pixel(255,0,0)) -&gt; None</li>
</ol>
<p>Add a rectangle to the image_window.  It will be displayed as a red box by default, but the color can be passed.</p>
<ol class="arabic simple" start="3">
<li>add_overlay(self: dlib.image_window, rectangle: dlib.drectangle, color: dlib.rgb_pixel=rgb_pixel(255,0,0)) -&gt; None</li>
</ol>
<p>Add a rectangle to the image_window.  It will be displayed as a red box by default, but the color can be passed.</p>
<ol class="arabic simple" start="4">
<li>add_overlay(self: dlib.image_window, detection: dlib.full_object_detection, color: dlib.rgb_pixel=rgb_pixel(0,0,255)) -&gt; None</li>
</ol>
<p>Add full_object_detection parts to the image window. They will be displayed as blue lines by default, but the color can be passed.</p>
<ol class="arabic simple" start="5">
<li>add_overlay(self: dlib.image_window, line: dlib.line, color: dlib.rgb_pixel=rgb_pixel(255,0,0)) -&gt; None</li>
</ol>
<p>Add line to the image window.</p>
<ol class="arabic simple" start="6">
<li>add_overlay(self: dlib.image_window, objects: list, color: dlib.rgb_pixel=rgb_pixel(255,0,0)) -&gt; None</li>
</ol>
<p>Adds all the overlayable objects, uses the given color.</p>
</dd></dl>

<dl class="method">
<dt id="dlib.image_window.add_overlay_circle">
<code class="descname">add_overlay_circle</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.image_window.add_overlay_circle" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>add_overlay_circle(self: dlib.image_window, center: dlib.point, radius: float, color: dlib.rgb_pixel=rgb_pixel(255,0,0)) -&gt; None</li>
</ol>
<p>Add circle to the image window.</p>
<ol class="arabic simple" start="2">
<li>add_overlay_circle(self: dlib.image_window, center: dlib.dpoint, radius: float, color: dlib.rgb_pixel=rgb_pixel(255,0,0)) -&gt; None</li>
</ol>
<p>Add circle to the image window.</p>
</dd></dl>

<dl class="method">
<dt id="dlib.image_window.clear_overlay">
<code class="descname">clear_overlay</code><span class="sig-paren">(</span><em>self: dlib.image_window</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.image_window.clear_overlay" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove all overlays from the image_window.</p>
</dd></dl>

<dl class="method">
<dt id="dlib.image_window.set_image">
<code class="descname">set_image</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.image_window.set_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>set_image(self: dlib.image_window, detector: dlib.simple_object_detector) -&gt; None</li>
</ol>
<p>Make the image_window display the given HOG detector&#8217;s filters.</p>
<ol class="arabic simple" start="2">
<li>set_image(self: dlib.image_window, detector: dlib.fhog_object_detector) -&gt; None</li>
</ol>
<p>Make the image_window display the given HOG detector&#8217;s filters.</p>
<ol class="arabic simple" start="3">
<li>set_image(self: dlib.image_window, image: numpy.ndarray[(rows,cols),uint8]) -&gt; None</li>
<li>set_image(self: dlib.image_window, image: numpy.ndarray[(rows,cols),uint16]) -&gt; None</li>
<li>set_image(self: dlib.image_window, image: numpy.ndarray[(rows,cols),uint32]) -&gt; None</li>
<li>set_image(self: dlib.image_window, image: numpy.ndarray[(rows,cols),uint64]) -&gt; None</li>
<li>set_image(self: dlib.image_window, image: numpy.ndarray[(rows,cols),int8]) -&gt; None</li>
<li>set_image(self: dlib.image_window, image: numpy.ndarray[(rows,cols),int16]) -&gt; None</li>
<li>set_image(self: dlib.image_window, image: numpy.ndarray[(rows,cols),int32]) -&gt; None</li>
<li>set_image(self: dlib.image_window, image: numpy.ndarray[(rows,cols),int64]) -&gt; None</li>
<li>set_image(self: dlib.image_window, image: numpy.ndarray[(rows,cols),float32]) -&gt; None</li>
<li>set_image(self: dlib.image_window, image: numpy.ndarray[(rows,cols),float64]) -&gt; None</li>
<li>set_image(self: dlib.image_window, image: numpy.ndarray[(rows,cols,3),uint8]) -&gt; None</li>
</ol>
<p>Make the image_window display the given image.</p>
</dd></dl>

<dl class="method">
<dt id="dlib.image_window.set_title">
<code class="descname">set_title</code><span class="sig-paren">(</span><em>self: dlib.image_window</em>, <em>title: unicode</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.image_window.set_title" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the title of the window to the given value.</p>
</dd></dl>

<dl class="method">
<dt id="dlib.image_window.wait_until_closed">
<code class="descname">wait_until_closed</code><span class="sig-paren">(</span><em>self: dlib.image_window</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.image_window.wait_until_closed" title="Permalink to this definition">¶</a></dt>
<dd><p>This function blocks until the window is closed.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="dlib.intersect">
<code class="descclassname">dlib.</code><code class="descname">intersect</code><span class="sig-paren">(</span><em>a: dlib.line</em>, <em>b: dlib.line</em><span class="sig-paren">)</span> &rarr; dlib.dpoint<a class="headerlink" href="#dlib.intersect" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>ensures </dt>
<dd><ul class="first last simple">
<li>returns the point of intersection between lines a and b.  If no such point 
exists then this function returns a point with Inf values in it.</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="dlib.inv">
<code class="descclassname">dlib.</code><code class="descname">inv</code><span class="sig-paren">(</span><em>trans: dlib.point_transform_projective</em><span class="sig-paren">)</span> &rarr; dlib.point_transform_projective<a class="headerlink" href="#dlib.inv" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>ensures </dt>
<dd><ul class="first last simple">
<li>If trans is an invertible transformation then this function returns a new 
transformation that is the inverse of trans.</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="dlib.jet">
<code class="descclassname">dlib.</code><code class="descname">jet</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.jet" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>jet(img: numpy.ndarray[(rows,cols),uint8]) -&gt; numpy.ndarray[(rows,cols,3),uint8]</li>
<li>jet(img: numpy.ndarray[(rows,cols),uint16]) -&gt; numpy.ndarray[(rows,cols,3),uint8]</li>
<li>jet(img: numpy.ndarray[(rows,cols),uint32]) -&gt; numpy.ndarray[(rows,cols,3),uint8]</li>
<li>jet(img: numpy.ndarray[(rows,cols),float32]) -&gt; numpy.ndarray[(rows,cols,3),uint8]</li>
<li>jet(img: numpy.ndarray[(rows,cols),float64]) -&gt; numpy.ndarray[(rows,cols,3),uint8]</li>
</ol>
<p>Converts a grayscale image into a jet colored image.  This is an image where dark 
pixels are dark blue and larger values become light blue, then yellow, and then 
finally red as they approach the maximum pixel values.</p>
</dd></dl>

<dl class="function">
<dt id="dlib.jitter_image">
<code class="descclassname">dlib.</code><code class="descname">jitter_image</code><span class="sig-paren">(</span><em>img: numpy.ndarray[(rows,cols,3),uint8], num_jitters: int=1L, disturb_colors: bool=False</em><span class="sig-paren">)</span> &rarr; list<a class="headerlink" href="#dlib.jitter_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes an image and returns a list of jittered images.The returned list contains num_jitters images (default is 1).If disturb_colors is set to True, the colors of the image are disturbed (default is False)</p>
</dd></dl>

<dl class="function">
<dt id="dlib.label_connected_blobs">
<code class="descclassname">dlib.</code><code class="descname">label_connected_blobs</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.label_connected_blobs" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>label_connected_blobs(img: numpy.ndarray[(rows,cols),uint8], zero_pixels_are_background: bool=True, neighborhood_connectivity: int=8L, connected_if_both_not_zero: bool=False) -&gt; tuple</li>
<li>label_connected_blobs(img: numpy.ndarray[(rows,cols),uint16], zero_pixels_are_background: bool=True, neighborhood_connectivity: int=8L, connected_if_both_not_zero: bool=False) -&gt; tuple</li>
<li>label_connected_blobs(img: numpy.ndarray[(rows,cols),uint32], zero_pixels_are_background: bool=True, neighborhood_connectivity: int=8L, connected_if_both_not_zero: bool=False) -&gt; tuple</li>
<li>label_connected_blobs(img: numpy.ndarray[(rows,cols),uint64], zero_pixels_are_background: bool=True, neighborhood_connectivity: int=8L, connected_if_both_not_zero: bool=False) -&gt; tuple</li>
<li>label_connected_blobs(img: numpy.ndarray[(rows,cols),float32], zero_pixels_are_background: bool=True, neighborhood_connectivity: int=8L, connected_if_both_not_zero: bool=False) -&gt; tuple</li>
<li>label_connected_blobs(img: numpy.ndarray[(rows,cols),float64], zero_pixels_are_background: bool=True, neighborhood_connectivity: int=8L, connected_if_both_not_zero: bool=False) -&gt; tuple</li>
</ol>
<dl class="docutils">
<dt>requires </dt>
<dd><ul class="first last simple">
<li>neighborhood_connectivity == 4, 8, or 24</li>
</ul>
</dd>
<dt>ensures </dt>
<dd><ul class="first last">
<li><p class="first">This function labels each of the connected blobs in img with a unique integer  
label.</p>
</li>
<li><p class="first">An image can be thought of as a graph where pixels A and B are connected if 
they are close to each other and satisfy some criterion like having the same 
value or both being non-zero.  Then this function can be understood as 
labeling all the connected components of this pixel graph such that all 
pixels in a component get the same label while pixels in different components 
get different labels.</p>
</li>
<li><p class="first">If zero_pixels_are_background==true then there is a special background component 
and all pixels with value 0 are assigned to it. Moreover, all such background pixels 
will always get a blob id of 0 regardless of any other considerations.</p>
</li>
<li><p class="first">This function returns a label image and a count of the number of blobs found. 
I.e., if you ran this function like:</p>
<blockquote>
<div><p>label_img, num_blobs = label_connected_blobs(img)</p>
</div></blockquote>
<p>You would obtain the noted label image and number of blobs.</p>
</li>
<li><p class="first">The output label_img has the same dimensions as the input image.</p>
</li>
<li><dl class="first docutils">
<dt>for all valid r and c: </dt>
<dd><ul class="first last">
<li><p class="first">label_img[r][c] == the blob label number for pixel img[r][c].</p>
</li>
<li><p class="first">label_img[r][c] &gt;= 0</p>
</li>
<li><dl class="first docutils">
<dt>if (img[r][c]==0) then </dt>
<dd><ul class="first last simple">
<li>label_img[r][c] == 0</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>else </dt>
<dd><ul class="first last simple">
<li>label_img[r][c] != 0</li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>if (len(img) != 0) then  </dt>
<dd><ul class="first last simple">
<li>The returned num_blobs will be == label_img.max()+1 
(i.e. returns a number one greater than the maximum blob id number,  
this is the number of blobs found.)</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>else </dt>
<dd><ul class="first last simple">
<li>num_blobs will be 0.</li>
</ul>
</dd>
</dl>
</li>
<li><p class="first">blob labels are contiguous, therefore, the number returned by this function is 
the number of blobs in the image (including the background blob).</p>
</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="dlib.label_connected_blobs_watershed">
<code class="descclassname">dlib.</code><code class="descname">label_connected_blobs_watershed</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.label_connected_blobs_watershed" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>label_connected_blobs_watershed(img: numpy.ndarray[(rows,cols),uint8], background_thresh: int, smoothing: float=0L) -&gt; tuple</li>
<li>label_connected_blobs_watershed(img: numpy.ndarray[(rows,cols),uint16], background_thresh: int, smoothing: float=0L) -&gt; tuple</li>
<li>label_connected_blobs_watershed(img: numpy.ndarray[(rows,cols),uint32], background_thresh: int, smoothing: float=0L) -&gt; tuple</li>
<li>label_connected_blobs_watershed(img: numpy.ndarray[(rows,cols),float32], background_thresh: float, smoothing: float=0L) -&gt; tuple</li>
<li>label_connected_blobs_watershed(img: numpy.ndarray[(rows,cols),float64], background_thresh: float, smoothing: float=0L) -&gt; tuple</li>
</ol>
<dl class="docutils">
<dt>requires </dt>
<dd><ul class="first last simple">
<li>smoothing &gt;= 0</li>
</ul>
</dd>
<dt>ensures </dt>
<dd><ul class="first last">
<li><p class="first">This routine performs a watershed segmentation of the given input image and 
labels each resulting flooding region with a unique integer label. It does 
this by marking the brightest pixels as sources of flooding and then flood 
fills the image outward from those sources.  Each flooded area is labeled 
with the identity of the source pixel and flooding stops when another flooded 
area is reached or pixels with values &lt; background_thresh are encountered.</p>
</li>
<li><p class="first">The flooding will also overrun a source pixel if that source pixel has yet to 
label any neighboring pixels.  This behavior helps to mitigate spurious 
splits of objects due to noise.  You can further control this behavior by 
setting the smoothing parameter.  The flooding will take place on an image 
that has been Gaussian blurred with a sigma==smoothing.  So setting smoothing 
to a larger number will in general cause more regions to be merged together. 
Note that the smoothing parameter has no effect on the interpretation of 
background_thresh since the decision of &#8220;background or not background&#8221; is 
always made relative to the unsmoothed input image.</p>
</li>
<li><p class="first">This function returns a tuple of the labeled image and number of blobs found.  
i.e. you can call it like this:</p>
<blockquote>
<div><p>label_img, num_blobs = label_connected_blobs_watershed(img,background_thresh,smoothing)</p>
</div></blockquote>
</li>
<li><p class="first">The returned label_img will have the same dimensions as img.</p>
</li>
<li><dl class="first docutils">
<dt>for all valid r and c: </dt>
<dd><ul class="first last">
<li><dl class="first docutils">
<dt>if (img[r][c] &lt; background_thresh) then </dt>
<dd><ul class="first last simple">
<li>label_img[r][c] == 0, (i.e. the pixel is labeled as background)</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>else </dt>
<dd><ul class="first last simple">
<li>label_img[r][c] == an integer value indicating the identity of the segment 
containing the pixel img[r][c].</li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</li>
<li><p class="first">The returned num_blobs is the number of labeled segments, including the 
background segment.  Therefore, the returned number is 1+(the max value in 
label_img).</p>
</li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="6">
<li>label_connected_blobs_watershed(img: numpy.ndarray[(rows,cols),uint8]) -&gt; tuple</li>
<li>label_connected_blobs_watershed(img: numpy.ndarray[(rows,cols),uint16]) -&gt; tuple</li>
<li>label_connected_blobs_watershed(img: numpy.ndarray[(rows,cols),uint32]) -&gt; tuple</li>
<li>label_connected_blobs_watershed(img: numpy.ndarray[(rows,cols),float32]) -&gt; tuple</li>
<li>label_connected_blobs_watershed(img: numpy.ndarray[(rows,cols),float64]) -&gt; tuple</li>
</ol>
<dl class="docutils">
<dt>This version of label_connected_blobs_watershed simple invokes: </dt>
<dd>return label_connected_blobs_watershed(img, partition_pixels(img))</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="dlib.length">
<code class="descclassname">dlib.</code><code class="descname">length</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.length" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>length(p: dlib.point) -&gt; float</li>
</ol>
<p>returns the distance from p to the origin, i.e. the L2 norm of p.</p>
<ol class="arabic simple" start="2">
<li>length(p: dlib.dpoint) -&gt; float</li>
</ol>
<p>returns the distance from p to the origin, i.e. the L2 norm of p.</p>
</dd></dl>

<dl class="class">
<dt id="dlib.line">
<em class="property">class </em><code class="descclassname">dlib.</code><code class="descname">line</code><a class="headerlink" href="#dlib.line" title="Permalink to this definition">¶</a></dt>
<dd><p>This object represents a line in the 2D plane.  The line is defined by two points 
running through it, p1 and p2.  This object also includes a unit normal vector that 
is perpendicular to the line.</p>
<dl class="method">
<dt id="dlib.line.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.line.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: dlib.line) -&gt; None</li>
</ol>
<p>p1, p2, and normal are all the 0 vector.</p>
<ol class="arabic simple" start="2">
<li>__init__(self: dlib.line, a: dlib.dpoint, b: dlib.dpoint) -&gt; None</li>
</ol>
<dl class="docutils">
<dt>ensures </dt>
<dd><ul class="first last simple">
<li>#p1 == a</li>
<li>#p2 == b</li>
<li>#normal == A vector normal to the line passing through points a and b. 
Therefore, the normal vector is the vector (a-b) but unit normalized and rotated clockwise 90 degrees.</li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="3">
<li>__init__(self: dlib.line, a: dlib.point, b: dlib.point) -&gt; None</li>
</ol>
<dl class="docutils">
<dt>ensures </dt>
<dd><ul class="first last simple">
<li>#p1 == a</li>
<li>#p2 == b</li>
<li>#normal == A vector normal to the line passing through points a and b. 
Therefore, the normal vector is the vector (a-b) but unit normalized and rotated clockwise 90 degrees.</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="dlib.line.normal">
<code class="descname">normal</code><a class="headerlink" href="#dlib.line.normal" title="Permalink to this definition">¶</a></dt>
<dd><p>returns a unit vector that is normal to the line passing through p1 and p2.</p>
</dd></dl>

<dl class="attribute">
<dt id="dlib.line.p1">
<code class="descname">p1</code><a class="headerlink" href="#dlib.line.p1" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the first endpoint of the line.</p>
</dd></dl>

<dl class="attribute">
<dt id="dlib.line.p2">
<code class="descname">p2</code><a class="headerlink" href="#dlib.line.p2" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the second endpoint of the line.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="dlib.load_grayscale_image">
<code class="descclassname">dlib.</code><code class="descname">load_grayscale_image</code><span class="sig-paren">(</span><em>filename: unicode</em><span class="sig-paren">)</span> &rarr; numpy.ndarray[(rows,cols),uint8]<a class="headerlink" href="#dlib.load_grayscale_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a path and returns a numpy array containing the image, as an 8bit grayscale image.</p>
</dd></dl>

<dl class="function">
<dt id="dlib.load_libsvm_formatted_data">
<code class="descclassname">dlib.</code><code class="descname">load_libsvm_formatted_data</code><span class="sig-paren">(</span><em>file_name: unicode</em><span class="sig-paren">)</span> &rarr; tuple<a class="headerlink" href="#dlib.load_libsvm_formatted_data" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>ensures    </dt>
<dd><ul class="first last simple">
<li>Attempts to read a file of the given name that should contain libsvm    
formatted data.  The data is returned as a tuple where the first tuple    
element is an array of sparse vectors and the second element is an array of    
labels.</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="dlib.load_rgb_image">
<code class="descclassname">dlib.</code><code class="descname">load_rgb_image</code><span class="sig-paren">(</span><em>filename: unicode</em><span class="sig-paren">)</span> &rarr; numpy.ndarray[(rows,cols,3),uint8]<a class="headerlink" href="#dlib.load_rgb_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a path and returns a numpy array (RGB) containing the image</p>
</dd></dl>

<dl class="function">
<dt id="dlib.make_bounding_box_regression_training_data">
<code class="descclassname">dlib.</code><code class="descname">make_bounding_box_regression_training_data</code><span class="sig-paren">(</span><em>truth: dlib.image_dataset_metadata.dataset</em>, <em>detections: object</em><span class="sig-paren">)</span> &rarr; dlib.image_dataset_metadata.dataset<a class="headerlink" href="#dlib.make_bounding_box_regression_training_data" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>requires </dt>
<dd><ul class="first last simple">
<li>len(truth.images) == len(detections)</li>
<li>detections == A dlib.rectangless object or a list of dlib.rectangles.</li>
</ul>
</dd>
<dt>ensures </dt>
<dd><ul class="first last">
<li><p class="first">Suppose you have an object detector that can roughly locate objects in an 
image.  This means your detector draws boxes around objects, but these are 
<em>rough</em> boxes in the sense that they aren&#8217;t positioned super accurately.  For 
instance, HOG based detectors usually have a stride of 8 pixels.  So the 
positional accuracy is going to be, at best, +/-8 pixels.</p>
<p>If you want to get better positional accuracy one easy thing to do is train a 
shape_predictor to give you the corners of the object.  The 
make_bounding_box_regression_training_data() routine helps you do this by 
creating an appropriate training dataset.  It does this by taking the dataset 
you used to train your detector (the truth object), and combining that with 
the output of your detector on each image in the training dataset (the 
detections object).  In particular, it will create a new annotated dataset 
where each object box is one of the rectangles from detections and that 
object has 4 part annotations, the corners of the truth rectangle 
corresponding to that detection rectangle.  You can then take the returned 
dataset and train a shape_predictor on it.  The resulting shape_predictor can 
then be used to do bounding box regression.</p>
</li>
<li><p class="first">We assume that detections[i] contains object detections corresponding to  
the image truth.images[i].</p>
</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="dlib.make_sparse_vector">
<code class="descclassname">dlib.</code><code class="descname">make_sparse_vector</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.make_sparse_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>make_sparse_vector(arg0: dlib.sparse_vector) -&gt; None</li>
</ol>
<p>This function modifies its argument so that it is a properly sorted sparse vector.    
This means that the elements of the sparse vector will be ordered so that pairs    
with smaller indices come first.  Additionally, there won&#8217;t be any pairs with    
identical indices.  If such pairs were present in the input sparse vector then    
their values will be added together and only one pair with their index will be    
present in the output.</p>
<ol class="arabic simple" start="2">
<li>make_sparse_vector(arg0: dlib.sparse_vectors) -&gt; None</li>
</ol>
<p>This function modifies a sparse_vectors object so that all elements it contains are properly sorted sparse vectors.</p>
</dd></dl>

<dl class="class">
<dt id="dlib.matrix">
<em class="property">class </em><code class="descclassname">dlib.</code><code class="descname">matrix</code><a class="headerlink" href="#dlib.matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>This object represents a dense 2D matrix of floating point numbers.Moreover, it binds directly to the C++ type dlib::matrix&lt;double&gt;.</p>
<dl class="method">
<dt id="dlib.matrix.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.matrix.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: dlib.matrix) -&gt; None</li>
<li>__init__(self: dlib.matrix, arg0: list) -&gt; None</li>
<li>__init__(self: dlib.matrix, arg0: object) -&gt; None</li>
<li>__init__(self: dlib.matrix, arg0: int, arg1: int) -&gt; None</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="dlib.matrix.nc">
<code class="descname">nc</code><span class="sig-paren">(</span><em>self: dlib.matrix</em><span class="sig-paren">)</span> &rarr; int<a class="headerlink" href="#dlib.matrix.nc" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of columns in the matrix.</p>
</dd></dl>

<dl class="method">
<dt id="dlib.matrix.nr">
<code class="descname">nr</code><span class="sig-paren">(</span><em>self: dlib.matrix</em><span class="sig-paren">)</span> &rarr; int<a class="headerlink" href="#dlib.matrix.nr" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of rows in the matrix.</p>
</dd></dl>

<dl class="method">
<dt id="dlib.matrix.set_size">
<code class="descname">set_size</code><span class="sig-paren">(</span><em>self: dlib.matrix</em>, <em>rows: int</em>, <em>cols: int</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.matrix.set_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the size of the matrix to the given number of rows and columns.</p>
</dd></dl>

<dl class="attribute">
<dt id="dlib.matrix.shape">
<code class="descname">shape</code><a class="headerlink" href="#dlib.matrix.shape" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="dlib.max_cost_assignment">
<code class="descclassname">dlib.</code><code class="descname">max_cost_assignment</code><span class="sig-paren">(</span><em>cost: dlib.matrix</em><span class="sig-paren">)</span> &rarr; list<a class="headerlink" href="#dlib.max_cost_assignment" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>requires    </dt>
<dd><ul class="first last simple">
<li>cost.nr() == cost.nc()    
(i.e. the input must be a square matrix)</li>
</ul>
</dd>
<dt>ensures    </dt>
<dd><ul class="first last">
<li><p class="first">Finds and returns the solution to the following optimization problem:</p>
<blockquote>
<div><p>Maximize: f(A) == assignment_cost(cost, A)    
Subject to the following constraints:</p>
<blockquote>
<div><ul class="simple">
<li>The elements of A are unique. That is, there aren&#8217;t any     
elements of A which are equal.</li>
<li>len(A) == cost.nr()</li>
</ul>
</div></blockquote>
</div></blockquote>
</li>
<li><p class="first">Note that this function converts the input cost matrix into a 64bit fixed    
point representation.  Therefore, you should make sure that the values in    
your cost matrix can be accurately represented by 64bit fixed point values.    
If this is not the case then the solution my become inaccurate due to    
rounding error.  In general, this function will work properly when the ratio    
of the largest to the smallest value in cost is no more than about 1e16.</p>
</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="dlib.max_index_plus_one">
<code class="descclassname">dlib.</code><code class="descname">max_index_plus_one</code><span class="sig-paren">(</span><em>v: dlib.sparse_vector</em><span class="sig-paren">)</span> &rarr; int<a class="headerlink" href="#dlib.max_index_plus_one" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>ensures    </dt>
<dd><ul class="first last simple">
<li>returns the dimensionality of the given sparse vector.  That is, returns a    
number one larger than the maximum index value in the vector.  If the vector    
is empty then returns 0.</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="dlib.max_point">
<code class="descclassname">dlib.</code><code class="descname">max_point</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.max_point" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>max_point(img: numpy.ndarray[(rows,cols),uint8]) -&gt; dlib.dpoint</li>
<li>max_point(img: numpy.ndarray[(rows,cols),uint16]) -&gt; dlib.dpoint</li>
<li>max_point(img: numpy.ndarray[(rows,cols),uint32]) -&gt; dlib.dpoint</li>
<li>max_point(img: numpy.ndarray[(rows,cols),uint64]) -&gt; dlib.dpoint</li>
<li>max_point(img: numpy.ndarray[(rows,cols),int8]) -&gt; dlib.dpoint</li>
<li>max_point(img: numpy.ndarray[(rows,cols),int16]) -&gt; dlib.dpoint</li>
<li>max_point(img: numpy.ndarray[(rows,cols),int32]) -&gt; dlib.dpoint</li>
<li>max_point(img: numpy.ndarray[(rows,cols),int64]) -&gt; dlib.dpoint</li>
<li>max_point(img: numpy.ndarray[(rows,cols),float32]) -&gt; dlib.dpoint</li>
<li>max_point(img: numpy.ndarray[(rows,cols),float64]) -&gt; dlib.dpoint</li>
</ol>
<dl class="docutils">
<dt>requires </dt>
<dd><ul class="first last simple">
<li>m.size &gt; 0</li>
</ul>
</dd>
<dt>ensures </dt>
<dd><ul class="first last simple">
<li>returns the location of the maximum element of the array, that is, if the 
returned point is P then it will be the case that: img[P.y,P.x] == img.max().</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="dlib.max_point_interpolated">
<code class="descclassname">dlib.</code><code class="descname">max_point_interpolated</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.max_point_interpolated" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>max_point_interpolated(img: numpy.ndarray[(rows,cols),uint8]) -&gt; dlib.dpoint</li>
<li>max_point_interpolated(img: numpy.ndarray[(rows,cols),uint16]) -&gt; dlib.dpoint</li>
<li>max_point_interpolated(img: numpy.ndarray[(rows,cols),uint32]) -&gt; dlib.dpoint</li>
<li>max_point_interpolated(img: numpy.ndarray[(rows,cols),uint64]) -&gt; dlib.dpoint</li>
<li>max_point_interpolated(img: numpy.ndarray[(rows,cols),int8]) -&gt; dlib.dpoint</li>
<li>max_point_interpolated(img: numpy.ndarray[(rows,cols),int16]) -&gt; dlib.dpoint</li>
<li>max_point_interpolated(img: numpy.ndarray[(rows,cols),int32]) -&gt; dlib.dpoint</li>
<li>max_point_interpolated(img: numpy.ndarray[(rows,cols),int64]) -&gt; dlib.dpoint</li>
<li>max_point_interpolated(img: numpy.ndarray[(rows,cols),float32]) -&gt; dlib.dpoint</li>
<li>max_point_interpolated(img: numpy.ndarray[(rows,cols),float64]) -&gt; dlib.dpoint</li>
</ol>
<dl class="docutils">
<dt>requires </dt>
<dd><ul class="first last simple">
<li>m.size &gt; 0</li>
</ul>
</dd>
<dt>ensures </dt>
<dd><ul class="first last simple">
<li>Like max_point(), this function finds the location in m with the largest 
value.  However, we additionally use some quadratic interpolation to find the 
location of the maximum point with sub-pixel accuracy.  Therefore, the 
returned point is equal to max_point(m) + some small sub-pixel delta.</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="dlib.min_barrier_distance">
<code class="descclassname">dlib.</code><code class="descname">min_barrier_distance</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.min_barrier_distance" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>min_barrier_distance(img: numpy.ndarray[(rows,cols),uint8], iterations: int=10L, do_left_right_scans: bool=True) -&gt; numpy.ndarray[(rows,cols),uint8]</li>
<li>min_barrier_distance(img: numpy.ndarray[(rows,cols),uint16], iterations: int=10L, do_left_right_scans: bool=True) -&gt; numpy.ndarray[(rows,cols),uint16]</li>
<li>min_barrier_distance(img: numpy.ndarray[(rows,cols),uint32], iterations: int=10L, do_left_right_scans: bool=True) -&gt; numpy.ndarray[(rows,cols),uint32]</li>
<li>min_barrier_distance(img: numpy.ndarray[(rows,cols),uint64], iterations: int=10L, do_left_right_scans: bool=True) -&gt; numpy.ndarray[(rows,cols),uint64]</li>
<li>min_barrier_distance(img: numpy.ndarray[(rows,cols),int8], iterations: int=10L, do_left_right_scans: bool=True) -&gt; numpy.ndarray[(rows,cols),int8]</li>
<li>min_barrier_distance(img: numpy.ndarray[(rows,cols),int16], iterations: int=10L, do_left_right_scans: bool=True) -&gt; numpy.ndarray[(rows,cols),int16]</li>
<li>min_barrier_distance(img: numpy.ndarray[(rows,cols),int32], iterations: int=10L, do_left_right_scans: bool=True) -&gt; numpy.ndarray[(rows,cols),int32]</li>
<li>min_barrier_distance(img: numpy.ndarray[(rows,cols),int64], iterations: int=10L, do_left_right_scans: bool=True) -&gt; numpy.ndarray[(rows,cols),int64]</li>
<li>min_barrier_distance(img: numpy.ndarray[(rows,cols),float32], iterations: int=10L, do_left_right_scans: bool=True) -&gt; numpy.ndarray[(rows,cols),float32]</li>
<li>min_barrier_distance(img: numpy.ndarray[(rows,cols),float64], iterations: int=10L, do_left_right_scans: bool=True) -&gt; numpy.ndarray[(rows,cols),float64]</li>
<li>min_barrier_distance(img: numpy.ndarray[(rows,cols,3),uint8], iterations: int=10L, do_left_right_scans: bool=True) -&gt; numpy.ndarray[(rows,cols),uint8]</li>
</ol>
<dl class="docutils">
<dt>requires </dt>
<dd><ul class="first last simple">
<li>iterations &gt; 0</li>
</ul>
</dd>
<dt>ensures </dt>
<dd><ul class="first last">
<li><dl class="first docutils">
<dt>This function implements the salient object detection method described in the paper: </dt>
<dd><p class="first last">&#8220;Minimum barrier salient object detection at 80 fps&#8221; by Zhang, Jianming, et al.</p>
</dd>
</dl>
<p>In particular, we compute the minimum barrier distance between the borders of 
the image and all the other pixels.  The resulting image is returned.  Note that 
the paper talks about a bunch of other things you could do beyond computing 
the minimum barrier distance, but this function doesn&#8217;t do any of that. It&#8217;s 
just the vanilla MBD.</p>
</li>
<li><p class="first">We will perform iterations iterations of MBD passes over the image.  Larger 
values might give better results but run slower.</p>
</li>
<li><p class="first">During each MBD iteration we make raster scans over the image.  These pass 
from top-&gt;bottom, bottom-&gt;top, left-&gt;right, and right-&gt;left.  If 
do_left_right_scans==false then the left/right passes are not executed. 
Skipping them makes the algorithm about 2x faster but might reduce the 
quality of the output.</p>
</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="dlib.mmod_rectangle">
<em class="property">class </em><code class="descclassname">dlib.</code><code class="descname">mmod_rectangle</code><a class="headerlink" href="#dlib.mmod_rectangle" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapper around a rectangle object and a detection confidence score.</p>
<dl class="attribute">
<dt id="dlib.mmod_rectangle.__init__">
<code class="descname">__init__</code><a class="headerlink" href="#dlib.mmod_rectangle.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__init__(...) initializes x; see help(type(x)) for signature</p>
</dd></dl>

<dl class="attribute">
<dt id="dlib.mmod_rectangle.confidence">
<code class="descname">confidence</code><a class="headerlink" href="#dlib.mmod_rectangle.confidence" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.mmod_rectangle.rect">
<code class="descname">rect</code><a class="headerlink" href="#dlib.mmod_rectangle.rect" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="dlib.mmod_rectangles">
<em class="property">class </em><code class="descclassname">dlib.</code><code class="descname">mmod_rectangles</code><a class="headerlink" href="#dlib.mmod_rectangles" title="Permalink to this definition">¶</a></dt>
<dd><p>An array of mmod rectangle objects.</p>
<dl class="method">
<dt id="dlib.mmod_rectangles.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.mmod_rectangles.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: dlib.mmod_rectangles) -&gt; None</li>
<li>__init__(self: dlib.mmod_rectangles, arg0: dlib.mmod_rectangles) -&gt; None</li>
</ol>
<p>Copy constructor</p>
<ol class="arabic simple" start="3">
<li>__init__(self: dlib.mmod_rectangles, arg0: iterable) -&gt; None</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="dlib.mmod_rectangles.append">
<code class="descname">append</code><span class="sig-paren">(</span><em>self: dlib.mmod_rectangles</em>, <em>x: dlib.mmod_rectangle</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.mmod_rectangles.append" title="Permalink to this definition">¶</a></dt>
<dd><p>Add an item to the end of the list</p>
</dd></dl>

<dl class="method">
<dt id="dlib.mmod_rectangles.count">
<code class="descname">count</code><span class="sig-paren">(</span><em>self: dlib.mmod_rectangles</em>, <em>x: dlib.mmod_rectangle</em><span class="sig-paren">)</span> &rarr; int<a class="headerlink" href="#dlib.mmod_rectangles.count" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of times <code class="docutils literal"><span class="pre">x</span></code> appears in the list</p>
</dd></dl>

<dl class="method">
<dt id="dlib.mmod_rectangles.extend">
<code class="descname">extend</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.mmod_rectangles.extend" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>extend(self: dlib.mmod_rectangles, L: dlib.mmod_rectangles) -&gt; None</li>
</ol>
<p>Extend the list by appending all the items in the given list</p>
<ol class="arabic simple" start="2">
<li>extend(self: dlib.mmod_rectangles, arg0: list) -&gt; None</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="dlib.mmod_rectangles.insert">
<code class="descname">insert</code><span class="sig-paren">(</span><em>self: dlib.mmod_rectangles</em>, <em>i: int</em>, <em>x: dlib.mmod_rectangle</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.mmod_rectangles.insert" title="Permalink to this definition">¶</a></dt>
<dd><p>Insert an item at a given position.</p>
</dd></dl>

<dl class="method">
<dt id="dlib.mmod_rectangles.pop">
<code class="descname">pop</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.mmod_rectangles.pop" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>pop(self: dlib.mmod_rectangles) -&gt; dlib.mmod_rectangle</li>
</ol>
<p>Remove and return the last item</p>
<ol class="arabic simple" start="2">
<li>pop(self: dlib.mmod_rectangles, i: int) -&gt; dlib.mmod_rectangle</li>
</ol>
<p>Remove and return the item at index <code class="docutils literal"><span class="pre">i</span></code></p>
</dd></dl>

<dl class="method">
<dt id="dlib.mmod_rectangles.remove">
<code class="descname">remove</code><span class="sig-paren">(</span><em>self: dlib.mmod_rectangles</em>, <em>x: dlib.mmod_rectangle</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.mmod_rectangles.remove" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove the first item from the list whose value is x. It is an error if there is no such item.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="dlib.mmod_rectangless">
<em class="property">class </em><code class="descclassname">dlib.</code><code class="descname">mmod_rectangless</code><a class="headerlink" href="#dlib.mmod_rectangless" title="Permalink to this definition">¶</a></dt>
<dd><p>A 2D array of mmod rectangle objects.</p>
<dl class="method">
<dt id="dlib.mmod_rectangless.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.mmod_rectangless.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: dlib.mmod_rectangless) -&gt; None</li>
<li>__init__(self: dlib.mmod_rectangless, arg0: dlib.mmod_rectangless) -&gt; None</li>
</ol>
<p>Copy constructor</p>
<ol class="arabic simple" start="3">
<li>__init__(self: dlib.mmod_rectangless, arg0: iterable) -&gt; None</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="dlib.mmod_rectangless.append">
<code class="descname">append</code><span class="sig-paren">(</span><em>self: dlib.mmod_rectangless</em>, <em>x: dlib.mmod_rectangles</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.mmod_rectangless.append" title="Permalink to this definition">¶</a></dt>
<dd><p>Add an item to the end of the list</p>
</dd></dl>

<dl class="method">
<dt id="dlib.mmod_rectangless.count">
<code class="descname">count</code><span class="sig-paren">(</span><em>self: dlib.mmod_rectangless</em>, <em>x: dlib.mmod_rectangles</em><span class="sig-paren">)</span> &rarr; int<a class="headerlink" href="#dlib.mmod_rectangless.count" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of times <code class="docutils literal"><span class="pre">x</span></code> appears in the list</p>
</dd></dl>

<dl class="method">
<dt id="dlib.mmod_rectangless.extend">
<code class="descname">extend</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.mmod_rectangless.extend" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>extend(self: dlib.mmod_rectangless, L: dlib.mmod_rectangless) -&gt; None</li>
</ol>
<p>Extend the list by appending all the items in the given list</p>
<ol class="arabic simple" start="2">
<li>extend(self: dlib.mmod_rectangless, arg0: list) -&gt; None</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="dlib.mmod_rectangless.insert">
<code class="descname">insert</code><span class="sig-paren">(</span><em>self: dlib.mmod_rectangless</em>, <em>i: int</em>, <em>x: dlib.mmod_rectangles</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.mmod_rectangless.insert" title="Permalink to this definition">¶</a></dt>
<dd><p>Insert an item at a given position.</p>
</dd></dl>

<dl class="method">
<dt id="dlib.mmod_rectangless.pop">
<code class="descname">pop</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.mmod_rectangless.pop" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>pop(self: dlib.mmod_rectangless) -&gt; dlib.mmod_rectangles</li>
</ol>
<p>Remove and return the last item</p>
<ol class="arabic simple" start="2">
<li>pop(self: dlib.mmod_rectangless, i: int) -&gt; dlib.mmod_rectangles</li>
</ol>
<p>Remove and return the item at index <code class="docutils literal"><span class="pre">i</span></code></p>
</dd></dl>

<dl class="method">
<dt id="dlib.mmod_rectangless.remove">
<code class="descname">remove</code><span class="sig-paren">(</span><em>self: dlib.mmod_rectangless</em>, <em>x: dlib.mmod_rectangles</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.mmod_rectangless.remove" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove the first item from the list whose value is x. It is an error if there is no such item.</p>
</dd></dl>

</dd></dl>

<dl class="exception">
<dt id="dlib.no_convex_quadrilateral">
<em class="property">exception </em><code class="descclassname">dlib.</code><code class="descname">no_convex_quadrilateral</code><a class="headerlink" href="#dlib.no_convex_quadrilateral" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="dlib.normalize_image_gradients">
<code class="descclassname">dlib.</code><code class="descname">normalize_image_gradients</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.normalize_image_gradients" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>normalize_image_gradients(img1: numpy.ndarray[(rows,cols),float64], img2: numpy.ndarray[(rows,cols),float64]) -&gt; None</li>
<li>normalize_image_gradients(img1: numpy.ndarray[(rows,cols),float32], img2: numpy.ndarray[(rows,cols),float32]) -&gt; None</li>
</ol>
<dl class="docutils">
<dt>requires </dt>
<dd><ul class="first last simple">
<li>img1 and img2 have the same dimensions.</li>
</ul>
</dd>
<dt>ensures </dt>
<dd><ul class="first last">
<li><p class="first">This function assumes img1 and img2 are the two gradient images produced by a 
function like sobel_edge_detector().  It then unit normalizes the gradient 
vectors. That is, for all valid r and c, this function ensures that:</p>
<blockquote>
<div><ul class="simple">
<li>img1[r][c]*img1[r][c] + img2[r][c]*img2[r][c] == 1  
unless both img1[r][c] and img2[r][c] were 0 initially, then they stay zero.</li>
</ul>
</div></blockquote>
</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="dlib.num_separable_filters">
<code class="descclassname">dlib.</code><code class="descname">num_separable_filters</code><span class="sig-paren">(</span><em>detector: dlib.simple_object_detector</em><span class="sig-paren">)</span> &rarr; int<a class="headerlink" href="#dlib.num_separable_filters" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of separable filters necessary to represent the HOG filters in the given detector.</p>
</dd></dl>

<dl class="class">
<dt id="dlib.pair">
<em class="property">class </em><code class="descclassname">dlib.</code><code class="descname">pair</code><a class="headerlink" href="#dlib.pair" title="Permalink to this definition">¶</a></dt>
<dd><p>This object is used to represent the elements of a sparse_vector.</p>
<dl class="method">
<dt id="dlib.pair.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: dlib.pair</em>, <em>arg0: int</em>, <em>arg1: float</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.pair.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.pair.first">
<code class="descname">first</code><a class="headerlink" href="#dlib.pair.first" title="Permalink to this definition">¶</a></dt>
<dd><p>This field represents the index/dimension number.</p>
</dd></dl>

<dl class="attribute">
<dt id="dlib.pair.second">
<code class="descname">second</code><a class="headerlink" href="#dlib.pair.second" title="Permalink to this definition">¶</a></dt>
<dd><p>This field contains the value in a vector at dimension specified by the first field.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="dlib.partition_pixels">
<code class="descclassname">dlib.</code><code class="descname">partition_pixels</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.partition_pixels" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>partition_pixels(img: numpy.ndarray[(rows,cols,3),uint8]) -&gt; int</li>
<li>partition_pixels(img: numpy.ndarray[(rows,cols),uint8]) -&gt; int</li>
<li>partition_pixels(img: numpy.ndarray[(rows,cols),uint16]) -&gt; int</li>
<li>partition_pixels(img: numpy.ndarray[(rows,cols),uint32]) -&gt; int</li>
<li>partition_pixels(img: numpy.ndarray[(rows,cols),float32]) -&gt; float</li>
<li>partition_pixels(img: numpy.ndarray[(rows,cols),float64]) -&gt; float</li>
</ol>
<p>Finds a threshold value that would be reasonable to use with 
threshold_image(img, threshold).  It does this by finding the threshold that 
partitions the pixels in img into two groups such that the sum of absolute 
deviations between each pixel and the mean of its group is minimized.</p>
<ol class="arabic simple" start="7">
<li>partition_pixels(img: numpy.ndarray[(rows,cols,3),uint8], num_thresholds: int) -&gt; tuple</li>
<li>partition_pixels(img: numpy.ndarray[(rows,cols),uint8], num_thresholds: int) -&gt; tuple</li>
<li>partition_pixels(img: numpy.ndarray[(rows,cols),uint16], num_thresholds: int) -&gt; tuple</li>
<li>partition_pixels(img: numpy.ndarray[(rows,cols),uint32], num_thresholds: int) -&gt; tuple</li>
<li>partition_pixels(img: numpy.ndarray[(rows,cols),float32], num_thresholds: int) -&gt; tuple</li>
<li>partition_pixels(img: numpy.ndarray[(rows,cols),float64], num_thresholds: int) -&gt; tuple</li>
</ol>
<p>This version of partition_pixels() finds multiple partitions rather than just 
one partition.  It does this by first partitioning the pixels just as the 
above partition_pixels(img) does.  Then it forms a new image with only pixels 
&gt;= that first partition value and recursively partitions this new image. 
However, the recursion is implemented in an efficient way which is faster than 
explicitly forming these images and calling partition_pixels(), but the 
output is the same as if you did.  For example, suppose you called 
[t1,t2,t2] = partition_pixels(img,3).  Then we would have:</p>
<blockquote>
<div><ul class="simple">
<li>t1 == partition_pixels(img)</li>
<li>t2 == partition_pixels(an image with only pixels with values &gt;= t1 in it)</li>
<li>t3 == partition_pixels(an image with only pixels with values &gt;= t2 in it)</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="class">
<dt id="dlib.point">
<em class="property">class </em><code class="descclassname">dlib.</code><code class="descname">point</code><a class="headerlink" href="#dlib.point" title="Permalink to this definition">¶</a></dt>
<dd><p>This object represents a single point of integer coordinates that maps directly to a dlib::point.</p>
<dl class="method">
<dt id="dlib.point.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.point.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: dlib.point, x: int, y: int) -&gt; None</li>
<li>__init__(self: dlib.point, p: dlib::vector&lt;double, 2l&gt;) -&gt; None</li>
<li>__init__(self: dlib.point, v: numpy.ndarray[int64]) -&gt; None</li>
<li>__init__(self: dlib.point, v: numpy.ndarray[float32]) -&gt; None</li>
<li>__init__(self: dlib.point, v: numpy.ndarray[float64]) -&gt; None</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="dlib.point.normalize">
<code class="descname">normalize</code><span class="sig-paren">(</span><em>self: dlib.point</em><span class="sig-paren">)</span> &rarr; dlib::vector&lt;double, 2l&gt;<a class="headerlink" href="#dlib.point.normalize" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a unit normalized copy of this vector.</p>
</dd></dl>

<dl class="attribute">
<dt id="dlib.point.x">
<code class="descname">x</code><a class="headerlink" href="#dlib.point.x" title="Permalink to this definition">¶</a></dt>
<dd><p>The x-coordinate of the point.</p>
</dd></dl>

<dl class="attribute">
<dt id="dlib.point.y">
<code class="descname">y</code><a class="headerlink" href="#dlib.point.y" title="Permalink to this definition">¶</a></dt>
<dd><p>The y-coordinate of the point.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="dlib.point_transform_projective">
<em class="property">class </em><code class="descclassname">dlib.</code><code class="descname">point_transform_projective</code><a class="headerlink" href="#dlib.point_transform_projective" title="Permalink to this definition">¶</a></dt>
<dd><p>This is an object that takes 2D points and applies a projective transformation to them.</p>
<dl class="method">
<dt id="dlib.point_transform_projective.__call__">
<code class="descname">__call__</code><span class="sig-paren">(</span><em>self: dlib.point_transform_projective</em>, <em>p: dlib.dpoint</em><span class="sig-paren">)</span> &rarr; dlib.dpoint<a class="headerlink" href="#dlib.point_transform_projective.__call__" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>ensures </dt>
<dd><ul class="first last">
<li><p class="first">Applies the projective transformation defined by this object&#8217;s constructor 
to p and returns the result.  To define this precisely:</p>
<blockquote>
<div><ul>
<li><dl class="first docutils">
<dt>let p_h == the point p in homogeneous coordinates.  That is: </dt>
<dd><ul class="first last simple">
<li>p_h.x == p.x</li>
<li>p_h.y == p.y</li>
<li>p_h.z == 1</li>
</ul>
</dd>
</dl>
</li>
<li><p class="first">let x == m*p_h</p>
</li>
<li><p class="first">Then this function returns the value x/x.z</p>
</li>
</ul>
</div></blockquote>
</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dlib.point_transform_projective.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.point_transform_projective.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: dlib.point_transform_projective) -&gt; None</li>
</ol>
<dl class="docutils">
<dt>ensures </dt>
<dd><ul class="first last simple">
<li>This object will perform the identity transform.  That is, given a point 
as input it will return the same point as output.  Therefore, self.m == a 3x3 identity matrix.</li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li>__init__(self: dlib.point_transform_projective, m: numpy.ndarray[(rows,cols),float64]) -&gt; None</li>
</ol>
<dl class="docutils">
<dt>ensures </dt>
<dd><ul class="first last simple">
<li>self.m == m</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="dlib.point_transform_projective.m">
<code class="descname">m</code><a class="headerlink" href="#dlib.point_transform_projective.m" title="Permalink to this definition">¶</a></dt>
<dd><p>m is the 3x3 matrix that defines the projective transformation.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="dlib.points">
<em class="property">class </em><code class="descclassname">dlib.</code><code class="descname">points</code><a class="headerlink" href="#dlib.points" title="Permalink to this definition">¶</a></dt>
<dd><p>An array of point objects.</p>
<dl class="method">
<dt id="dlib.points.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.points.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: dlib.points) -&gt; None</li>
<li>__init__(self: dlib.points, arg0: dlib.points) -&gt; None</li>
</ol>
<p>Copy constructor</p>
<ol class="arabic simple" start="3">
<li>__init__(self: dlib.points, arg0: iterable) -&gt; None</li>
<li>__init__(self: dlib.points, initial_size: int) -&gt; None</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="dlib.points.append">
<code class="descname">append</code><span class="sig-paren">(</span><em>self: dlib.points</em>, <em>x: dlib.point</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.points.append" title="Permalink to this definition">¶</a></dt>
<dd><p>Add an item to the end of the list</p>
</dd></dl>

<dl class="method">
<dt id="dlib.points.clear">
<code class="descname">clear</code><span class="sig-paren">(</span><em>self: dlib.points</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.points.clear" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dlib.points.count">
<code class="descname">count</code><span class="sig-paren">(</span><em>self: dlib.points</em>, <em>x: dlib.point</em><span class="sig-paren">)</span> &rarr; int<a class="headerlink" href="#dlib.points.count" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of times <code class="docutils literal"><span class="pre">x</span></code> appears in the list</p>
</dd></dl>

<dl class="method">
<dt id="dlib.points.extend">
<code class="descname">extend</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.points.extend" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>extend(self: dlib.points, L: dlib.points) -&gt; None</li>
</ol>
<p>Extend the list by appending all the items in the given list</p>
<ol class="arabic simple" start="2">
<li>extend(self: dlib.points, arg0: list) -&gt; None</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="dlib.points.insert">
<code class="descname">insert</code><span class="sig-paren">(</span><em>self: dlib.points</em>, <em>i: int</em>, <em>x: dlib.point</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.points.insert" title="Permalink to this definition">¶</a></dt>
<dd><p>Insert an item at a given position.</p>
</dd></dl>

<dl class="method">
<dt id="dlib.points.pop">
<code class="descname">pop</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.points.pop" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>pop(self: dlib.points) -&gt; dlib.point</li>
</ol>
<p>Remove and return the last item</p>
<ol class="arabic simple" start="2">
<li>pop(self: dlib.points, i: int) -&gt; dlib.point</li>
</ol>
<p>Remove and return the item at index <code class="docutils literal"><span class="pre">i</span></code></p>
</dd></dl>

<dl class="method">
<dt id="dlib.points.remove">
<code class="descname">remove</code><span class="sig-paren">(</span><em>self: dlib.points</em>, <em>x: dlib.point</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.points.remove" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove the first item from the list whose value is x. It is an error if there is no such item.</p>
</dd></dl>

<dl class="method">
<dt id="dlib.points.resize">
<code class="descname">resize</code><span class="sig-paren">(</span><em>self: dlib.points</em>, <em>arg0: int</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.points.resize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="dlib.polygon_area">
<code class="descclassname">dlib.</code><code class="descname">polygon_area</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.polygon_area" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>polygon_area(pts: dlib.dpoints) -&gt; float</li>
<li>polygon_area(pts: list) -&gt; float</li>
</ol>
<dl class="docutils">
<dt>ensures </dt>
<dd><ul class="first last simple">
<li>If you walk the points pts in order to make a closed polygon, what is its 
area?  This function returns that area.  It uses the shoelace formula to 
compute the result and so works for general non-self-intersecting polygons.</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="dlib.probability_that_sequence_is_increasing">
<code class="descclassname">dlib.</code><code class="descname">probability_that_sequence_is_increasing</code><span class="sig-paren">(</span><em>time_series: object</em><span class="sig-paren">)</span> &rarr; float<a class="headerlink" href="#dlib.probability_that_sequence_is_increasing" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the probability that the given sequence of real numbers is increasing in value over time.</p>
</dd></dl>

<dl class="class">
<dt id="dlib.pyramid_down">
<em class="property">class </em><code class="descclassname">dlib.</code><code class="descname">pyramid_down</code><a class="headerlink" href="#dlib.pyramid_down" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a simple object to help create image pyramids.  In particular, it 
downsamples images at a ratio of N to N-1.</p>
<p>Note that setting N to 1 means that this object functions like 
pyramid_disable (defined at the bottom of this file).</p>
<p>WARNING, when mapping rectangles from one layer of a pyramid 
to another you might end up with rectangles which extend slightly  
outside your images.  This is because points on the border of an  
image at a higher pyramid layer might correspond to points outside  
images at lower layers.  So just keep this in mind.  Note also 
that it&#8217;s easy to deal with.  Just say something like this:</p>
<blockquote>
<div>rect = rect.intersect(get_rect(my_image)); # keep rect inside my_image</div></blockquote>
<dl class="method">
<dt id="dlib.pyramid_down.__call__">
<code class="descname">__call__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.pyramid_down.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__call__(self: dlib.pyramid_down, img: numpy.ndarray[(rows,cols),uint8]) -&gt; numpy.ndarray[(rows,cols),uint8]</li>
<li>__call__(self: dlib.pyramid_down, img: numpy.ndarray[(rows,cols),uint16]) -&gt; numpy.ndarray[(rows,cols),uint16]</li>
<li>__call__(self: dlib.pyramid_down, img: numpy.ndarray[(rows,cols),uint32]) -&gt; numpy.ndarray[(rows,cols),uint32]</li>
<li>__call__(self: dlib.pyramid_down, img: numpy.ndarray[(rows,cols),uint64]) -&gt; numpy.ndarray[(rows,cols),uint64]</li>
<li>__call__(self: dlib.pyramid_down, img: numpy.ndarray[(rows,cols),int8]) -&gt; numpy.ndarray[(rows,cols),int8]</li>
<li>__call__(self: dlib.pyramid_down, img: numpy.ndarray[(rows,cols),int16]) -&gt; numpy.ndarray[(rows,cols),int16]</li>
<li>__call__(self: dlib.pyramid_down, img: numpy.ndarray[(rows,cols),int32]) -&gt; numpy.ndarray[(rows,cols),int32]</li>
<li>__call__(self: dlib.pyramid_down, img: numpy.ndarray[(rows,cols),int64]) -&gt; numpy.ndarray[(rows,cols),int64]</li>
<li>__call__(self: dlib.pyramid_down, img: numpy.ndarray[(rows,cols),float32]) -&gt; numpy.ndarray[(rows,cols),float32]</li>
<li>__call__(self: dlib.pyramid_down, img: numpy.ndarray[(rows,cols),float64]) -&gt; numpy.ndarray[(rows,cols),float64]</li>
<li>__call__(self: dlib.pyramid_down, img: numpy.ndarray[(rows,cols,3),uint8]) -&gt; numpy.ndarray[(rows,cols,3),uint8]</li>
</ol>
<ul class="simple">
<li>Downsamples img to make a new image that is roughly (pyramid_downsampling_rate()-1)/pyramid_downsampling_rate()  
times the size of the original image.</li>
<li>The location of a point P in original image will show up at point point_down(P) 
in the downsampled image.</li>
<li>Note that some points on the border of the original image might correspond to  
points outside the downsampled image.</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="dlib.pyramid_down.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.pyramid_down.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: dlib.pyramid_down, N: int) -&gt; None</li>
</ol>
<p>Creates this class with the provided downsampling rate. i.e. pyramid_downsampling_rate()==N. 
N must be in the range 1 to 20.</p>
<ol class="arabic simple" start="2">
<li>__init__(self: dlib.pyramid_down) -&gt; None</li>
</ol>
<p>Creates this class with pyramid_downsampling_rate()==2</p>
</dd></dl>

<dl class="method">
<dt id="dlib.pyramid_down.point_down">
<code class="descname">point_down</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.pyramid_down.point_down" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>point_down(self: dlib.pyramid_down, p: dlib.point) -&gt; dlib.dpoint</li>
<li>point_down(self: dlib.pyramid_down, p: dlib.dpoint) -&gt; dlib.dpoint</li>
</ol>
<p>Maps from pixels in a source image to the corresponding pixels in the downsampled image.</p>
<ol class="arabic simple" start="3">
<li>point_down(self: dlib.pyramid_down, p: dlib.point, levels: int) -&gt; dlib.dpoint</li>
<li>point_down(self: dlib.pyramid_down, p: dlib.dpoint, levels: int) -&gt; dlib.dpoint</li>
</ol>
<p>Applies point_down() to p levels times and returns the result.</p>
</dd></dl>

<dl class="method">
<dt id="dlib.pyramid_down.point_up">
<code class="descname">point_up</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.pyramid_down.point_up" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>point_up(self: dlib.pyramid_down, p: dlib.point) -&gt; dlib.dpoint</li>
<li>point_up(self: dlib.pyramid_down, p: dlib.dpoint) -&gt; dlib.dpoint</li>
</ol>
<p>Maps from pixels in a downsampled image to pixels in the original image.</p>
<ol class="arabic simple" start="3">
<li>point_up(self: dlib.pyramid_down, p: dlib.point, levels: int) -&gt; dlib.dpoint</li>
<li>point_up(self: dlib.pyramid_down, p: dlib.dpoint, levels: int) -&gt; dlib.dpoint</li>
</ol>
<p>Applies point_up() to p levels times and returns the result.</p>
</dd></dl>

<dl class="method">
<dt id="dlib.pyramid_down.pyramid_downsampling_rate">
<code class="descname">pyramid_downsampling_rate</code><span class="sig-paren">(</span><em>self: dlib.pyramid_down</em><span class="sig-paren">)</span> &rarr; int<a class="headerlink" href="#dlib.pyramid_down.pyramid_downsampling_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a number N that defines the downsampling rate.  In particular, images are downsampled by a factor of N to N-1.</p>
</dd></dl>

<dl class="method">
<dt id="dlib.pyramid_down.rect_down">
<code class="descname">rect_down</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.pyramid_down.rect_down" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>rect_down(self: dlib.pyramid_down, rect: dlib.rectangle) -&gt; dlib.rectangle</li>
<li>rect_down(self: dlib.pyramid_down, rect: dlib.drectangle) -&gt; dlib.drectangle</li>
</ol>
<dl class="docutils">
<dt>returns drectangle(point_down(rect.tl_corner()), point_down(rect.br_corner()));</dt>
<dd>(i.e. maps rect into a downsampled)</dd>
</dl>
<ol class="arabic simple" start="3">
<li>rect_down(self: dlib.pyramid_down, rect: dlib.rectangle, levels: int) -&gt; dlib.rectangle</li>
<li>rect_down(self: dlib.pyramid_down, rect: dlib.drectangle, levels: int) -&gt; dlib.drectangle</li>
</ol>
<p>Applies rect_down() to rect levels times and returns the result.</p>
</dd></dl>

<dl class="method">
<dt id="dlib.pyramid_down.rect_up">
<code class="descname">rect_up</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.pyramid_down.rect_up" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>rect_up(self: dlib.pyramid_down, rect: dlib.rectangle) -&gt; dlib.rectangle</li>
<li>rect_up(self: dlib.pyramid_down, rect: dlib.drectangle) -&gt; dlib.drectangle</li>
</ol>
<dl class="docutils">
<dt>returns drectangle(point_up(rect.tl_corner()), point_up(rect.br_corner()));</dt>
<dd>(i.e. maps rect into a parent image)</dd>
</dl>
<ol class="arabic simple" start="3">
<li>rect_up(self: dlib.pyramid_down, rect: dlib.rectangle, levels: int) -&gt; dlib.rectangle</li>
<li>rect_up(self: dlib.pyramid_down, p: dlib.drectangle, levels: int) -&gt; dlib.drectangle</li>
</ol>
<p>Applies rect_up() to rect levels times and returns the result.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="dlib.randomly_color_image">
<code class="descclassname">dlib.</code><code class="descname">randomly_color_image</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.randomly_color_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>randomly_color_image(img: numpy.ndarray[(rows,cols),uint8]) -&gt; numpy.ndarray[(rows,cols,3),uint8]</li>
<li>randomly_color_image(img: numpy.ndarray[(rows,cols),uint16]) -&gt; numpy.ndarray[(rows,cols,3),uint8]</li>
<li>randomly_color_image(img: numpy.ndarray[(rows,cols),uint32]) -&gt; numpy.ndarray[(rows,cols,3),uint8]</li>
</ol>
<ul class="simple">
<li>randomly generates a mapping from gray level pixel values 
to the RGB pixel space and then uses this mapping to create 
a colored version of img.  Returns an image which represents 
this colored version of img.</li>
<li>black pixels in img will remain black in the output image.</li>
</ul>
</dd></dl>

<dl class="class">
<dt id="dlib.range">
<em class="property">class </em><code class="descclassname">dlib.</code><code class="descname">range</code><a class="headerlink" href="#dlib.range" title="Permalink to this definition">¶</a></dt>
<dd><p>This object is used to represent a range of elements in an array.</p>
<dl class="method">
<dt id="dlib.range.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.range.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: dlib.range, arg0: int, arg1: int) -&gt; None</li>
<li>__init__(self: dlib.range, arg0: int) -&gt; None</li>
</ol>
</dd></dl>

<dl class="attribute">
<dt id="dlib.range.begin">
<code class="descname">begin</code><a class="headerlink" href="#dlib.range.begin" title="Permalink to this definition">¶</a></dt>
<dd><p>The index of the first element in the range.  This is represented using an unsigned integer.</p>
</dd></dl>

<dl class="attribute">
<dt id="dlib.range.end">
<code class="descname">end</code><a class="headerlink" href="#dlib.range.end" title="Permalink to this definition">¶</a></dt>
<dd><p>One past the index of the last element in the range.  This is represented using an unsigned integer.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="dlib.ranges">
<em class="property">class </em><code class="descclassname">dlib.</code><code class="descname">ranges</code><a class="headerlink" href="#dlib.ranges" title="Permalink to this definition">¶</a></dt>
<dd><p>This object is an array of range objects.</p>
<dl class="method">
<dt id="dlib.ranges.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.ranges.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: dlib.ranges) -&gt; None</li>
<li>__init__(self: dlib.ranges, arg0: dlib.ranges) -&gt; None</li>
</ol>
<p>Copy constructor</p>
<ol class="arabic simple" start="3">
<li>__init__(self: dlib.ranges, arg0: iterable) -&gt; None</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="dlib.ranges.append">
<code class="descname">append</code><span class="sig-paren">(</span><em>self: dlib.ranges</em>, <em>x: dlib.range</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.ranges.append" title="Permalink to this definition">¶</a></dt>
<dd><p>Add an item to the end of the list</p>
</dd></dl>

<dl class="method">
<dt id="dlib.ranges.clear">
<code class="descname">clear</code><span class="sig-paren">(</span><em>self: dlib.ranges</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.ranges.clear" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dlib.ranges.count">
<code class="descname">count</code><span class="sig-paren">(</span><em>self: dlib.ranges</em>, <em>x: dlib.range</em><span class="sig-paren">)</span> &rarr; int<a class="headerlink" href="#dlib.ranges.count" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of times <code class="docutils literal"><span class="pre">x</span></code> appears in the list</p>
</dd></dl>

<dl class="method">
<dt id="dlib.ranges.extend">
<code class="descname">extend</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.ranges.extend" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>extend(self: dlib.ranges, L: dlib.ranges) -&gt; None</li>
</ol>
<p>Extend the list by appending all the items in the given list</p>
<ol class="arabic simple" start="2">
<li>extend(self: dlib.ranges, arg0: list) -&gt; None</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="dlib.ranges.insert">
<code class="descname">insert</code><span class="sig-paren">(</span><em>self: dlib.ranges</em>, <em>i: int</em>, <em>x: dlib.range</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.ranges.insert" title="Permalink to this definition">¶</a></dt>
<dd><p>Insert an item at a given position.</p>
</dd></dl>

<dl class="method">
<dt id="dlib.ranges.pop">
<code class="descname">pop</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.ranges.pop" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>pop(self: dlib.ranges) -&gt; dlib.range</li>
</ol>
<p>Remove and return the last item</p>
<ol class="arabic simple" start="2">
<li>pop(self: dlib.ranges, i: int) -&gt; dlib.range</li>
</ol>
<p>Remove and return the item at index <code class="docutils literal"><span class="pre">i</span></code></p>
</dd></dl>

<dl class="method">
<dt id="dlib.ranges.remove">
<code class="descname">remove</code><span class="sig-paren">(</span><em>self: dlib.ranges</em>, <em>x: dlib.range</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.ranges.remove" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove the first item from the list whose value is x. It is an error if there is no such item.</p>
</dd></dl>

<dl class="method">
<dt id="dlib.ranges.resize">
<code class="descname">resize</code><span class="sig-paren">(</span><em>self: dlib.ranges</em>, <em>arg0: int</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.ranges.resize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="dlib.rangess">
<em class="property">class </em><code class="descclassname">dlib.</code><code class="descname">rangess</code><a class="headerlink" href="#dlib.rangess" title="Permalink to this definition">¶</a></dt>
<dd><p>This object is an array of arrays of range objects.</p>
<dl class="method">
<dt id="dlib.rangess.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.rangess.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: dlib.rangess) -&gt; None</li>
<li>__init__(self: dlib.rangess, arg0: dlib.rangess) -&gt; None</li>
</ol>
<p>Copy constructor</p>
<ol class="arabic simple" start="3">
<li>__init__(self: dlib.rangess, arg0: iterable) -&gt; None</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="dlib.rangess.append">
<code class="descname">append</code><span class="sig-paren">(</span><em>self: dlib.rangess</em>, <em>x: dlib.ranges</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.rangess.append" title="Permalink to this definition">¶</a></dt>
<dd><p>Add an item to the end of the list</p>
</dd></dl>

<dl class="method">
<dt id="dlib.rangess.clear">
<code class="descname">clear</code><span class="sig-paren">(</span><em>self: dlib.rangess</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.rangess.clear" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dlib.rangess.count">
<code class="descname">count</code><span class="sig-paren">(</span><em>self: dlib.rangess</em>, <em>x: dlib.ranges</em><span class="sig-paren">)</span> &rarr; int<a class="headerlink" href="#dlib.rangess.count" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of times <code class="docutils literal"><span class="pre">x</span></code> appears in the list</p>
</dd></dl>

<dl class="method">
<dt id="dlib.rangess.extend">
<code class="descname">extend</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.rangess.extend" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>extend(self: dlib.rangess, L: dlib.rangess) -&gt; None</li>
</ol>
<p>Extend the list by appending all the items in the given list</p>
<ol class="arabic simple" start="2">
<li>extend(self: dlib.rangess, arg0: list) -&gt; None</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="dlib.rangess.insert">
<code class="descname">insert</code><span class="sig-paren">(</span><em>self: dlib.rangess</em>, <em>i: int</em>, <em>x: dlib.ranges</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.rangess.insert" title="Permalink to this definition">¶</a></dt>
<dd><p>Insert an item at a given position.</p>
</dd></dl>

<dl class="method">
<dt id="dlib.rangess.pop">
<code class="descname">pop</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.rangess.pop" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>pop(self: dlib.rangess) -&gt; dlib.ranges</li>
</ol>
<p>Remove and return the last item</p>
<ol class="arabic simple" start="2">
<li>pop(self: dlib.rangess, i: int) -&gt; dlib.ranges</li>
</ol>
<p>Remove and return the item at index <code class="docutils literal"><span class="pre">i</span></code></p>
</dd></dl>

<dl class="method">
<dt id="dlib.rangess.remove">
<code class="descname">remove</code><span class="sig-paren">(</span><em>self: dlib.rangess</em>, <em>x: dlib.ranges</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.rangess.remove" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove the first item from the list whose value is x. It is an error if there is no such item.</p>
</dd></dl>

<dl class="method">
<dt id="dlib.rangess.resize">
<code class="descname">resize</code><span class="sig-paren">(</span><em>self: dlib.rangess</em>, <em>arg0: int</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.rangess.resize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="dlib.ranking_pair">
<em class="property">class </em><code class="descclassname">dlib.</code><code class="descname">ranking_pair</code><a class="headerlink" href="#dlib.ranking_pair" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="dlib.ranking_pair.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: dlib.ranking_pair</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.ranking_pair.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.ranking_pair.nonrelevant">
<code class="descname">nonrelevant</code><a class="headerlink" href="#dlib.ranking_pair.nonrelevant" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.ranking_pair.relevant">
<code class="descname">relevant</code><a class="headerlink" href="#dlib.ranking_pair.relevant" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="dlib.ranking_pairs">
<em class="property">class </em><code class="descclassname">dlib.</code><code class="descname">ranking_pairs</code><a class="headerlink" href="#dlib.ranking_pairs" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="dlib.ranking_pairs.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.ranking_pairs.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: dlib.ranking_pairs) -&gt; None</li>
<li>__init__(self: dlib.ranking_pairs, arg0: dlib.ranking_pairs) -&gt; None</li>
</ol>
<p>Copy constructor</p>
<ol class="arabic simple" start="3">
<li>__init__(self: dlib.ranking_pairs, arg0: iterable) -&gt; None</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="dlib.ranking_pairs.append">
<code class="descname">append</code><span class="sig-paren">(</span><em>self: dlib.ranking_pairs</em>, <em>x: dlib.ranking_pair</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.ranking_pairs.append" title="Permalink to this definition">¶</a></dt>
<dd><p>Add an item to the end of the list</p>
</dd></dl>

<dl class="method">
<dt id="dlib.ranking_pairs.clear">
<code class="descname">clear</code><span class="sig-paren">(</span><em>self: dlib.ranking_pairs</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.ranking_pairs.clear" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dlib.ranking_pairs.count">
<code class="descname">count</code><span class="sig-paren">(</span><em>self: dlib.ranking_pairs</em>, <em>x: dlib.ranking_pair</em><span class="sig-paren">)</span> &rarr; int<a class="headerlink" href="#dlib.ranking_pairs.count" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of times <code class="docutils literal"><span class="pre">x</span></code> appears in the list</p>
</dd></dl>

<dl class="method">
<dt id="dlib.ranking_pairs.extend">
<code class="descname">extend</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.ranking_pairs.extend" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>extend(self: dlib.ranking_pairs, L: dlib.ranking_pairs) -&gt; None</li>
</ol>
<p>Extend the list by appending all the items in the given list</p>
<ol class="arabic simple" start="2">
<li>extend(self: dlib.ranking_pairs, arg0: list) -&gt; None</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="dlib.ranking_pairs.insert">
<code class="descname">insert</code><span class="sig-paren">(</span><em>self: dlib.ranking_pairs</em>, <em>i: int</em>, <em>x: dlib.ranking_pair</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.ranking_pairs.insert" title="Permalink to this definition">¶</a></dt>
<dd><p>Insert an item at a given position.</p>
</dd></dl>

<dl class="method">
<dt id="dlib.ranking_pairs.pop">
<code class="descname">pop</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.ranking_pairs.pop" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>pop(self: dlib.ranking_pairs) -&gt; dlib.ranking_pair</li>
</ol>
<p>Remove and return the last item</p>
<ol class="arabic simple" start="2">
<li>pop(self: dlib.ranking_pairs, i: int) -&gt; dlib.ranking_pair</li>
</ol>
<p>Remove and return the item at index <code class="docutils literal"><span class="pre">i</span></code></p>
</dd></dl>

<dl class="method">
<dt id="dlib.ranking_pairs.remove">
<code class="descname">remove</code><span class="sig-paren">(</span><em>self: dlib.ranking_pairs</em>, <em>x: dlib.ranking_pair</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.ranking_pairs.remove" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove the first item from the list whose value is x. It is an error if there is no such item.</p>
</dd></dl>

<dl class="method">
<dt id="dlib.ranking_pairs.resize">
<code class="descname">resize</code><span class="sig-paren">(</span><em>self: dlib.ranking_pairs</em>, <em>arg0: int</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.ranking_pairs.resize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="dlib.rect_filter">
<em class="property">class </em><code class="descclassname">dlib.</code><code class="descname">rect_filter</code><a class="headerlink" href="#dlib.rect_filter" title="Permalink to this definition">¶</a></dt>
<dd><p>This object is a simple tool for filtering a rectangle that
measures the location of a moving object that has some non-trivial
momentum.  Importantly, the measurements are noisy and the object can
experience sudden unpredictable accelerations.  To accomplish this
filtering we use a simple Kalman filter with a state transition model of:</p>
<blockquote>
<div>position_{i+1} = position_{i} + velocity_{i} 
velocity_{i+1} = velocity_{i} + some_unpredictable_acceleration</div></blockquote>
<p>and a measurement model of:</p>
<blockquote>
<div>measured_position_{i} = position_{i} + measurement_noise</div></blockquote>
<p>Where some_unpredictable_acceleration and measurement_noise are 0 mean Gaussian 
noise sources with standard deviations of typical_acceleration and
measurement_noise respectively.</p>
<p>To allow for really sudden and large but infrequent accelerations, at each
step we check if the current measured position deviates from the predicted
filtered position by more than max_measurement_deviation*measurement_noise 
and if so we adjust the filter&#8217;s state to keep it within these bounds.
This allows the moving object to undergo large unmodeled accelerations, far
in excess of what would be suggested by typical_acceleration, without
then experiencing a long lag time where the Kalman filter has to &#8220;catches
up&#8221; to the new position.</p>
<dl class="method">
<dt id="dlib.rect_filter.__call__">
<code class="descname">__call__</code><span class="sig-paren">(</span><em>self: dlib.rect_filter</em>, <em>rect: dlib.rectangle</em><span class="sig-paren">)</span> &rarr; dlib.rectangle<a class="headerlink" href="#dlib.rect_filter.__call__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dlib.rect_filter.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: dlib.rect_filter</em>, <em>measurement_noise: float</em>, <em>typical_acceleration: float</em>, <em>max_measurement_deviation: float</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.rect_filter.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dlib.rect_filter.max_measurement_deviation">
<code class="descname">max_measurement_deviation</code><span class="sig-paren">(</span><em>self: dlib.rect_filter</em><span class="sig-paren">)</span> &rarr; float<a class="headerlink" href="#dlib.rect_filter.max_measurement_deviation" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dlib.rect_filter.measurement_noise">
<code class="descname">measurement_noise</code><span class="sig-paren">(</span><em>self: dlib.rect_filter</em><span class="sig-paren">)</span> &rarr; float<a class="headerlink" href="#dlib.rect_filter.measurement_noise" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dlib.rect_filter.typical_acceleration">
<code class="descname">typical_acceleration</code><span class="sig-paren">(</span><em>self: dlib.rect_filter</em><span class="sig-paren">)</span> &rarr; float<a class="headerlink" href="#dlib.rect_filter.typical_acceleration" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="dlib.rectangle">
<em class="property">class </em><code class="descclassname">dlib.</code><code class="descname">rectangle</code><a class="headerlink" href="#dlib.rectangle" title="Permalink to this definition">¶</a></dt>
<dd><p>This object represents a rectangular area of an image.</p>
<dl class="method">
<dt id="dlib.rectangle.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.rectangle.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: dlib.rectangle, left: int, top: int, right: int, bottom: int) -&gt; None</li>
<li>__init__(self: dlib.rectangle, rect: dlib::drectangle) -&gt; None</li>
<li>__init__(self: dlib.rectangle, rect: dlib.rectangle) -&gt; None</li>
<li>__init__(self: dlib.rectangle) -&gt; None</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="dlib.rectangle.area">
<code class="descname">area</code><span class="sig-paren">(</span><em>self: dlib.rectangle</em><span class="sig-paren">)</span> &rarr; int<a class="headerlink" href="#dlib.rectangle.area" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dlib.rectangle.bl_corner">
<code class="descname">bl_corner</code><span class="sig-paren">(</span><em>self: dlib.rectangle</em><span class="sig-paren">)</span> &rarr; dlib.point<a class="headerlink" href="#dlib.rectangle.bl_corner" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the bottom left corner of the rectangle.</p>
</dd></dl>

<dl class="method">
<dt id="dlib.rectangle.bottom">
<code class="descname">bottom</code><span class="sig-paren">(</span><em>self: dlib.rectangle</em><span class="sig-paren">)</span> &rarr; int<a class="headerlink" href="#dlib.rectangle.bottom" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dlib.rectangle.br_corner">
<code class="descname">br_corner</code><span class="sig-paren">(</span><em>self: dlib.rectangle</em><span class="sig-paren">)</span> &rarr; dlib.point<a class="headerlink" href="#dlib.rectangle.br_corner" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the bottom right corner of the rectangle.</p>
</dd></dl>

<dl class="method">
<dt id="dlib.rectangle.center">
<code class="descname">center</code><span class="sig-paren">(</span><em>self: dlib.rectangle</em><span class="sig-paren">)</span> &rarr; dlib.point<a class="headerlink" href="#dlib.rectangle.center" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dlib.rectangle.contains">
<code class="descname">contains</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.rectangle.contains" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>contains(self: dlib.rectangle, point: dlib.point) -&gt; bool</li>
<li>contains(self: dlib.rectangle, point: dlib.dpoint) -&gt; bool</li>
<li>contains(self: dlib.rectangle, x: int, y: int) -&gt; bool</li>
<li>contains(self: dlib.rectangle, rectangle: dlib.rectangle) -&gt; bool</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="dlib.rectangle.dcenter">
<code class="descname">dcenter</code><span class="sig-paren">(</span><em>self: dlib.rectangle</em><span class="sig-paren">)</span> &rarr; dlib.point<a class="headerlink" href="#dlib.rectangle.dcenter" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dlib.rectangle.height">
<code class="descname">height</code><span class="sig-paren">(</span><em>self: dlib.rectangle</em><span class="sig-paren">)</span> &rarr; int<a class="headerlink" href="#dlib.rectangle.height" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dlib.rectangle.intersect">
<code class="descname">intersect</code><span class="sig-paren">(</span><em>self: dlib.rectangle</em>, <em>rectangle: dlib.rectangle</em><span class="sig-paren">)</span> &rarr; dlib.rectangle<a class="headerlink" href="#dlib.rectangle.intersect" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dlib.rectangle.is_empty">
<code class="descname">is_empty</code><span class="sig-paren">(</span><em>self: dlib.rectangle</em><span class="sig-paren">)</span> &rarr; bool<a class="headerlink" href="#dlib.rectangle.is_empty" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dlib.rectangle.left">
<code class="descname">left</code><span class="sig-paren">(</span><em>self: dlib.rectangle</em><span class="sig-paren">)</span> &rarr; int<a class="headerlink" href="#dlib.rectangle.left" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dlib.rectangle.right">
<code class="descname">right</code><span class="sig-paren">(</span><em>self: dlib.rectangle</em><span class="sig-paren">)</span> &rarr; int<a class="headerlink" href="#dlib.rectangle.right" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dlib.rectangle.tl_corner">
<code class="descname">tl_corner</code><span class="sig-paren">(</span><em>self: dlib.rectangle</em><span class="sig-paren">)</span> &rarr; dlib.point<a class="headerlink" href="#dlib.rectangle.tl_corner" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the top left corner of the rectangle.</p>
</dd></dl>

<dl class="method">
<dt id="dlib.rectangle.top">
<code class="descname">top</code><span class="sig-paren">(</span><em>self: dlib.rectangle</em><span class="sig-paren">)</span> &rarr; int<a class="headerlink" href="#dlib.rectangle.top" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dlib.rectangle.tr_corner">
<code class="descname">tr_corner</code><span class="sig-paren">(</span><em>self: dlib.rectangle</em><span class="sig-paren">)</span> &rarr; dlib.point<a class="headerlink" href="#dlib.rectangle.tr_corner" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the top right corner of the rectangle.</p>
</dd></dl>

<dl class="method">
<dt id="dlib.rectangle.width">
<code class="descname">width</code><span class="sig-paren">(</span><em>self: dlib.rectangle</em><span class="sig-paren">)</span> &rarr; int<a class="headerlink" href="#dlib.rectangle.width" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="dlib.rectangles">
<em class="property">class </em><code class="descclassname">dlib.</code><code class="descname">rectangles</code><a class="headerlink" href="#dlib.rectangles" title="Permalink to this definition">¶</a></dt>
<dd><p>An array of rectangle objects.</p>
<dl class="method">
<dt id="dlib.rectangles.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.rectangles.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: dlib.rectangles) -&gt; None</li>
<li>__init__(self: dlib.rectangles, arg0: dlib.rectangles) -&gt; None</li>
</ol>
<p>Copy constructor</p>
<ol class="arabic simple" start="3">
<li>__init__(self: dlib.rectangles, arg0: iterable) -&gt; None</li>
<li>__init__(self: dlib.rectangles, initial_size: int) -&gt; None</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="dlib.rectangles.append">
<code class="descname">append</code><span class="sig-paren">(</span><em>self: dlib.rectangles</em>, <em>x: dlib.rectangle</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.rectangles.append" title="Permalink to this definition">¶</a></dt>
<dd><p>Add an item to the end of the list</p>
</dd></dl>

<dl class="method">
<dt id="dlib.rectangles.clear">
<code class="descname">clear</code><span class="sig-paren">(</span><em>self: dlib.rectangles</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.rectangles.clear" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dlib.rectangles.count">
<code class="descname">count</code><span class="sig-paren">(</span><em>self: dlib.rectangles</em>, <em>x: dlib.rectangle</em><span class="sig-paren">)</span> &rarr; int<a class="headerlink" href="#dlib.rectangles.count" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of times <code class="docutils literal"><span class="pre">x</span></code> appears in the list</p>
</dd></dl>

<dl class="method">
<dt id="dlib.rectangles.extend">
<code class="descname">extend</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.rectangles.extend" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>extend(self: dlib.rectangles, L: dlib.rectangles) -&gt; None</li>
</ol>
<p>Extend the list by appending all the items in the given list</p>
<ol class="arabic simple" start="2">
<li>extend(self: dlib.rectangles, arg0: list) -&gt; None</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="dlib.rectangles.insert">
<code class="descname">insert</code><span class="sig-paren">(</span><em>self: dlib.rectangles</em>, <em>i: int</em>, <em>x: dlib.rectangle</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.rectangles.insert" title="Permalink to this definition">¶</a></dt>
<dd><p>Insert an item at a given position.</p>
</dd></dl>

<dl class="method">
<dt id="dlib.rectangles.pop">
<code class="descname">pop</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.rectangles.pop" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>pop(self: dlib.rectangles) -&gt; dlib.rectangle</li>
</ol>
<p>Remove and return the last item</p>
<ol class="arabic simple" start="2">
<li>pop(self: dlib.rectangles, i: int) -&gt; dlib.rectangle</li>
</ol>
<p>Remove and return the item at index <code class="docutils literal"><span class="pre">i</span></code></p>
</dd></dl>

<dl class="method">
<dt id="dlib.rectangles.remove">
<code class="descname">remove</code><span class="sig-paren">(</span><em>self: dlib.rectangles</em>, <em>x: dlib.rectangle</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.rectangles.remove" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove the first item from the list whose value is x. It is an error if there is no such item.</p>
</dd></dl>

<dl class="method">
<dt id="dlib.rectangles.resize">
<code class="descname">resize</code><span class="sig-paren">(</span><em>self: dlib.rectangles</em>, <em>arg0: int</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.rectangles.resize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="dlib.rectangless">
<em class="property">class </em><code class="descclassname">dlib.</code><code class="descname">rectangless</code><a class="headerlink" href="#dlib.rectangless" title="Permalink to this definition">¶</a></dt>
<dd><p>An array of arrays of rectangle objects.</p>
<dl class="method">
<dt id="dlib.rectangless.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.rectangless.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: dlib.rectangless) -&gt; None</li>
<li>__init__(self: dlib.rectangless, arg0: dlib.rectangless) -&gt; None</li>
</ol>
<p>Copy constructor</p>
<ol class="arabic simple" start="3">
<li>__init__(self: dlib.rectangless, arg0: iterable) -&gt; None</li>
<li>__init__(self: dlib.rectangless, initial_size: int) -&gt; None</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="dlib.rectangless.append">
<code class="descname">append</code><span class="sig-paren">(</span><em>self: dlib.rectangless</em>, <em>x: dlib.rectangles</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.rectangless.append" title="Permalink to this definition">¶</a></dt>
<dd><p>Add an item to the end of the list</p>
</dd></dl>

<dl class="method">
<dt id="dlib.rectangless.clear">
<code class="descname">clear</code><span class="sig-paren">(</span><em>self: dlib.rectangless</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.rectangless.clear" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dlib.rectangless.count">
<code class="descname">count</code><span class="sig-paren">(</span><em>self: dlib.rectangless</em>, <em>x: dlib.rectangles</em><span class="sig-paren">)</span> &rarr; int<a class="headerlink" href="#dlib.rectangless.count" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of times <code class="docutils literal"><span class="pre">x</span></code> appears in the list</p>
</dd></dl>

<dl class="method">
<dt id="dlib.rectangless.extend">
<code class="descname">extend</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.rectangless.extend" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>extend(self: dlib.rectangless, L: dlib.rectangless) -&gt; None</li>
</ol>
<p>Extend the list by appending all the items in the given list</p>
<ol class="arabic simple" start="2">
<li>extend(self: dlib.rectangles, arg0: list) -&gt; None</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="dlib.rectangless.insert">
<code class="descname">insert</code><span class="sig-paren">(</span><em>self: dlib.rectangless</em>, <em>i: int</em>, <em>x: dlib.rectangles</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.rectangless.insert" title="Permalink to this definition">¶</a></dt>
<dd><p>Insert an item at a given position.</p>
</dd></dl>

<dl class="method">
<dt id="dlib.rectangless.pop">
<code class="descname">pop</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.rectangless.pop" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>pop(self: dlib.rectangless) -&gt; dlib.rectangles</li>
</ol>
<p>Remove and return the last item</p>
<ol class="arabic simple" start="2">
<li>pop(self: dlib.rectangless, i: int) -&gt; dlib.rectangles</li>
</ol>
<p>Remove and return the item at index <code class="docutils literal"><span class="pre">i</span></code></p>
</dd></dl>

<dl class="method">
<dt id="dlib.rectangless.remove">
<code class="descname">remove</code><span class="sig-paren">(</span><em>self: dlib.rectangless</em>, <em>x: dlib.rectangles</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.rectangless.remove" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove the first item from the list whose value is x. It is an error if there is no such item.</p>
</dd></dl>

<dl class="method">
<dt id="dlib.rectangless.resize">
<code class="descname">resize</code><span class="sig-paren">(</span><em>self: dlib.rectangless</em>, <em>arg0: int</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.rectangless.resize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="dlib.reduce">
<code class="descclassname">dlib.</code><code class="descname">reduce</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.reduce" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>reduce(df: dlib._normalized_decision_function_radial_basis, x: dlib.vectors, num_basis_vectors: int, eps: float=0.001) -&gt; dlib._normalized_decision_function_radial_basis</li>
<li>reduce(df: dlib._normalized_decision_function_radial_basis, x: numpy.ndarray[(rows,cols),float64], num_basis_vectors: int, eps: float=0.001) -&gt; dlib._normalized_decision_function_radial_basis</li>
</ol>
<dl class="docutils">
<dt>requires </dt>
<dd><ul class="first last simple">
<li>eps &gt; 0</li>
<li>num_bv &gt; 0</li>
</ul>
</dd>
<dt>ensures </dt>
<dd><ul class="first last simple">
<li>This routine takes a learned radial basis function and tries to find a 
new RBF function with num_basis_vectors basis vectors that approximates 
the given df() as closely as possible.  In particular, it finds a 
function new_df() such that new_df(x[i])==df(x[i]) as often as possible.</li>
<li>This is accomplished using a reduced set method that begins by using a 
projection, in kernel space, onto a random set of num_basis_vectors 
vectors in x.  Then, L-BFGS is used to further optimize new_df() to match 
df().  The eps parameter controls how long L-BFGS will run, smaller 
values of eps possibly giving better solutions but taking longer to 
execute.</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="dlib.remove_incoherent_edge_pixels">
<code class="descclassname">dlib.</code><code class="descname">remove_incoherent_edge_pixels</code><span class="sig-paren">(</span><em>line: dlib.points, horz_gradient: numpy.ndarray[(rows,cols),float32], vert_gradient: numpy.ndarray[(rows,cols),float32], angle_thresh: float</em><span class="sig-paren">)</span> &rarr; dlib.points<a class="headerlink" href="#dlib.remove_incoherent_edge_pixels" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>requires </dt>
<dd><ul class="first last">
<li><p class="first">horz_gradient and vert_gradient have the same dimensions.</p>
</li>
<li><p class="first">horz_gradient and vert_gradient represent unit normalized vectors.  That is, 
you should have called normalize_image_gradients(horz_gradient,vert_gradient) 
or otherwise caused all the gradients to have unit norm.</p>
</li>
<li><dl class="first docutils">
<dt>for all valid i: </dt>
<dd><p class="first last">get_rect(horz_gradient).contains(line[i])</p>
</dd>
</dl>
</li>
</ul>
</dd>
<dt>ensures </dt>
<dd><ul class="first last">
<li><p class="first">This routine looks at all the points in the given line and discards the ones that 
have outlying gradient directions.  To be specific, this routine returns a set 
of points PTS such that:</p>
<blockquote>
<div><ul>
<li><dl class="first docutils">
<dt>for all valid i,j: </dt>
<dd><ul class="first last simple">
<li>The difference in angle between the gradients for PTS[i] and PTS[j] is  
less than angle_threshold degrees.</li>
</ul>
</dd>
</dl>
</li>
<li><p class="first">len(PTS) &lt;= len(line)</p>
</li>
<li><p class="first">PTS is just line with some elements removed.</p>
</li>
</ul>
</div></blockquote>
</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="dlib.resize_image">
<code class="descclassname">dlib.</code><code class="descname">resize_image</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.resize_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>resize_image(img: numpy.ndarray[(rows,cols),uint8], rows: int, cols: int) -&gt; numpy.ndarray[(rows,cols),uint8]</li>
<li>resize_image(img: numpy.ndarray[(rows,cols),uint16], rows: int, cols: int) -&gt; numpy.ndarray[(rows,cols),uint16]</li>
<li>resize_image(img: numpy.ndarray[(rows,cols),uint32], rows: int, cols: int) -&gt; numpy.ndarray[(rows,cols),uint32]</li>
<li>resize_image(img: numpy.ndarray[(rows,cols),uint64], rows: int, cols: int) -&gt; numpy.ndarray[(rows,cols),uint64]</li>
<li>resize_image(img: numpy.ndarray[(rows,cols),int8], rows: int, cols: int) -&gt; numpy.ndarray[(rows,cols),int8]</li>
<li>resize_image(img: numpy.ndarray[(rows,cols),int16], rows: int, cols: int) -&gt; numpy.ndarray[(rows,cols),int16]</li>
<li>resize_image(img: numpy.ndarray[(rows,cols),int32], rows: int, cols: int) -&gt; numpy.ndarray[(rows,cols),int32]</li>
<li>resize_image(img: numpy.ndarray[(rows,cols),int64], rows: int, cols: int) -&gt; numpy.ndarray[(rows,cols),int64]</li>
<li>resize_image(img: numpy.ndarray[(rows,cols),float32], rows: int, cols: int) -&gt; numpy.ndarray[(rows,cols),float32]</li>
<li>resize_image(img: numpy.ndarray[(rows,cols),float64], rows: int, cols: int) -&gt; numpy.ndarray[(rows,cols),float64]</li>
</ol>
<p>Resizes img, using bilinear interpolation, to have the indicated number of rows and columns.</p>
<ol class="arabic simple" start="11">
<li>resize_image(img: numpy.ndarray[(rows,cols,3),uint8], rows: int, cols: int) -&gt; numpy.ndarray[(rows,cols,3),uint8]</li>
</ol>
<p>Resizes img, using bilinear interpolation, to have the indicated number of rows and columns.</p>
<ol class="arabic simple" start="12">
<li>resize_image(img: numpy.ndarray[(rows,cols),int8], scale: float) -&gt; numpy.ndarray[(rows,cols),int8]</li>
<li>resize_image(img: numpy.ndarray[(rows,cols),int16], scale: float) -&gt; numpy.ndarray[(rows,cols),int16]</li>
<li>resize_image(img: numpy.ndarray[(rows,cols),int32], scale: float) -&gt; numpy.ndarray[(rows,cols),int32]</li>
<li>resize_image(img: numpy.ndarray[(rows,cols),int64], scale: float) -&gt; numpy.ndarray[(rows,cols),int64]</li>
<li>resize_image(img: numpy.ndarray[(rows,cols),float32], scale: float) -&gt; numpy.ndarray[(rows,cols),float32]</li>
<li>resize_image(img: numpy.ndarray[(rows,cols),float64], scale: float) -&gt; numpy.ndarray[(rows,cols),float64]</li>
<li>resize_image(img: numpy.ndarray[(rows,cols,3),uint8], scale: float) -&gt; numpy.ndarray[(rows,cols,3),uint8]</li>
</ol>
<p>Resizes img, using bilinear interpolation, to have the new size (img rows * scale, img cols * scale)</p>
</dd></dl>

<dl class="function">
<dt id="dlib.reverse">
<code class="descclassname">dlib.</code><code class="descname">reverse</code><span class="sig-paren">(</span><em>l: dlib.line</em><span class="sig-paren">)</span> &rarr; dlib.line<a class="headerlink" href="#dlib.reverse" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>ensures </dt>
<dd><ul class="first last simple">
<li>returns line(l.p2, l.p1) 
(i.e. returns a line object that represents the same line as l but with the 
endpoints, and therefore, the normal vector flipped.  This means that the 
signed distance of operator() is also flipped).</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="dlib.rgb_pixel">
<em class="property">class </em><code class="descclassname">dlib.</code><code class="descname">rgb_pixel</code><a class="headerlink" href="#dlib.rgb_pixel" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="dlib.rgb_pixel.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: dlib.rgb_pixel</em>, <em>red: int</em>, <em>green: int</em>, <em>blue: int</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.rgb_pixel.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.rgb_pixel.blue">
<code class="descname">blue</code><a class="headerlink" href="#dlib.rgb_pixel.blue" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.rgb_pixel.green">
<code class="descname">green</code><a class="headerlink" href="#dlib.rgb_pixel.green" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.rgb_pixel.red">
<code class="descname">red</code><a class="headerlink" href="#dlib.rgb_pixel.red" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="dlib.rvm_trainer_histogram_intersection">
<em class="property">class </em><code class="descclassname">dlib.</code><code class="descname">rvm_trainer_histogram_intersection</code><a class="headerlink" href="#dlib.rvm_trainer_histogram_intersection" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="dlib.rvm_trainer_histogram_intersection.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: dlib.rvm_trainer_histogram_intersection</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.rvm_trainer_histogram_intersection.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.rvm_trainer_histogram_intersection.epsilon">
<code class="descname">epsilon</code><a class="headerlink" href="#dlib.rvm_trainer_histogram_intersection.epsilon" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dlib.rvm_trainer_histogram_intersection.train">
<code class="descname">train</code><span class="sig-paren">(</span><em>self: dlib.rvm_trainer_histogram_intersection</em>, <em>arg0: dlib.vectors</em>, <em>arg1: dlib.array</em><span class="sig-paren">)</span> &rarr; dlib._decision_function_histogram_intersection<a class="headerlink" href="#dlib.rvm_trainer_histogram_intersection.train" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="dlib.rvm_trainer_linear">
<em class="property">class </em><code class="descclassname">dlib.</code><code class="descname">rvm_trainer_linear</code><a class="headerlink" href="#dlib.rvm_trainer_linear" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="dlib.rvm_trainer_linear.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: dlib.rvm_trainer_linear</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.rvm_trainer_linear.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.rvm_trainer_linear.epsilon">
<code class="descname">epsilon</code><a class="headerlink" href="#dlib.rvm_trainer_linear.epsilon" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dlib.rvm_trainer_linear.train">
<code class="descname">train</code><span class="sig-paren">(</span><em>self: dlib.rvm_trainer_linear</em>, <em>arg0: dlib.vectors</em>, <em>arg1: dlib.array</em><span class="sig-paren">)</span> &rarr; dlib._decision_function_linear<a class="headerlink" href="#dlib.rvm_trainer_linear.train" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="dlib.rvm_trainer_radial_basis">
<em class="property">class </em><code class="descclassname">dlib.</code><code class="descname">rvm_trainer_radial_basis</code><a class="headerlink" href="#dlib.rvm_trainer_radial_basis" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="dlib.rvm_trainer_radial_basis.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: dlib.rvm_trainer_radial_basis</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.rvm_trainer_radial_basis.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.rvm_trainer_radial_basis.epsilon">
<code class="descname">epsilon</code><a class="headerlink" href="#dlib.rvm_trainer_radial_basis.epsilon" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.rvm_trainer_radial_basis.gamma">
<code class="descname">gamma</code><a class="headerlink" href="#dlib.rvm_trainer_radial_basis.gamma" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dlib.rvm_trainer_radial_basis.train">
<code class="descname">train</code><span class="sig-paren">(</span><em>self: dlib.rvm_trainer_radial_basis</em>, <em>arg0: dlib.vectors</em>, <em>arg1: dlib.array</em><span class="sig-paren">)</span> &rarr; dlib._decision_function_radial_basis<a class="headerlink" href="#dlib.rvm_trainer_radial_basis.train" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="dlib.rvm_trainer_sparse_histogram_intersection">
<em class="property">class </em><code class="descclassname">dlib.</code><code class="descname">rvm_trainer_sparse_histogram_intersection</code><a class="headerlink" href="#dlib.rvm_trainer_sparse_histogram_intersection" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="dlib.rvm_trainer_sparse_histogram_intersection.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: dlib.rvm_trainer_sparse_histogram_intersection</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.rvm_trainer_sparse_histogram_intersection.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.rvm_trainer_sparse_histogram_intersection.epsilon">
<code class="descname">epsilon</code><a class="headerlink" href="#dlib.rvm_trainer_sparse_histogram_intersection.epsilon" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dlib.rvm_trainer_sparse_histogram_intersection.train">
<code class="descname">train</code><span class="sig-paren">(</span><em>self: dlib.rvm_trainer_sparse_histogram_intersection</em>, <em>arg0: dlib.sparse_vectors</em>, <em>arg1: dlib.array</em><span class="sig-paren">)</span> &rarr; dlib._decision_function_sparse_histogram_intersection<a class="headerlink" href="#dlib.rvm_trainer_sparse_histogram_intersection.train" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="dlib.rvm_trainer_sparse_linear">
<em class="property">class </em><code class="descclassname">dlib.</code><code class="descname">rvm_trainer_sparse_linear</code><a class="headerlink" href="#dlib.rvm_trainer_sparse_linear" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="dlib.rvm_trainer_sparse_linear.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: dlib.rvm_trainer_sparse_linear</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.rvm_trainer_sparse_linear.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.rvm_trainer_sparse_linear.epsilon">
<code class="descname">epsilon</code><a class="headerlink" href="#dlib.rvm_trainer_sparse_linear.epsilon" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dlib.rvm_trainer_sparse_linear.train">
<code class="descname">train</code><span class="sig-paren">(</span><em>self: dlib.rvm_trainer_sparse_linear</em>, <em>arg0: dlib.sparse_vectors</em>, <em>arg1: dlib.array</em><span class="sig-paren">)</span> &rarr; dlib._decision_function_sparse_linear<a class="headerlink" href="#dlib.rvm_trainer_sparse_linear.train" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="dlib.rvm_trainer_sparse_radial_basis">
<em class="property">class </em><code class="descclassname">dlib.</code><code class="descname">rvm_trainer_sparse_radial_basis</code><a class="headerlink" href="#dlib.rvm_trainer_sparse_radial_basis" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="dlib.rvm_trainer_sparse_radial_basis.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: dlib.rvm_trainer_sparse_radial_basis</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.rvm_trainer_sparse_radial_basis.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.rvm_trainer_sparse_radial_basis.epsilon">
<code class="descname">epsilon</code><a class="headerlink" href="#dlib.rvm_trainer_sparse_radial_basis.epsilon" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.rvm_trainer_sparse_radial_basis.gamma">
<code class="descname">gamma</code><a class="headerlink" href="#dlib.rvm_trainer_sparse_radial_basis.gamma" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dlib.rvm_trainer_sparse_radial_basis.train">
<code class="descname">train</code><span class="sig-paren">(</span><em>self: dlib.rvm_trainer_sparse_radial_basis</em>, <em>arg0: dlib.sparse_vectors</em>, <em>arg1: dlib.array</em><span class="sig-paren">)</span> &rarr; dlib._decision_function_sparse_radial_basis<a class="headerlink" href="#dlib.rvm_trainer_sparse_radial_basis.train" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="dlib.save_face_chip">
<code class="descclassname">dlib.</code><code class="descname">save_face_chip</code><span class="sig-paren">(</span><em>img: numpy.ndarray[(rows,cols,3),uint8], face: dlib.full_object_detection, chip_filename: unicode, size: int=150L, padding: float=0.25</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.save_face_chip" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes an image and a full_object_detection that references a face in that image and saves the face with the specified file name prefix.  The face will be rotated upright and scaled to 150x150 pixels or with the optional specified size and padding.</p>
</dd></dl>

<dl class="function">
<dt id="dlib.save_face_chips">
<code class="descclassname">dlib.</code><code class="descname">save_face_chips</code><span class="sig-paren">(</span><em>img: numpy.ndarray[(rows,cols,3),uint8], faces: dlib.full_object_detections, chip_filename: unicode, size: int=150L, padding: float=0.25</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.save_face_chips" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes an image and a full_object_detections object that reference faces in that image and saves the faces with the specified file name prefix.  The faces will be rotated upright and scaled to 150x150 pixels or with the optional specified size and padding.</p>
</dd></dl>

<dl class="function">
<dt id="dlib.save_image">
<code class="descclassname">dlib.</code><code class="descname">save_image</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.save_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>save_image(img: numpy.ndarray[(rows,cols,3),uint8], filename: unicode) -&gt; None</li>
</ol>
<p>Saves the given image to the specified path. Determines the file type from the file extension specified in the path</p>
<ol class="arabic simple" start="2">
<li>save_image(img: numpy.ndarray[(rows,cols),uint8], filename: unicode) -&gt; None</li>
</ol>
<p>Saves the given image to the specified path. Determines the file type from the file extension specified in the path</p>
</dd></dl>

<dl class="function">
<dt id="dlib.save_libsvm_formatted_data">
<code class="descclassname">dlib.</code><code class="descname">save_libsvm_formatted_data</code><span class="sig-paren">(</span><em>file_name: unicode</em>, <em>samples: dlib.sparse_vectors</em>, <em>labels: dlib.array</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.save_libsvm_formatted_data" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>requires    </dt>
<dd><ul class="first last simple">
<li>len(samples) == len(labels)</li>
</ul>
</dd>
<dt>ensures    </dt>
<dd><ul class="first last simple">
<li>saves the data to the given file in libsvm format</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="dlib.scale_rect">
<code class="descclassname">dlib.</code><code class="descname">scale_rect</code><span class="sig-paren">(</span><em>rect: dlib.rectangle</em>, <em>scale: float</em><span class="sig-paren">)</span> &rarr; dlib.rectangle<a class="headerlink" href="#dlib.scale_rect" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>return scale_rect(rect, scale)</li>
</ul>
<p>(i.e. resizes the given rectangle by a scale factor)</p>
</dd></dl>

<dl class="class">
<dt id="dlib.segmenter_params">
<em class="property">class </em><code class="descclassname">dlib.</code><code class="descname">segmenter_params</code><a class="headerlink" href="#dlib.segmenter_params" title="Permalink to this definition">¶</a></dt>
<dd><p>This class is used to define all the optional parameters to the    
train_sequence_segmenter() and cross_validate_sequence_segmenter() routines.</p>
<dl class="attribute">
<dt id="dlib.segmenter_params.C">
<code class="descname">C</code><a class="headerlink" href="#dlib.segmenter_params.C" title="Permalink to this definition">¶</a></dt>
<dd><p>SVM C parameter</p>
</dd></dl>

<dl class="method">
<dt id="dlib.segmenter_params.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: dlib.segmenter_params</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.segmenter_params.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.segmenter_params.allow_negative_weights">
<code class="descname">allow_negative_weights</code><a class="headerlink" href="#dlib.segmenter_params.allow_negative_weights" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.segmenter_params.be_verbose">
<code class="descname">be_verbose</code><a class="headerlink" href="#dlib.segmenter_params.be_verbose" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.segmenter_params.epsilon">
<code class="descname">epsilon</code><a class="headerlink" href="#dlib.segmenter_params.epsilon" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.segmenter_params.max_cache_size">
<code class="descname">max_cache_size</code><a class="headerlink" href="#dlib.segmenter_params.max_cache_size" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.segmenter_params.num_threads">
<code class="descname">num_threads</code><a class="headerlink" href="#dlib.segmenter_params.num_threads" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.segmenter_params.use_BIO_model">
<code class="descname">use_BIO_model</code><a class="headerlink" href="#dlib.segmenter_params.use_BIO_model" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.segmenter_params.use_high_order_features">
<code class="descname">use_high_order_features</code><a class="headerlink" href="#dlib.segmenter_params.use_high_order_features" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.segmenter_params.window_size">
<code class="descname">window_size</code><a class="headerlink" href="#dlib.segmenter_params.window_size" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="dlib.segmenter_test">
<em class="property">class </em><code class="descclassname">dlib.</code><code class="descname">segmenter_test</code><a class="headerlink" href="#dlib.segmenter_test" title="Permalink to this definition">¶</a></dt>
<dd><p>This object is the output of the dlib.test_sequence_segmenter() and dlib.cross_validate_sequence_segmenter() routines.</p>
<dl class="attribute">
<dt id="dlib.segmenter_test.__init__">
<code class="descname">__init__</code><a class="headerlink" href="#dlib.segmenter_test.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__init__(...) initializes x; see help(type(x)) for signature</p>
</dd></dl>

<dl class="attribute">
<dt id="dlib.segmenter_test.f1">
<code class="descname">f1</code><a class="headerlink" href="#dlib.segmenter_test.f1" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.segmenter_test.precision">
<code class="descname">precision</code><a class="headerlink" href="#dlib.segmenter_test.precision" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.segmenter_test.recall">
<code class="descname">recall</code><a class="headerlink" href="#dlib.segmenter_test.recall" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="dlib.segmenter_type">
<em class="property">class </em><code class="descclassname">dlib.</code><code class="descname">segmenter_type</code><a class="headerlink" href="#dlib.segmenter_type" title="Permalink to this definition">¶</a></dt>
<dd><p>This object represents a sequence segmenter and is the type of object returned by the dlib.train_sequence_segmenter() routine.</p>
<dl class="method">
<dt id="dlib.segmenter_type.__call__">
<code class="descname">__call__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.segmenter_type.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__call__(self: dlib.segmenter_type, arg0: dlib.vectors) -&gt; dlib.ranges</li>
<li>__call__(self: dlib.segmenter_type, arg0: dlib.sparse_vectors) -&gt; dlib.ranges</li>
</ol>
</dd></dl>

<dl class="attribute">
<dt id="dlib.segmenter_type.__init__">
<code class="descname">__init__</code><a class="headerlink" href="#dlib.segmenter_type.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__init__(...) initializes x; see help(type(x)) for signature</p>
</dd></dl>

<dl class="attribute">
<dt id="dlib.segmenter_type.weights">
<code class="descname">weights</code><a class="headerlink" href="#dlib.segmenter_type.weights" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="dlib.set_dnn_prefer_smallest_algorithms">
<code class="descclassname">dlib.</code><code class="descname">set_dnn_prefer_smallest_algorithms</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.set_dnn_prefer_smallest_algorithms" title="Permalink to this definition">¶</a></dt>
<dd><p>Tells cuDNN to use slower algorithms that use less RAM.</p>
</dd></dl>

<dl class="class">
<dt id="dlib.shape_predictor">
<em class="property">class </em><code class="descclassname">dlib.</code><code class="descname">shape_predictor</code><a class="headerlink" href="#dlib.shape_predictor" title="Permalink to this definition">¶</a></dt>
<dd><p>This object is a tool that takes in an image region containing some object and outputs a set of point locations that define the pose of the object. The classic example of this is human face pose prediction, where you take an image of a human face as input and are expected to identify the locations of important facial landmarks such as the corners of the mouth and eyes, tip of the nose, and so forth.</p>
<dl class="method">
<dt id="dlib.shape_predictor.__call__">
<code class="descname">__call__</code><span class="sig-paren">(</span><em>self: dlib.shape_predictor</em>, <em>image: array</em>, <em>box: dlib.rectangle</em><span class="sig-paren">)</span> &rarr; dlib.full_object_detection<a class="headerlink" href="#dlib.shape_predictor.__call__" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>requires </dt>
<dd><ul class="first last simple">
<li>image is a numpy ndarray containing either an 8bit grayscale or RGB 
image.</li>
<li>box is the bounding box to begin the shape prediction inside.</li>
</ul>
</dd>
<dt>ensures </dt>
<dd><ul class="first last simple">
<li>This function runs the shape predictor on the input image and returns 
a single full_object_detection.</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dlib.shape_predictor.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.shape_predictor.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: dlib.shape_predictor) -&gt; None</li>
<li>__init__(self: dlib.shape_predictor, arg0: unicode) -&gt; None</li>
</ol>
<p>Loads a shape_predictor from a file that contains the output of the 
train_shape_predictor() routine.</p>
</dd></dl>

<dl class="method">
<dt id="dlib.shape_predictor.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>self: dlib.shape_predictor</em>, <em>predictor_output_filename: unicode</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.shape_predictor.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save a shape_predictor to the provided path.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="dlib.shape_predictor_training_options">
<em class="property">class </em><code class="descclassname">dlib.</code><code class="descname">shape_predictor_training_options</code><a class="headerlink" href="#dlib.shape_predictor_training_options" title="Permalink to this definition">¶</a></dt>
<dd><p>This object is a container for the options to the train_shape_predictor() routine.</p>
<dl class="method">
<dt id="dlib.shape_predictor_training_options.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: dlib.shape_predictor_training_options</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.shape_predictor_training_options.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.shape_predictor_training_options.be_verbose">
<code class="descname">be_verbose</code><a class="headerlink" href="#dlib.shape_predictor_training_options.be_verbose" title="Permalink to this definition">¶</a></dt>
<dd><p>If true, train_shape_predictor() will print out a lot of information to stdout while training.</p>
</dd></dl>

<dl class="attribute">
<dt id="dlib.shape_predictor_training_options.cascade_depth">
<code class="descname">cascade_depth</code><a class="headerlink" href="#dlib.shape_predictor_training_options.cascade_depth" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of cascades created to train the model with.</p>
</dd></dl>

<dl class="attribute">
<dt id="dlib.shape_predictor_training_options.feature_pool_region_padding">
<code class="descname">feature_pool_region_padding</code><a class="headerlink" href="#dlib.shape_predictor_training_options.feature_pool_region_padding" title="Permalink to this definition">¶</a></dt>
<dd><p>Size of region within which to sample features for the feature pool.                       positive values increase the sampling region while negative values decrease it. E.g. padding of 0 means we                       sample fr</p>
</dd></dl>

<dl class="attribute">
<dt id="dlib.shape_predictor_training_options.feature_pool_size">
<code class="descname">feature_pool_size</code><a class="headerlink" href="#dlib.shape_predictor_training_options.feature_pool_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of pixels used to generate features for the random trees.</p>
</dd></dl>

<dl class="attribute">
<dt id="dlib.shape_predictor_training_options.lambda_param">
<code class="descname">lambda_param</code><a class="headerlink" href="#dlib.shape_predictor_training_options.lambda_param" title="Permalink to this definition">¶</a></dt>
<dd><p>Controls how tight the feature sampling should be. Lower values enforce closer features.</p>
</dd></dl>

<dl class="attribute">
<dt id="dlib.shape_predictor_training_options.landmark_relative_padding_mode">
<code class="descname">landmark_relative_padding_mode</code><a class="headerlink" href="#dlib.shape_predictor_training_options.landmark_relative_padding_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>If True then features are drawn only from the box around the landmarks, otherwise they come from the bounding box and landmarks together.  See feature_pool_region_padding doc for more details.</p>
</dd></dl>

<dl class="attribute">
<dt id="dlib.shape_predictor_training_options.nu">
<code class="descname">nu</code><a class="headerlink" href="#dlib.shape_predictor_training_options.nu" title="Permalink to this definition">¶</a></dt>
<dd><p>The regularization parameter.  Larger values of this parameter                        will cause the algorithm to fit the training data better but may also                        cause overfitting.  The value must be in the range (0, 1].</p>
</dd></dl>

<dl class="attribute">
<dt id="dlib.shape_predictor_training_options.num_test_splits">
<code class="descname">num_test_splits</code><a class="headerlink" href="#dlib.shape_predictor_training_options.num_test_splits" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of split features at each node to sample. The one that gives the best split is chosen.</p>
</dd></dl>

<dl class="attribute">
<dt id="dlib.shape_predictor_training_options.num_threads">
<code class="descname">num_threads</code><a class="headerlink" href="#dlib.shape_predictor_training_options.num_threads" title="Permalink to this definition">¶</a></dt>
<dd><p>Use this many threads/CPU cores for training.</p>
</dd></dl>

<dl class="attribute">
<dt id="dlib.shape_predictor_training_options.num_trees_per_cascade_level">
<code class="descname">num_trees_per_cascade_level</code><a class="headerlink" href="#dlib.shape_predictor_training_options.num_trees_per_cascade_level" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of trees created for each cascade.</p>
</dd></dl>

<dl class="attribute">
<dt id="dlib.shape_predictor_training_options.oversampling_amount">
<code class="descname">oversampling_amount</code><a class="headerlink" href="#dlib.shape_predictor_training_options.oversampling_amount" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of randomly selected initial starting points sampled for each training example</p>
</dd></dl>

<dl class="attribute">
<dt id="dlib.shape_predictor_training_options.oversampling_translation_jitter">
<code class="descname">oversampling_translation_jitter</code><a class="headerlink" href="#dlib.shape_predictor_training_options.oversampling_translation_jitter" title="Permalink to this definition">¶</a></dt>
<dd><p>The amount of translation jittering to apply to bounding boxes, a good value is in in the range [0 0.5].</p>
</dd></dl>

<dl class="attribute">
<dt id="dlib.shape_predictor_training_options.random_seed">
<code class="descname">random_seed</code><a class="headerlink" href="#dlib.shape_predictor_training_options.random_seed" title="Permalink to this definition">¶</a></dt>
<dd><p>The random seed used by the internal random number generator</p>
</dd></dl>

<dl class="attribute">
<dt id="dlib.shape_predictor_training_options.tree_depth">
<code class="descname">tree_depth</code><a class="headerlink" href="#dlib.shape_predictor_training_options.tree_depth" title="Permalink to this definition">¶</a></dt>
<dd><p>The depth of the trees used in each cascade. There are pow(2, get_tree_depth()) leaves in each tree</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="dlib.shrink_rect">
<code class="descclassname">dlib.</code><code class="descname">shrink_rect</code><span class="sig-paren">(</span><em>rect: dlib.rectangle</em>, <em>num: int</em><span class="sig-paren">)</span> &rarr; dlib.rectangle<a class="headerlink" href="#dlib.shrink_rect" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>returns rectangle(rect.left()+num, rect.top()+num, rect.right()-num, rect.bottom()-num) </dt>
<dd>(i.e. shrinks the given rectangle by shrinking its border by num)</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="dlib.signed_distance_to_line">
<code class="descclassname">dlib.</code><code class="descname">signed_distance_to_line</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.signed_distance_to_line" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>signed_distance_to_line(l: dlib.line, p: dlib.point) -&gt; float</li>
<li>signed_distance_to_line(l: dlib.line, p: dlib.dpoint) -&gt; float</li>
</ol>
<dl class="docutils">
<dt>ensures </dt>
<dd><ul class="first last simple">
<li>returns how far p is from the line l.  This is a signed distance.  The sign 
indicates which side of the line the point is on and the magnitude is the 
distance. Moreover, the direction of positive sign is pointed to by the 
vector l.normal.</li>
<li>To be specific, this routine returns dot(p-l.p1, l.normal)</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="dlib.simple_object_detector">
<em class="property">class </em><code class="descclassname">dlib.</code><code class="descname">simple_object_detector</code><a class="headerlink" href="#dlib.simple_object_detector" title="Permalink to this definition">¶</a></dt>
<dd><p>This object represents a sliding window histogram-of-oriented-gradients based object detector.</p>
<dl class="method">
<dt id="dlib.simple_object_detector.__call__">
<code class="descname">__call__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.simple_object_detector.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__call__(self: dlib.simple_object_detector, image: array, upsample_num_times: int) -&gt; dlib.rectangles</li>
</ol>
<dl class="docutils">
<dt>requires </dt>
<dd><ul class="first last simple">
<li>image is a numpy ndarray containing either an 8bit grayscale or RGB 
image.</li>
<li>upsample_num_times &gt;= 0</li>
</ul>
</dd>
<dt>ensures </dt>
<dd><ul class="first last simple">
<li>This function runs the object detector on the input image and returns 
a list of detections.</li>
<li>Upsamples the image upsample_num_times before running the basic 
detector.  If you don&#8217;t know how many times you want to upsample then 
don&#8217;t provide a value for upsample_num_times and an appropriate 
default will be used.</li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li>__call__(self: dlib.simple_object_detector, image: array) -&gt; dlib.rectangles</li>
</ol>
<dl class="docutils">
<dt>requires </dt>
<dd><ul class="first last simple">
<li>image is a numpy ndarray containing either an 8bit grayscale or RGB 
image.</li>
</ul>
</dd>
<dt>ensures </dt>
<dd><ul class="first last simple">
<li>This function runs the object detector on the input image and returns 
a list of detections.</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dlib.simple_object_detector.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.simple_object_detector.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: dlib.simple_object_detector, detectors: list) -&gt; None</li>
</ol>
<p>This version of the constructor builds a simple_object_detector from a 
bunch of other simple_object_detectors.  It essentially packs them together 
so that when you run the detector it&#8217;s like calling run_multiple().  Except 
in this case the non-max suppression is applied to them all as a group.  So 
unlike run_multiple(), each detector competes in the non-max suppression.</p>
<p>Also, the non-max suppression settings used for this whole thing are 
the settings used by detectors[0].  So if you have a preference,  
put the detector that uses the type of non-max suppression you like first 
in the list.</p>
<ol class="arabic simple" start="2">
<li>__init__(self: dlib.simple_object_detector, arg0: unicode) -&gt; None</li>
</ol>
<p>Loads a simple_object_detector from a file that contains the output of the 
train_simple_object_detector() routine.</p>
</dd></dl>

<dl class="attribute">
<dt id="dlib.simple_object_detector.detection_window_height">
<code class="descname">detection_window_height</code><a class="headerlink" href="#dlib.simple_object_detector.detection_window_height" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.simple_object_detector.detection_window_width">
<code class="descname">detection_window_width</code><a class="headerlink" href="#dlib.simple_object_detector.detection_window_width" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.simple_object_detector.num_detectors">
<code class="descname">num_detectors</code><a class="headerlink" href="#dlib.simple_object_detector.num_detectors" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dlib.simple_object_detector.run_multiple">
<code class="descname">run_multiple</code><span class="sig-paren">(</span><em>detectors: list</em>, <em>image: array</em>, <em>upsample_num_times: int=0L</em>, <em>adjust_threshold: float=0.0</em><span class="sig-paren">)</span> &rarr; tuple<a class="headerlink" href="#dlib.simple_object_detector.run_multiple" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>requires </dt>
<dd><ul class="first last simple">
<li>detectors is a list of detectors.</li>
<li>image is a numpy ndarray containing either an 8bit grayscale or RGB 
image.</li>
<li>upsample_num_times &gt;= 0</li>
</ul>
</dd>
<dt>ensures </dt>
<dd><ul class="first last simple">
<li>This function runs the list of object detectors at once on the input image and returns 
a tuple of (list of detections, list of scores, list of weight_indices).</li>
<li>Upsamples the image upsample_num_times before running the basic 
detector.</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dlib.simple_object_detector.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>self: dlib.simple_object_detector</em>, <em>detector_output_filename: unicode</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.simple_object_detector.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save a simple_object_detector to the provided path.</p>
</dd></dl>

<dl class="attribute">
<dt id="dlib.simple_object_detector.upsampling_amount">
<code class="descname">upsampling_amount</code><a class="headerlink" href="#dlib.simple_object_detector.upsampling_amount" title="Permalink to this definition">¶</a></dt>
<dd><p>The detector upsamples the image this many times before running.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="dlib.simple_object_detector_training_options">
<em class="property">class </em><code class="descclassname">dlib.</code><code class="descname">simple_object_detector_training_options</code><a class="headerlink" href="#dlib.simple_object_detector_training_options" title="Permalink to this definition">¶</a></dt>
<dd><p>This object is a container for the options to the train_simple_object_detector() routine.</p>
<dl class="attribute">
<dt id="dlib.simple_object_detector_training_options.C">
<code class="descname">C</code><a class="headerlink" href="#dlib.simple_object_detector_training_options.C" title="Permalink to this definition">¶</a></dt>
<dd><p>C is the usual SVM C regularization parameter.  So it is passed to 
structural_object_detection_trainer::set_c().  Larger values of C 
will encourage the trainer to fit the data better but might lead to 
overfitting.  Therefore, you must determine the proper setting of 
this parameter experimentally.</p>
</dd></dl>

<dl class="method">
<dt id="dlib.simple_object_detector_training_options.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: dlib.simple_object_detector_training_options</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.simple_object_detector_training_options.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.simple_object_detector_training_options.add_left_right_image_flips">
<code class="descname">add_left_right_image_flips</code><a class="headerlink" href="#dlib.simple_object_detector_training_options.add_left_right_image_flips" title="Permalink to this definition">¶</a></dt>
<dd><p>if true, train_simple_object_detector() will assume the objects are 
left/right symmetric and add in left right flips of the training 
images.  This doubles the size of the training dataset.</p>
</dd></dl>

<dl class="attribute">
<dt id="dlib.simple_object_detector_training_options.be_verbose">
<code class="descname">be_verbose</code><a class="headerlink" href="#dlib.simple_object_detector_training_options.be_verbose" title="Permalink to this definition">¶</a></dt>
<dd><p>If true, train_simple_object_detector() will print out a lot of information to the screen while training.</p>
</dd></dl>

<dl class="attribute">
<dt id="dlib.simple_object_detector_training_options.detection_window_size">
<code class="descname">detection_window_size</code><a class="headerlink" href="#dlib.simple_object_detector_training_options.detection_window_size" title="Permalink to this definition">¶</a></dt>
<dd><p>The sliding window used will have about this many pixels inside it.</p>
</dd></dl>

<dl class="attribute">
<dt id="dlib.simple_object_detector_training_options.epsilon">
<code class="descname">epsilon</code><a class="headerlink" href="#dlib.simple_object_detector_training_options.epsilon" title="Permalink to this definition">¶</a></dt>
<dd><p>epsilon is the stopping epsilon.  Smaller values make the trainer&#8217;s 
solver more accurate but might take longer to train.</p>
</dd></dl>

<dl class="attribute">
<dt id="dlib.simple_object_detector_training_options.max_runtime_seconds">
<code class="descname">max_runtime_seconds</code><a class="headerlink" href="#dlib.simple_object_detector_training_options.max_runtime_seconds" title="Permalink to this definition">¶</a></dt>
<dd><p>Don&#8217;t let the solver run for longer than this many seconds.</p>
</dd></dl>

<dl class="attribute">
<dt id="dlib.simple_object_detector_training_options.nuclear_norm_regularization_strength">
<code class="descname">nuclear_norm_regularization_strength</code><a class="headerlink" href="#dlib.simple_object_detector_training_options.nuclear_norm_regularization_strength" title="Permalink to this definition">¶</a></dt>
<dd><p>This detector works by convolving a filter over a HOG feature image.  If that 
filter is separable then the convolution can be performed much faster.  The 
nuclear_norm_regularization_strength parameter encourages the machine learning 
algorithm to learn a separable filter.  A value of 0 disables this feature, but 
any non-zero value places a nuclear norm regularizer on the objective function 
and this encourages the learning of a separable filter.  Note that setting 
nuclear_norm_regularization_strength to a non-zero value can make the training 
process take significantly longer, so be patient when using it.</p>
</dd></dl>

<dl class="attribute">
<dt id="dlib.simple_object_detector_training_options.num_threads">
<code class="descname">num_threads</code><a class="headerlink" href="#dlib.simple_object_detector_training_options.num_threads" title="Permalink to this definition">¶</a></dt>
<dd><p>train_simple_object_detector() will use this many threads of 
execution.  Set this to the number of CPU cores on your machine to 
obtain the fastest training speed.</p>
</dd></dl>

<dl class="attribute">
<dt id="dlib.simple_object_detector_training_options.upsample_limit">
<code class="descname">upsample_limit</code><a class="headerlink" href="#dlib.simple_object_detector_training_options.upsample_limit" title="Permalink to this definition">¶</a></dt>
<dd><p>train_simple_object_detector() will upsample images if needed 
no more than upsample_limit times. Value 0 will forbid trainer to 
upsample any images. If trainer is unable to fit all boxes with 
required upsample_limit, exception will be thrown. Higher values 
of upsample_limit exponentially increases memory requirements. 
Values higher than 2 (default) are not recommended.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="dlib.simple_test_results">
<em class="property">class </em><code class="descclassname">dlib.</code><code class="descname">simple_test_results</code><a class="headerlink" href="#dlib.simple_test_results" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="dlib.simple_test_results.__init__">
<code class="descname">__init__</code><a class="headerlink" href="#dlib.simple_test_results.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__init__(...) initializes x; see help(type(x)) for signature</p>
</dd></dl>

<dl class="attribute">
<dt id="dlib.simple_test_results.average_precision">
<code class="descname">average_precision</code><a class="headerlink" href="#dlib.simple_test_results.average_precision" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.simple_test_results.precision">
<code class="descname">precision</code><a class="headerlink" href="#dlib.simple_test_results.precision" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.simple_test_results.recall">
<code class="descname">recall</code><a class="headerlink" href="#dlib.simple_test_results.recall" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="dlib.skeleton">
<code class="descclassname">dlib.</code><code class="descname">skeleton</code><span class="sig-paren">(</span><em>img: numpy.ndarray[(rows,cols),uint8]</em><span class="sig-paren">)</span> &rarr; numpy.ndarray[(rows,cols),uint8]<a class="headerlink" href="#dlib.skeleton" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>requires </dt>
<dd><ul class="first last simple">
<li>all pixels in img are set to either 255 or 0.</li>
</ul>
</dd>
<dt>ensures </dt>
<dd><ul class="first last simple">
<li>This function computes the skeletonization of img and stores the result in 
#img.  That is, given a binary image, we progressively thin the binary blobs 
(composed of on_pixel values) until only a single pixel wide skeleton of the 
original blobs remains.</li>
<li>Doesn&#8217;t change the shape or size of img.</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="dlib.sobel_edge_detector">
<code class="descclassname">dlib.</code><code class="descname">sobel_edge_detector</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.sobel_edge_detector" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>sobel_edge_detector(img: numpy.ndarray[(rows,cols),uint8]) -&gt; tuple</li>
<li>sobel_edge_detector(img: numpy.ndarray[(rows,cols),uint16]) -&gt; tuple</li>
<li>sobel_edge_detector(img: numpy.ndarray[(rows,cols),uint32]) -&gt; tuple</li>
<li>sobel_edge_detector(img: numpy.ndarray[(rows,cols),uint64]) -&gt; tuple</li>
<li>sobel_edge_detector(img: numpy.ndarray[(rows,cols),int8]) -&gt; tuple</li>
<li>sobel_edge_detector(img: numpy.ndarray[(rows,cols),int16]) -&gt; tuple</li>
<li>sobel_edge_detector(img: numpy.ndarray[(rows,cols),int32]) -&gt; tuple</li>
<li>sobel_edge_detector(img: numpy.ndarray[(rows,cols),int64]) -&gt; tuple</li>
<li>sobel_edge_detector(img: numpy.ndarray[(rows,cols),float32]) -&gt; tuple</li>
<li>sobel_edge_detector(img: numpy.ndarray[(rows,cols),float64]) -&gt; tuple</li>
</ol>
<p>Applies the sobel edge detector to the given input image and returns two gradient 
images in a tuple.  The first contains the x gradients and the second contains the 
y gradients of the image.</p>
</dd></dl>

<dl class="function">
<dt id="dlib.solve_structural_svm_problem">
<code class="descclassname">dlib.</code><code class="descname">solve_structural_svm_problem</code><span class="sig-paren">(</span><em>problem: object</em><span class="sig-paren">)</span> &rarr; dlib.vector<a class="headerlink" href="#dlib.solve_structural_svm_problem" title="Permalink to this definition">¶</a></dt>
<dd><p>This function solves a structural SVM problem and returns the weight vector    
that defines the solution.  See the example program python_examples/svm_struct.py    
for documentation about how to create a proper problem object.</p>
</dd></dl>

<dl class="class">
<dt id="dlib.sparse_ranking_pair">
<em class="property">class </em><code class="descclassname">dlib.</code><code class="descname">sparse_ranking_pair</code><a class="headerlink" href="#dlib.sparse_ranking_pair" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="dlib.sparse_ranking_pair.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: dlib.sparse_ranking_pair</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.sparse_ranking_pair.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.sparse_ranking_pair.nonrelevant">
<code class="descname">nonrelevant</code><a class="headerlink" href="#dlib.sparse_ranking_pair.nonrelevant" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.sparse_ranking_pair.relevant">
<code class="descname">relevant</code><a class="headerlink" href="#dlib.sparse_ranking_pair.relevant" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="dlib.sparse_ranking_pairs">
<em class="property">class </em><code class="descclassname">dlib.</code><code class="descname">sparse_ranking_pairs</code><a class="headerlink" href="#dlib.sparse_ranking_pairs" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="dlib.sparse_ranking_pairs.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.sparse_ranking_pairs.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: dlib.sparse_ranking_pairs) -&gt; None</li>
<li>__init__(self: dlib.sparse_ranking_pairs, arg0: dlib.sparse_ranking_pairs) -&gt; None</li>
</ol>
<p>Copy constructor</p>
<ol class="arabic simple" start="3">
<li>__init__(self: dlib.sparse_ranking_pairs, arg0: iterable) -&gt; None</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="dlib.sparse_ranking_pairs.append">
<code class="descname">append</code><span class="sig-paren">(</span><em>self: dlib.sparse_ranking_pairs</em>, <em>x: dlib.sparse_ranking_pair</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.sparse_ranking_pairs.append" title="Permalink to this definition">¶</a></dt>
<dd><p>Add an item to the end of the list</p>
</dd></dl>

<dl class="method">
<dt id="dlib.sparse_ranking_pairs.clear">
<code class="descname">clear</code><span class="sig-paren">(</span><em>self: dlib.sparse_ranking_pairs</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.sparse_ranking_pairs.clear" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dlib.sparse_ranking_pairs.count">
<code class="descname">count</code><span class="sig-paren">(</span><em>self: dlib.sparse_ranking_pairs</em>, <em>x: dlib.sparse_ranking_pair</em><span class="sig-paren">)</span> &rarr; int<a class="headerlink" href="#dlib.sparse_ranking_pairs.count" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of times <code class="docutils literal"><span class="pre">x</span></code> appears in the list</p>
</dd></dl>

<dl class="method">
<dt id="dlib.sparse_ranking_pairs.extend">
<code class="descname">extend</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.sparse_ranking_pairs.extend" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>extend(self: dlib.sparse_ranking_pairs, L: dlib.sparse_ranking_pairs) -&gt; None</li>
</ol>
<p>Extend the list by appending all the items in the given list</p>
<ol class="arabic simple" start="2">
<li>extend(self: dlib.sparse_ranking_pairs, arg0: list) -&gt; None</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="dlib.sparse_ranking_pairs.insert">
<code class="descname">insert</code><span class="sig-paren">(</span><em>self: dlib.sparse_ranking_pairs</em>, <em>i: int</em>, <em>x: dlib.sparse_ranking_pair</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.sparse_ranking_pairs.insert" title="Permalink to this definition">¶</a></dt>
<dd><p>Insert an item at a given position.</p>
</dd></dl>

<dl class="method">
<dt id="dlib.sparse_ranking_pairs.pop">
<code class="descname">pop</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.sparse_ranking_pairs.pop" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>pop(self: dlib.sparse_ranking_pairs) -&gt; dlib.sparse_ranking_pair</li>
</ol>
<p>Remove and return the last item</p>
<ol class="arabic simple" start="2">
<li>pop(self: dlib.sparse_ranking_pairs, i: int) -&gt; dlib.sparse_ranking_pair</li>
</ol>
<p>Remove and return the item at index <code class="docutils literal"><span class="pre">i</span></code></p>
</dd></dl>

<dl class="method">
<dt id="dlib.sparse_ranking_pairs.remove">
<code class="descname">remove</code><span class="sig-paren">(</span><em>self: dlib.sparse_ranking_pairs</em>, <em>x: dlib.sparse_ranking_pair</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.sparse_ranking_pairs.remove" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove the first item from the list whose value is x. It is an error if there is no such item.</p>
</dd></dl>

<dl class="method">
<dt id="dlib.sparse_ranking_pairs.resize">
<code class="descname">resize</code><span class="sig-paren">(</span><em>self: dlib.sparse_ranking_pairs</em>, <em>arg0: int</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.sparse_ranking_pairs.resize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="dlib.sparse_vector">
<em class="property">class </em><code class="descclassname">dlib.</code><code class="descname">sparse_vector</code><a class="headerlink" href="#dlib.sparse_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>This object represents the mathematical idea of a sparse column vector.  It is    
simply an array of dlib.pair objects, each representing an index/value pair in    
the vector.  Any elements of the vector which are missing are implicitly set to    
zero.</p>
<p>Unless otherwise noted, any routines taking a sparse_vector assume the sparse    
vector is sorted and has unique elements.  That is, the index values of the    
pairs in a sparse_vector should be listed in increasing order and there should    
not be duplicates.  However, some functions work with &#8220;unsorted&#8221; sparse    
vectors.  These are dlib.sparse_vector objects that have either duplicate    
entries or non-sorted index values.  Note further that you can convert an    
&#8220;unsorted&#8221; sparse_vector into a properly sorted sparse vector by calling    
dlib.make_sparse_vector() on it.</p>
<dl class="method">
<dt id="dlib.sparse_vector.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.sparse_vector.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: dlib.sparse_vector) -&gt; None</li>
<li>__init__(self: dlib.sparse_vector, arg0: dlib.sparse_vector) -&gt; None</li>
</ol>
<p>Copy constructor</p>
<ol class="arabic simple" start="3">
<li>__init__(self: dlib.sparse_vector, arg0: iterable) -&gt; None</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="dlib.sparse_vector.append">
<code class="descname">append</code><span class="sig-paren">(</span><em>self: dlib.sparse_vector</em>, <em>x: dlib.pair</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.sparse_vector.append" title="Permalink to this definition">¶</a></dt>
<dd><p>Add an item to the end of the list</p>
</dd></dl>

<dl class="method">
<dt id="dlib.sparse_vector.clear">
<code class="descname">clear</code><span class="sig-paren">(</span><em>self: dlib.sparse_vector</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.sparse_vector.clear" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dlib.sparse_vector.count">
<code class="descname">count</code><span class="sig-paren">(</span><em>self: dlib.sparse_vector</em>, <em>x: dlib.pair</em><span class="sig-paren">)</span> &rarr; int<a class="headerlink" href="#dlib.sparse_vector.count" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of times <code class="docutils literal"><span class="pre">x</span></code> appears in the list</p>
</dd></dl>

<dl class="method">
<dt id="dlib.sparse_vector.extend">
<code class="descname">extend</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.sparse_vector.extend" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>extend(self: dlib.sparse_vector, L: dlib.sparse_vector) -&gt; None</li>
</ol>
<p>Extend the list by appending all the items in the given list</p>
<ol class="arabic simple" start="2">
<li>extend(self: dlib.sparse_vector, arg0: list) -&gt; None</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="dlib.sparse_vector.insert">
<code class="descname">insert</code><span class="sig-paren">(</span><em>self: dlib.sparse_vector</em>, <em>i: int</em>, <em>x: dlib.pair</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.sparse_vector.insert" title="Permalink to this definition">¶</a></dt>
<dd><p>Insert an item at a given position.</p>
</dd></dl>

<dl class="method">
<dt id="dlib.sparse_vector.pop">
<code class="descname">pop</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.sparse_vector.pop" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>pop(self: dlib.sparse_vector) -&gt; dlib.pair</li>
</ol>
<p>Remove and return the last item</p>
<ol class="arabic simple" start="2">
<li>pop(self: dlib.sparse_vector, i: int) -&gt; dlib.pair</li>
</ol>
<p>Remove and return the item at index <code class="docutils literal"><span class="pre">i</span></code></p>
</dd></dl>

<dl class="method">
<dt id="dlib.sparse_vector.remove">
<code class="descname">remove</code><span class="sig-paren">(</span><em>self: dlib.sparse_vector</em>, <em>x: dlib.pair</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.sparse_vector.remove" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove the first item from the list whose value is x. It is an error if there is no such item.</p>
</dd></dl>

<dl class="method">
<dt id="dlib.sparse_vector.resize">
<code class="descname">resize</code><span class="sig-paren">(</span><em>self: dlib.sparse_vector</em>, <em>arg0: int</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.sparse_vector.resize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="dlib.sparse_vectors">
<em class="property">class </em><code class="descclassname">dlib.</code><code class="descname">sparse_vectors</code><a class="headerlink" href="#dlib.sparse_vectors" title="Permalink to this definition">¶</a></dt>
<dd><p>This object is an array of sparse_vector objects.</p>
<dl class="method">
<dt id="dlib.sparse_vectors.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.sparse_vectors.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: dlib.sparse_vectors) -&gt; None</li>
<li>__init__(self: dlib.sparse_vectors, arg0: dlib.sparse_vectors) -&gt; None</li>
</ol>
<p>Copy constructor</p>
<ol class="arabic simple" start="3">
<li>__init__(self: dlib.sparse_vectors, arg0: iterable) -&gt; None</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="dlib.sparse_vectors.append">
<code class="descname">append</code><span class="sig-paren">(</span><em>self: dlib.sparse_vectors</em>, <em>x: dlib.sparse_vector</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.sparse_vectors.append" title="Permalink to this definition">¶</a></dt>
<dd><p>Add an item to the end of the list</p>
</dd></dl>

<dl class="method">
<dt id="dlib.sparse_vectors.clear">
<code class="descname">clear</code><span class="sig-paren">(</span><em>self: dlib.sparse_vectors</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.sparse_vectors.clear" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dlib.sparse_vectors.count">
<code class="descname">count</code><span class="sig-paren">(</span><em>self: dlib.sparse_vectors</em>, <em>x: dlib.sparse_vector</em><span class="sig-paren">)</span> &rarr; int<a class="headerlink" href="#dlib.sparse_vectors.count" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of times <code class="docutils literal"><span class="pre">x</span></code> appears in the list</p>
</dd></dl>

<dl class="method">
<dt id="dlib.sparse_vectors.extend">
<code class="descname">extend</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.sparse_vectors.extend" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>extend(self: dlib.sparse_vectors, L: dlib.sparse_vectors) -&gt; None</li>
</ol>
<p>Extend the list by appending all the items in the given list</p>
<ol class="arabic simple" start="2">
<li>extend(self: dlib.sparse_vectors, arg0: list) -&gt; None</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="dlib.sparse_vectors.insert">
<code class="descname">insert</code><span class="sig-paren">(</span><em>self: dlib.sparse_vectors</em>, <em>i: int</em>, <em>x: dlib.sparse_vector</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.sparse_vectors.insert" title="Permalink to this definition">¶</a></dt>
<dd><p>Insert an item at a given position.</p>
</dd></dl>

<dl class="method">
<dt id="dlib.sparse_vectors.pop">
<code class="descname">pop</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.sparse_vectors.pop" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>pop(self: dlib.sparse_vectors) -&gt; dlib.sparse_vector</li>
</ol>
<p>Remove and return the last item</p>
<ol class="arabic simple" start="2">
<li>pop(self: dlib.sparse_vectors, i: int) -&gt; dlib.sparse_vector</li>
</ol>
<p>Remove and return the item at index <code class="docutils literal"><span class="pre">i</span></code></p>
</dd></dl>

<dl class="method">
<dt id="dlib.sparse_vectors.remove">
<code class="descname">remove</code><span class="sig-paren">(</span><em>self: dlib.sparse_vectors</em>, <em>x: dlib.sparse_vector</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.sparse_vectors.remove" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove the first item from the list whose value is x. It is an error if there is no such item.</p>
</dd></dl>

<dl class="method">
<dt id="dlib.sparse_vectors.resize">
<code class="descname">resize</code><span class="sig-paren">(</span><em>self: dlib.sparse_vectors</em>, <em>arg0: int</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.sparse_vectors.resize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="dlib.sparse_vectorss">
<em class="property">class </em><code class="descclassname">dlib.</code><code class="descname">sparse_vectorss</code><a class="headerlink" href="#dlib.sparse_vectorss" title="Permalink to this definition">¶</a></dt>
<dd><p>This object is an array of arrays of sparse_vector objects.</p>
<dl class="method">
<dt id="dlib.sparse_vectorss.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.sparse_vectorss.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: dlib.sparse_vectorss) -&gt; None</li>
<li>__init__(self: dlib.sparse_vectorss, arg0: dlib.sparse_vectorss) -&gt; None</li>
</ol>
<p>Copy constructor</p>
<ol class="arabic simple" start="3">
<li>__init__(self: dlib.sparse_vectorss, arg0: iterable) -&gt; None</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="dlib.sparse_vectorss.append">
<code class="descname">append</code><span class="sig-paren">(</span><em>self: dlib.sparse_vectorss</em>, <em>x: dlib.sparse_vectors</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.sparse_vectorss.append" title="Permalink to this definition">¶</a></dt>
<dd><p>Add an item to the end of the list</p>
</dd></dl>

<dl class="method">
<dt id="dlib.sparse_vectorss.clear">
<code class="descname">clear</code><span class="sig-paren">(</span><em>self: dlib.sparse_vectorss</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.sparse_vectorss.clear" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dlib.sparse_vectorss.count">
<code class="descname">count</code><span class="sig-paren">(</span><em>self: dlib.sparse_vectorss</em>, <em>x: dlib.sparse_vectors</em><span class="sig-paren">)</span> &rarr; int<a class="headerlink" href="#dlib.sparse_vectorss.count" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of times <code class="docutils literal"><span class="pre">x</span></code> appears in the list</p>
</dd></dl>

<dl class="method">
<dt id="dlib.sparse_vectorss.extend">
<code class="descname">extend</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.sparse_vectorss.extend" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>extend(self: dlib.sparse_vectorss, L: dlib.sparse_vectorss) -&gt; None</li>
</ol>
<p>Extend the list by appending all the items in the given list</p>
<ol class="arabic simple" start="2">
<li>extend(self: dlib.sparse_vectorss, arg0: list) -&gt; None</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="dlib.sparse_vectorss.insert">
<code class="descname">insert</code><span class="sig-paren">(</span><em>self: dlib.sparse_vectorss</em>, <em>i: int</em>, <em>x: dlib.sparse_vectors</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.sparse_vectorss.insert" title="Permalink to this definition">¶</a></dt>
<dd><p>Insert an item at a given position.</p>
</dd></dl>

<dl class="method">
<dt id="dlib.sparse_vectorss.pop">
<code class="descname">pop</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.sparse_vectorss.pop" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>pop(self: dlib.sparse_vectorss) -&gt; dlib.sparse_vectors</li>
</ol>
<p>Remove and return the last item</p>
<ol class="arabic simple" start="2">
<li>pop(self: dlib.sparse_vectorss, i: int) -&gt; dlib.sparse_vectors</li>
</ol>
<p>Remove and return the item at index <code class="docutils literal"><span class="pre">i</span></code></p>
</dd></dl>

<dl class="method">
<dt id="dlib.sparse_vectorss.remove">
<code class="descname">remove</code><span class="sig-paren">(</span><em>self: dlib.sparse_vectorss</em>, <em>x: dlib.sparse_vectors</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.sparse_vectorss.remove" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove the first item from the list whose value is x. It is an error if there is no such item.</p>
</dd></dl>

<dl class="method">
<dt id="dlib.sparse_vectorss.resize">
<code class="descname">resize</code><span class="sig-paren">(</span><em>self: dlib.sparse_vectorss</em>, <em>arg0: int</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.sparse_vectorss.resize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="dlib.spatially_filter_image">
<code class="descclassname">dlib.</code><code class="descname">spatially_filter_image</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.spatially_filter_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>spatially_filter_image(img: numpy.ndarray[(rows,cols),uint8], filter: numpy.ndarray[(rows,cols),uint8]) -&gt; tuple</li>
<li>spatially_filter_image(img: numpy.ndarray[(rows,cols),float32], filter: numpy.ndarray[(rows,cols),float32]) -&gt; tuple</li>
<li>spatially_filter_image(img: numpy.ndarray[(rows,cols),float64], filter: numpy.ndarray[(rows,cols),float64]) -&gt; tuple</li>
</ol>
<dl class="docutils">
<dt>requires </dt>
<dd><ul class="first last simple">
<li>filter.size != 0</li>
</ul>
</dd>
<dt>ensures </dt>
<dd><ul class="first last">
<li><p class="first">Applies the given spatial filter to img and returns the result (i.e. we  
cross-correlate img with filter).  We also return a rectangle which 
indicates what pixels in the returned image are considered non-border pixels 
and therefore contain output from the filter.  E.g.</p>
<blockquote>
<div><ul class="simple">
<li>filtered_img,rect = spatially_filter_image(img, filter)</li>
</ul>
</div></blockquote>
<p>would give you the filtered image and the rectangle in question.  Since the 
returned image has the same shape as img we fill the border pixels by setting 
them to 0.</p>
</li>
<li><p class="first">The filter is applied such that it&#8217;s centered over the pixel it writes its 
output into.  For centering purposes, we consider the center element of the 
filter to be filter[filter.shape[0]/2,filter.shape[1]/2].  This means that 
the filter that writes its output to a pixel at location point(c,r) and is W 
by H (width by height) pixels in size operates on exactly the pixels in the 
rectangle centered_rect(point(c,r),W,H) within img.</p>
</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="dlib.spatially_filter_image_separable">
<code class="descclassname">dlib.</code><code class="descname">spatially_filter_image_separable</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.spatially_filter_image_separable" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>spatially_filter_image_separable(img: numpy.ndarray[(rows,cols),uint8], row_filter: numpy.ndarray[uint8], col_filter: numpy.ndarray[uint8]) -&gt; tuple</li>
<li>spatially_filter_image_separable(img: numpy.ndarray[(rows,cols),float32], row_filter: numpy.ndarray[float32], col_filter: numpy.ndarray[float32]) -&gt; tuple</li>
<li>spatially_filter_image_separable(img: numpy.ndarray[(rows,cols),float64], row_filter: numpy.ndarray[float64], col_filter: numpy.ndarray[float64]) -&gt; tuple</li>
</ol>
<dl class="docutils">
<dt>requires </dt>
<dd><ul class="first last simple">
<li>row_filter.size != 0</li>
<li>col_filter.size != 0</li>
<li>row_filter and col_filter are both either row or column vectors.</li>
</ul>
</dd>
<dt>ensures </dt>
<dd><ul class="first last">
<li><p class="first">Applies the given separable spatial filter to img and returns the result 
(i.e. we cross-correlate img with the filters).  In particular, calling this 
function has the same effect as calling the regular spatially_filter_image() 
routine with a filter, FILT, defined as follows:</p>
<blockquote>
<div><ul class="simple">
<li>FILT(r,c) == col_filter(r)*row_filter(c)</li>
</ul>
</div></blockquote>
<p>Therefore, the return value of this routine is the same as if it were 
implemented as:</p>
<blockquote>
<div><p>return spatially_filter_image(img, FILT)</p>
</div></blockquote>
<p>Except that this version should be faster for separable filters.</p>
</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="dlib.sub_image">
<code class="descclassname">dlib.</code><code class="descname">sub_image</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.sub_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>sub_image(img: array, rect: dlib.rectangle) -&gt; array</li>
</ol>
<p>Returns a new numpy array that references the sub window in img defined by rect. 
If rect is larger than img then rect is cropped so that it does not go outside img. 
Therefore, this routine is equivalent to performing:</p>
<blockquote>
<div>win = get_rect(img).intersect(rect) 
subimg = img[win.top():win.bottom()-1,win.left():win.right()-1]</div></blockquote>
<ol class="arabic simple" start="2">
<li>sub_image(image_and_rect_tuple: tuple) -&gt; array</li>
</ol>
<p>Performs: return sub_image(image_and_rect_tuple[0], image_and_rect_tuple[1])</p>
</dd></dl>

<dl class="function">
<dt id="dlib.suppress_non_maximum_edges">
<code class="descclassname">dlib.</code><code class="descname">suppress_non_maximum_edges</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.suppress_non_maximum_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>suppress_non_maximum_edges(horz: numpy.ndarray[(rows,cols),float32], vert: numpy.ndarray[(rows,cols),float32]) -&gt; numpy.ndarray[(rows,cols),float32]</li>
</ol>
<dl class="docutils">
<dt>requires </dt>
<dd><ul class="first last simple">
<li>The two input images have the same dimensions.</li>
</ul>
</dd>
<dt>ensures </dt>
<dd><ul class="first last">
<li><p class="first">Returns an image, of the same dimensions as the input.  Each element in this 
image holds the edge strength at that location.  Moreover, edge pixels that are not  
local maximizers have been set to 0.</p>
</li>
<li><p class="first">let edge_strength(r,c) == sqrt(pow(horz[r][c],2) + pow(vert[r][c],2)) 
(i.e. The Euclidean norm of the gradient)</p>
</li>
<li><p class="first">let OUT denote the returned image.</p>
</li>
<li><dl class="first docutils">
<dt>for all valid r and c: </dt>
<dd><ul class="first last">
<li><p class="first">if (edge_strength(r,c) is at a maximum with respect to its 2 neighboring 
pixels along the line indicated by the image gradient vector (horz[r][c],vert[r][c])) then</p>
<blockquote>
<div><ul class="simple">
<li>OUT[r][c] == edge_strength(r,c)</li>
</ul>
</div></blockquote>
</li>
<li><dl class="first docutils">
<dt>else </dt>
<dd><ul class="first last simple">
<li>OUT[r][c] == 0</li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li>suppress_non_maximum_edges(horz_and_vert_gradients: tuple) -&gt; numpy.ndarray[(rows,cols),float32]</li>
</ol>
<p>Performs: return suppress_non_maximum_edges(horz_and_vert_gradients[0], horz_and_vert_gradients[1])</p>
</dd></dl>

<dl class="class">
<dt id="dlib.svm_c_trainer_histogram_intersection">
<em class="property">class </em><code class="descclassname">dlib.</code><code class="descname">svm_c_trainer_histogram_intersection</code><a class="headerlink" href="#dlib.svm_c_trainer_histogram_intersection" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="dlib.svm_c_trainer_histogram_intersection.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: dlib.svm_c_trainer_histogram_intersection</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.svm_c_trainer_histogram_intersection.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.svm_c_trainer_histogram_intersection.c_class1">
<code class="descname">c_class1</code><a class="headerlink" href="#dlib.svm_c_trainer_histogram_intersection.c_class1" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.svm_c_trainer_histogram_intersection.c_class2">
<code class="descname">c_class2</code><a class="headerlink" href="#dlib.svm_c_trainer_histogram_intersection.c_class2" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.svm_c_trainer_histogram_intersection.cache_size">
<code class="descname">cache_size</code><a class="headerlink" href="#dlib.svm_c_trainer_histogram_intersection.cache_size" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.svm_c_trainer_histogram_intersection.epsilon">
<code class="descname">epsilon</code><a class="headerlink" href="#dlib.svm_c_trainer_histogram_intersection.epsilon" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dlib.svm_c_trainer_histogram_intersection.set_c">
<code class="descname">set_c</code><span class="sig-paren">(</span><em>self: dlib.svm_c_trainer_histogram_intersection</em>, <em>arg0: float</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.svm_c_trainer_histogram_intersection.set_c" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dlib.svm_c_trainer_histogram_intersection.train">
<code class="descname">train</code><span class="sig-paren">(</span><em>self: dlib.svm_c_trainer_histogram_intersection</em>, <em>arg0: dlib.vectors</em>, <em>arg1: dlib.array</em><span class="sig-paren">)</span> &rarr; dlib._decision_function_histogram_intersection<a class="headerlink" href="#dlib.svm_c_trainer_histogram_intersection.train" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="dlib.svm_c_trainer_linear">
<em class="property">class </em><code class="descclassname">dlib.</code><code class="descname">svm_c_trainer_linear</code><a class="headerlink" href="#dlib.svm_c_trainer_linear" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="dlib.svm_c_trainer_linear.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: dlib.svm_c_trainer_linear</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.svm_c_trainer_linear.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dlib.svm_c_trainer_linear.be_quiet">
<code class="descname">be_quiet</code><span class="sig-paren">(</span><em>self: dlib.svm_c_trainer_linear</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.svm_c_trainer_linear.be_quiet" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dlib.svm_c_trainer_linear.be_verbose">
<code class="descname">be_verbose</code><span class="sig-paren">(</span><em>self: dlib.svm_c_trainer_linear</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.svm_c_trainer_linear.be_verbose" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.svm_c_trainer_linear.c_class1">
<code class="descname">c_class1</code><a class="headerlink" href="#dlib.svm_c_trainer_linear.c_class1" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.svm_c_trainer_linear.c_class2">
<code class="descname">c_class2</code><a class="headerlink" href="#dlib.svm_c_trainer_linear.c_class2" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.svm_c_trainer_linear.epsilon">
<code class="descname">epsilon</code><a class="headerlink" href="#dlib.svm_c_trainer_linear.epsilon" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.svm_c_trainer_linear.force_last_weight_to_1">
<code class="descname">force_last_weight_to_1</code><a class="headerlink" href="#dlib.svm_c_trainer_linear.force_last_weight_to_1" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.svm_c_trainer_linear.has_prior">
<code class="descname">has_prior</code><a class="headerlink" href="#dlib.svm_c_trainer_linear.has_prior" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.svm_c_trainer_linear.learns_nonnegative_weights">
<code class="descname">learns_nonnegative_weights</code><a class="headerlink" href="#dlib.svm_c_trainer_linear.learns_nonnegative_weights" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.svm_c_trainer_linear.max_iterations">
<code class="descname">max_iterations</code><a class="headerlink" href="#dlib.svm_c_trainer_linear.max_iterations" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dlib.svm_c_trainer_linear.set_c">
<code class="descname">set_c</code><span class="sig-paren">(</span><em>self: dlib.svm_c_trainer_linear</em>, <em>arg0: float</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.svm_c_trainer_linear.set_c" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dlib.svm_c_trainer_linear.set_prior">
<code class="descname">set_prior</code><span class="sig-paren">(</span><em>self: dlib.svm_c_trainer_linear</em>, <em>arg0: dlib._decision_function_linear</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.svm_c_trainer_linear.set_prior" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dlib.svm_c_trainer_linear.train">
<code class="descname">train</code><span class="sig-paren">(</span><em>self: dlib.svm_c_trainer_linear</em>, <em>arg0: dlib.vectors</em>, <em>arg1: dlib.array</em><span class="sig-paren">)</span> &rarr; dlib._decision_function_linear<a class="headerlink" href="#dlib.svm_c_trainer_linear.train" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="dlib.svm_c_trainer_radial_basis">
<em class="property">class </em><code class="descclassname">dlib.</code><code class="descname">svm_c_trainer_radial_basis</code><a class="headerlink" href="#dlib.svm_c_trainer_radial_basis" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="dlib.svm_c_trainer_radial_basis.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: dlib.svm_c_trainer_radial_basis</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.svm_c_trainer_radial_basis.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.svm_c_trainer_radial_basis.c_class1">
<code class="descname">c_class1</code><a class="headerlink" href="#dlib.svm_c_trainer_radial_basis.c_class1" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.svm_c_trainer_radial_basis.c_class2">
<code class="descname">c_class2</code><a class="headerlink" href="#dlib.svm_c_trainer_radial_basis.c_class2" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.svm_c_trainer_radial_basis.cache_size">
<code class="descname">cache_size</code><a class="headerlink" href="#dlib.svm_c_trainer_radial_basis.cache_size" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.svm_c_trainer_radial_basis.epsilon">
<code class="descname">epsilon</code><a class="headerlink" href="#dlib.svm_c_trainer_radial_basis.epsilon" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.svm_c_trainer_radial_basis.gamma">
<code class="descname">gamma</code><a class="headerlink" href="#dlib.svm_c_trainer_radial_basis.gamma" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dlib.svm_c_trainer_radial_basis.set_c">
<code class="descname">set_c</code><span class="sig-paren">(</span><em>self: dlib.svm_c_trainer_radial_basis</em>, <em>arg0: float</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.svm_c_trainer_radial_basis.set_c" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dlib.svm_c_trainer_radial_basis.train">
<code class="descname">train</code><span class="sig-paren">(</span><em>self: dlib.svm_c_trainer_radial_basis</em>, <em>arg0: dlib.vectors</em>, <em>arg1: dlib.array</em><span class="sig-paren">)</span> &rarr; dlib._decision_function_radial_basis<a class="headerlink" href="#dlib.svm_c_trainer_radial_basis.train" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="dlib.svm_c_trainer_sparse_histogram_intersection">
<em class="property">class </em><code class="descclassname">dlib.</code><code class="descname">svm_c_trainer_sparse_histogram_intersection</code><a class="headerlink" href="#dlib.svm_c_trainer_sparse_histogram_intersection" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="dlib.svm_c_trainer_sparse_histogram_intersection.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: dlib.svm_c_trainer_sparse_histogram_intersection</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.svm_c_trainer_sparse_histogram_intersection.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.svm_c_trainer_sparse_histogram_intersection.c_class1">
<code class="descname">c_class1</code><a class="headerlink" href="#dlib.svm_c_trainer_sparse_histogram_intersection.c_class1" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.svm_c_trainer_sparse_histogram_intersection.c_class2">
<code class="descname">c_class2</code><a class="headerlink" href="#dlib.svm_c_trainer_sparse_histogram_intersection.c_class2" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.svm_c_trainer_sparse_histogram_intersection.cache_size">
<code class="descname">cache_size</code><a class="headerlink" href="#dlib.svm_c_trainer_sparse_histogram_intersection.cache_size" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.svm_c_trainer_sparse_histogram_intersection.epsilon">
<code class="descname">epsilon</code><a class="headerlink" href="#dlib.svm_c_trainer_sparse_histogram_intersection.epsilon" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dlib.svm_c_trainer_sparse_histogram_intersection.set_c">
<code class="descname">set_c</code><span class="sig-paren">(</span><em>self: dlib.svm_c_trainer_sparse_histogram_intersection</em>, <em>arg0: float</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.svm_c_trainer_sparse_histogram_intersection.set_c" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dlib.svm_c_trainer_sparse_histogram_intersection.train">
<code class="descname">train</code><span class="sig-paren">(</span><em>self: dlib.svm_c_trainer_sparse_histogram_intersection</em>, <em>arg0: dlib.sparse_vectors</em>, <em>arg1: dlib.array</em><span class="sig-paren">)</span> &rarr; dlib._decision_function_sparse_histogram_intersection<a class="headerlink" href="#dlib.svm_c_trainer_sparse_histogram_intersection.train" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="dlib.svm_c_trainer_sparse_linear">
<em class="property">class </em><code class="descclassname">dlib.</code><code class="descname">svm_c_trainer_sparse_linear</code><a class="headerlink" href="#dlib.svm_c_trainer_sparse_linear" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="dlib.svm_c_trainer_sparse_linear.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: dlib.svm_c_trainer_sparse_linear</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.svm_c_trainer_sparse_linear.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dlib.svm_c_trainer_sparse_linear.be_quiet">
<code class="descname">be_quiet</code><span class="sig-paren">(</span><em>self: dlib.svm_c_trainer_sparse_linear</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.svm_c_trainer_sparse_linear.be_quiet" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dlib.svm_c_trainer_sparse_linear.be_verbose">
<code class="descname">be_verbose</code><span class="sig-paren">(</span><em>self: dlib.svm_c_trainer_sparse_linear</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.svm_c_trainer_sparse_linear.be_verbose" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.svm_c_trainer_sparse_linear.c_class1">
<code class="descname">c_class1</code><a class="headerlink" href="#dlib.svm_c_trainer_sparse_linear.c_class1" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.svm_c_trainer_sparse_linear.c_class2">
<code class="descname">c_class2</code><a class="headerlink" href="#dlib.svm_c_trainer_sparse_linear.c_class2" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.svm_c_trainer_sparse_linear.epsilon">
<code class="descname">epsilon</code><a class="headerlink" href="#dlib.svm_c_trainer_sparse_linear.epsilon" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.svm_c_trainer_sparse_linear.force_last_weight_to_1">
<code class="descname">force_last_weight_to_1</code><a class="headerlink" href="#dlib.svm_c_trainer_sparse_linear.force_last_weight_to_1" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.svm_c_trainer_sparse_linear.has_prior">
<code class="descname">has_prior</code><a class="headerlink" href="#dlib.svm_c_trainer_sparse_linear.has_prior" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.svm_c_trainer_sparse_linear.learns_nonnegative_weights">
<code class="descname">learns_nonnegative_weights</code><a class="headerlink" href="#dlib.svm_c_trainer_sparse_linear.learns_nonnegative_weights" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.svm_c_trainer_sparse_linear.max_iterations">
<code class="descname">max_iterations</code><a class="headerlink" href="#dlib.svm_c_trainer_sparse_linear.max_iterations" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dlib.svm_c_trainer_sparse_linear.set_c">
<code class="descname">set_c</code><span class="sig-paren">(</span><em>self: dlib.svm_c_trainer_sparse_linear</em>, <em>arg0: float</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.svm_c_trainer_sparse_linear.set_c" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dlib.svm_c_trainer_sparse_linear.set_prior">
<code class="descname">set_prior</code><span class="sig-paren">(</span><em>self: dlib.svm_c_trainer_sparse_linear</em>, <em>arg0: dlib._decision_function_sparse_linear</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.svm_c_trainer_sparse_linear.set_prior" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dlib.svm_c_trainer_sparse_linear.train">
<code class="descname">train</code><span class="sig-paren">(</span><em>self: dlib.svm_c_trainer_sparse_linear</em>, <em>arg0: dlib.sparse_vectors</em>, <em>arg1: dlib.array</em><span class="sig-paren">)</span> &rarr; dlib._decision_function_sparse_linear<a class="headerlink" href="#dlib.svm_c_trainer_sparse_linear.train" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="dlib.svm_c_trainer_sparse_radial_basis">
<em class="property">class </em><code class="descclassname">dlib.</code><code class="descname">svm_c_trainer_sparse_radial_basis</code><a class="headerlink" href="#dlib.svm_c_trainer_sparse_radial_basis" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="dlib.svm_c_trainer_sparse_radial_basis.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: dlib.svm_c_trainer_sparse_radial_basis</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.svm_c_trainer_sparse_radial_basis.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.svm_c_trainer_sparse_radial_basis.c_class1">
<code class="descname">c_class1</code><a class="headerlink" href="#dlib.svm_c_trainer_sparse_radial_basis.c_class1" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.svm_c_trainer_sparse_radial_basis.c_class2">
<code class="descname">c_class2</code><a class="headerlink" href="#dlib.svm_c_trainer_sparse_radial_basis.c_class2" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.svm_c_trainer_sparse_radial_basis.cache_size">
<code class="descname">cache_size</code><a class="headerlink" href="#dlib.svm_c_trainer_sparse_radial_basis.cache_size" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.svm_c_trainer_sparse_radial_basis.epsilon">
<code class="descname">epsilon</code><a class="headerlink" href="#dlib.svm_c_trainer_sparse_radial_basis.epsilon" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.svm_c_trainer_sparse_radial_basis.gamma">
<code class="descname">gamma</code><a class="headerlink" href="#dlib.svm_c_trainer_sparse_radial_basis.gamma" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dlib.svm_c_trainer_sparse_radial_basis.set_c">
<code class="descname">set_c</code><span class="sig-paren">(</span><em>self: dlib.svm_c_trainer_sparse_radial_basis</em>, <em>arg0: float</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.svm_c_trainer_sparse_radial_basis.set_c" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dlib.svm_c_trainer_sparse_radial_basis.train">
<code class="descname">train</code><span class="sig-paren">(</span><em>self: dlib.svm_c_trainer_sparse_radial_basis</em>, <em>arg0: dlib.sparse_vectors</em>, <em>arg1: dlib.array</em><span class="sig-paren">)</span> &rarr; dlib._decision_function_sparse_radial_basis<a class="headerlink" href="#dlib.svm_c_trainer_sparse_radial_basis.train" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="dlib.svm_rank_trainer">
<em class="property">class </em><code class="descclassname">dlib.</code><code class="descname">svm_rank_trainer</code><a class="headerlink" href="#dlib.svm_rank_trainer" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="dlib.svm_rank_trainer.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: dlib.svm_rank_trainer</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.svm_rank_trainer.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dlib.svm_rank_trainer.be_quiet">
<code class="descname">be_quiet</code><span class="sig-paren">(</span><em>self: dlib.svm_rank_trainer</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.svm_rank_trainer.be_quiet" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dlib.svm_rank_trainer.be_verbose">
<code class="descname">be_verbose</code><span class="sig-paren">(</span><em>self: dlib.svm_rank_trainer</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.svm_rank_trainer.be_verbose" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.svm_rank_trainer.c">
<code class="descname">c</code><a class="headerlink" href="#dlib.svm_rank_trainer.c" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.svm_rank_trainer.epsilon">
<code class="descname">epsilon</code><a class="headerlink" href="#dlib.svm_rank_trainer.epsilon" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.svm_rank_trainer.force_last_weight_to_1">
<code class="descname">force_last_weight_to_1</code><a class="headerlink" href="#dlib.svm_rank_trainer.force_last_weight_to_1" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.svm_rank_trainer.has_prior">
<code class="descname">has_prior</code><a class="headerlink" href="#dlib.svm_rank_trainer.has_prior" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.svm_rank_trainer.learns_nonnegative_weights">
<code class="descname">learns_nonnegative_weights</code><a class="headerlink" href="#dlib.svm_rank_trainer.learns_nonnegative_weights" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.svm_rank_trainer.max_iterations">
<code class="descname">max_iterations</code><a class="headerlink" href="#dlib.svm_rank_trainer.max_iterations" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dlib.svm_rank_trainer.set_prior">
<code class="descname">set_prior</code><span class="sig-paren">(</span><em>self: dlib.svm_rank_trainer</em>, <em>arg0: dlib::decision_function&lt;dlib::linear_kernel&lt;dlib::matrix&lt;double</em>, <em>0l</em>, <em>1l</em>, <em>dlib::memory_manager_stateless_kernel_1&lt;char&gt;</em>, <em>dlib::row_major_layout&gt; &gt; &gt;</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.svm_rank_trainer.set_prior" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dlib.svm_rank_trainer.train">
<code class="descname">train</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.svm_rank_trainer.train" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>train(self: dlib.svm_rank_trainer, arg0: dlib.ranking_pair) -&gt; dlib::decision_function&lt;dlib::linear_kernel&lt;dlib::matrix&lt;double, 0l, 1l, dlib::memory_manager_stateless_kernel_1&lt;char&gt;, dlib::row_major_layout&gt; &gt; &gt;</li>
<li>train(self: dlib.svm_rank_trainer, arg0: dlib.ranking_pairs) -&gt; dlib::decision_function&lt;dlib::linear_kernel&lt;dlib::matrix&lt;double, 0l, 1l, dlib::memory_manager_stateless_kernel_1&lt;char&gt;, dlib::row_major_layout&gt; &gt; &gt;</li>
</ol>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="dlib.svm_rank_trainer_sparse">
<em class="property">class </em><code class="descclassname">dlib.</code><code class="descname">svm_rank_trainer_sparse</code><a class="headerlink" href="#dlib.svm_rank_trainer_sparse" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="dlib.svm_rank_trainer_sparse.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: dlib.svm_rank_trainer_sparse</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.svm_rank_trainer_sparse.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dlib.svm_rank_trainer_sparse.be_quiet">
<code class="descname">be_quiet</code><span class="sig-paren">(</span><em>self: dlib.svm_rank_trainer_sparse</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.svm_rank_trainer_sparse.be_quiet" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dlib.svm_rank_trainer_sparse.be_verbose">
<code class="descname">be_verbose</code><span class="sig-paren">(</span><em>self: dlib.svm_rank_trainer_sparse</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.svm_rank_trainer_sparse.be_verbose" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.svm_rank_trainer_sparse.c">
<code class="descname">c</code><a class="headerlink" href="#dlib.svm_rank_trainer_sparse.c" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.svm_rank_trainer_sparse.epsilon">
<code class="descname">epsilon</code><a class="headerlink" href="#dlib.svm_rank_trainer_sparse.epsilon" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.svm_rank_trainer_sparse.force_last_weight_to_1">
<code class="descname">force_last_weight_to_1</code><a class="headerlink" href="#dlib.svm_rank_trainer_sparse.force_last_weight_to_1" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.svm_rank_trainer_sparse.has_prior">
<code class="descname">has_prior</code><a class="headerlink" href="#dlib.svm_rank_trainer_sparse.has_prior" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.svm_rank_trainer_sparse.learns_nonnegative_weights">
<code class="descname">learns_nonnegative_weights</code><a class="headerlink" href="#dlib.svm_rank_trainer_sparse.learns_nonnegative_weights" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.svm_rank_trainer_sparse.max_iterations">
<code class="descname">max_iterations</code><a class="headerlink" href="#dlib.svm_rank_trainer_sparse.max_iterations" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dlib.svm_rank_trainer_sparse.set_prior">
<code class="descname">set_prior</code><span class="sig-paren">(</span><em>self: dlib.svm_rank_trainer_sparse</em>, <em>arg0: dlib::decision_function&lt;dlib::sparse_linear_kernel&lt;std::vector&lt;std::pair&lt;unsigned long</em>, <em>double&gt;</em>, <em>std::allocator&lt;std::pair&lt;unsigned long</em>, <em>double&gt; &gt; &gt; &gt; &gt;</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.svm_rank_trainer_sparse.set_prior" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dlib.svm_rank_trainer_sparse.train">
<code class="descname">train</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.svm_rank_trainer_sparse.train" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>train(self: dlib.svm_rank_trainer_sparse, arg0: dlib.sparse_ranking_pair) -&gt; dlib::decision_function&lt;dlib::sparse_linear_kernel&lt;std::vector&lt;std::pair&lt;unsigned long, double&gt;, std::allocator&lt;std::pair&lt;unsigned long, double&gt; &gt; &gt; &gt; &gt;</li>
<li>train(self: dlib.svm_rank_trainer_sparse, arg0: dlib.sparse_ranking_pairs) -&gt; dlib::decision_function&lt;dlib::sparse_linear_kernel&lt;std::vector&lt;std::pair&lt;unsigned long, double&gt;, std::allocator&lt;std::pair&lt;unsigned long, double&gt; &gt; &gt; &gt; &gt;</li>
</ol>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="dlib.test_binary_decision_function">
<code class="descclassname">dlib.</code><code class="descname">test_binary_decision_function</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.test_binary_decision_function" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>test_binary_decision_function(function: dlib._normalized_decision_function_radial_basis, samples: dlib.vectors, labels: dlib.array) -&gt; binary_test</li>
<li>test_binary_decision_function(function: dlib._normalized_decision_function_radial_basis, samples: numpy.ndarray[(rows,cols),float64], labels: numpy.ndarray[float64]) -&gt; binary_test</li>
<li>test_binary_decision_function(function: dlib._decision_function_linear, samples: dlib.vectors, labels: dlib.array) -&gt; binary_test</li>
<li>test_binary_decision_function(function: dlib._decision_function_sparse_linear, samples: dlib.sparse_vectors, labels: dlib.array) -&gt; binary_test</li>
<li>test_binary_decision_function(function: dlib._decision_function_radial_basis, samples: dlib.vectors, labels: dlib.array) -&gt; binary_test</li>
<li>test_binary_decision_function(function: dlib._decision_function_sparse_radial_basis, samples: dlib.sparse_vectors, labels: dlib.array) -&gt; binary_test</li>
<li>test_binary_decision_function(function: dlib._decision_function_polynomial, samples: dlib.vectors, labels: dlib.array) -&gt; binary_test</li>
<li>test_binary_decision_function(function: dlib._decision_function_sparse_polynomial, samples: dlib.sparse_vectors, labels: dlib.array) -&gt; binary_test</li>
<li>test_binary_decision_function(function: dlib._decision_function_histogram_intersection, samples: dlib.vectors, labels: dlib.array) -&gt; binary_test</li>
<li>test_binary_decision_function(function: dlib._decision_function_sparse_histogram_intersection, samples: dlib.sparse_vectors, labels: dlib.array) -&gt; binary_test</li>
<li>test_binary_decision_function(function: dlib._decision_function_sigmoid, samples: dlib.vectors, labels: dlib.array) -&gt; binary_test</li>
<li>test_binary_decision_function(function: dlib._decision_function_sparse_sigmoid, samples: dlib.sparse_vectors, labels: dlib.array) -&gt; binary_test</li>
</ol>
</dd></dl>

<dl class="function">
<dt id="dlib.test_ranking_function">
<code class="descclassname">dlib.</code><code class="descname">test_ranking_function</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.test_ranking_function" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>test_ranking_function(function: dlib._decision_function_linear, samples: dlib.ranking_pairs) -&gt; ranking_test</li>
<li>test_ranking_function(function: dlib._decision_function_sparse_linear, samples: dlib.sparse_ranking_pairs) -&gt; ranking_test</li>
<li>test_ranking_function(function: dlib._decision_function_linear, sample: dlib.ranking_pair) -&gt; ranking_test</li>
<li>test_ranking_function(function: dlib._decision_function_sparse_linear, sample: dlib.sparse_ranking_pair) -&gt; ranking_test</li>
</ol>
</dd></dl>

<dl class="function">
<dt id="dlib.test_regression_function">
<code class="descclassname">dlib.</code><code class="descname">test_regression_function</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.test_regression_function" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>test_regression_function(function: dlib._decision_function_linear, samples: dlib.vectors, targets: dlib.array) -&gt; regression_test</li>
<li>test_regression_function(function: dlib._decision_function_sparse_linear, samples: dlib.sparse_vectors, targets: dlib.array) -&gt; regression_test</li>
<li>test_regression_function(function: dlib._decision_function_radial_basis, samples: dlib.vectors, targets: dlib.array) -&gt; regression_test</li>
<li>test_regression_function(function: dlib._decision_function_sparse_radial_basis, samples: dlib.sparse_vectors, targets: dlib.array) -&gt; regression_test</li>
<li>test_regression_function(function: dlib._decision_function_histogram_intersection, samples: dlib.vectors, targets: dlib.array) -&gt; regression_test</li>
<li>test_regression_function(function: dlib._decision_function_sparse_histogram_intersection, samples: dlib.sparse_vectors, targets: dlib.array) -&gt; regression_test</li>
<li>test_regression_function(function: dlib._decision_function_sigmoid, samples: dlib.vectors, targets: dlib.array) -&gt; regression_test</li>
<li>test_regression_function(function: dlib._decision_function_sparse_sigmoid, samples: dlib.sparse_vectors, targets: dlib.array) -&gt; regression_test</li>
<li>test_regression_function(function: dlib._decision_function_polynomial, samples: dlib.vectors, targets: dlib.array) -&gt; regression_test</li>
<li>test_regression_function(function: dlib._decision_function_sparse_polynomial, samples: dlib.sparse_vectors, targets: dlib.array) -&gt; regression_test</li>
</ol>
</dd></dl>

<dl class="function">
<dt id="dlib.test_sequence_segmenter">
<code class="descclassname">dlib.</code><code class="descname">test_sequence_segmenter</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.test_sequence_segmenter" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>test_sequence_segmenter(arg0: dlib.segmenter_type, arg1: dlib.vectorss, arg2: dlib.rangess) -&gt; dlib.segmenter_test</li>
<li>test_sequence_segmenter(arg0: dlib.segmenter_type, arg1: dlib.sparse_vectorss, arg2: dlib.rangess) -&gt; dlib.segmenter_test</li>
</ol>
</dd></dl>

<dl class="function">
<dt id="dlib.test_shape_predictor">
<code class="descclassname">dlib.</code><code class="descname">test_shape_predictor</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.test_shape_predictor" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>test_shape_predictor(dataset_filename: unicode, predictor_filename: unicode) -&gt; float</li>
</ol>
<dl class="docutils">
<dt>ensures </dt>
<dd><ul class="first last simple">
<li>Loads an image dataset from dataset_filename.  We assume dataset_filename is 
a file using the XML format written by save_image_dataset_metadata().</li>
<li>Loads a shape_predictor from the file predictor_filename.  This means 
predictor_filename should be a file produced by the train_shape_predictor() 
routine.</li>
<li>This function tests the predictor against the dataset and returns the 
mean average error of the detector.  In fact, The 
return value of this function is identical to that of dlib&#8217;s 
shape_predictor_trainer() routine.  Therefore, see the documentation 
for shape_predictor_trainer() for a detailed definition of the mean average error.</li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li>test_shape_predictor(images: list, detections: list, shape_predictor: dlib.shape_predictor) -&gt; float</li>
</ol>
<dl class="docutils">
<dt>requires </dt>
<dd><blockquote class="first">
<div><ul class="simple">
<li>len(images) == len(object_detections)</li>
<li>images should be a list of numpy matrices that represent images, either RGB or grayscale.</li>
<li>object_detections should be a list of lists of dlib.full_object_detection objects.       Each dlib.full_object_detection contains the bounding box and the lists of points that make up the object parts.</li>
</ul>
</div></blockquote>
<dl class="last docutils">
<dt>ensures </dt>
<dd><ul class="first last simple">
<li>shape_predictor should be a file produced by the train_shape_predictor()  
routine.</li>
<li>This function tests the predictor against the dataset and returns the 
mean average error of the detector.  In fact, The 
return value of this function is identical to that of dlib&#8217;s 
shape_predictor_trainer() routine.  Therefore, see the documentation 
for shape_predictor_trainer() for a detailed definition of the mean average error.</li>
</ul>
</dd>
</dl>
</dd>
</dl>
<ol class="arabic simple" start="3">
<li>test_shape_predictor(images: list, detections: list, scales: list, shape_predictor: dlib.shape_predictor) -&gt; float</li>
</ol>
<dl class="docutils">
<dt>requires </dt>
<dd><blockquote class="first">
<div><ul class="simple">
<li>len(images) == len(object_detections)</li>
<li>len(object_detections) == len(scales)</li>
<li>for every sublist in object_detections: len(object_detections[i]) == len(scales[i])</li>
<li>scales is a list of floating point scales that each predicted part location       should be divided by. Useful for normalization.</li>
<li>images should be a list of numpy matrices that represent images, either RGB or grayscale.</li>
<li>object_detections should be a list of lists of dlib.full_object_detection objects.       Each dlib.full_object_detection contains the bounding box and the lists of points that make up the object parts.</li>
</ul>
</div></blockquote>
<dl class="last docutils">
<dt>ensures </dt>
<dd><ul class="first last simple">
<li>shape_predictor should be a file produced by the train_shape_predictor()  
routine.</li>
<li>This function tests the predictor against the dataset and returns the 
mean average error of the detector.  In fact, The 
return value of this function is identical to that of dlib&#8217;s 
shape_predictor_trainer() routine.  Therefore, see the documentation 
for shape_predictor_trainer() for a detailed definition of the mean average error.</li>
</ul>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="dlib.test_simple_object_detector">
<code class="descclassname">dlib.</code><code class="descname">test_simple_object_detector</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.test_simple_object_detector" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>test_simple_object_detector(dataset_filename: unicode, detector_filename: unicode, upsampling_amount: int=-1L) -&gt; dlib.simple_test_results</li>
</ol>
<dl class="docutils">
<dt>ensures </dt>
<dd><ul class="first last simple">
<li>Loads an image dataset from dataset_filename.  We assume dataset_filename is 
a file using the XML format written by save_image_dataset_metadata().</li>
<li>Loads a simple_object_detector from the file detector_filename.  This means 
detector_filename should be a file produced by the train_simple_object_detector()  
routine.</li>
<li>This function tests the detector against the dataset and returns the 
precision, recall, and average precision of the detector.  In fact, The 
return value of this function is identical to that of dlib&#8217;s 
test_object_detection_function() routine.  Therefore, see the documentation 
for test_object_detection_function() for a detailed definition of these 
metrics.</li>
<li>if upsampling_amount&gt;=0 then we upsample the data by upsampling_amount rather than 
use any upsampling amount that happens to be encoded in the given detector.  If upsampling_amount&lt;0 
then we use the upsampling amount the detector wants to use.</li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li>test_simple_object_detector(dataset_filename: unicode, detector: dlib::simple_object_detector_py, upsampling_amount: int=-1L) -&gt; dlib.simple_test_results</li>
</ol>
<dl class="docutils">
<dt>ensures </dt>
<dd><ul class="first last simple">
<li>Loads an image dataset from dataset_filename.  We assume dataset_filename is 
a file using the XML format written by save_image_dataset_metadata().</li>
<li>Loads a simple_object_detector from the file detector_filename.  This means 
detector_filename should be a file produced by the train_simple_object_detector()  
routine.</li>
<li>This function tests the detector against the dataset and returns the 
precision, recall, and average precision of the detector.  In fact, The 
return value of this function is identical to that of dlib&#8217;s 
test_object_detection_function() routine.  Therefore, see the documentation 
for test_object_detection_function() for a detailed definition of these 
metrics.</li>
<li>if upsampling_amount&gt;=0 then we upsample the data by upsampling_amount rather than 
use any upsampling amount that happens to be encoded in the given detector.  If upsampling_amount&lt;0 
then we use the upsampling amount the detector wants to use.</li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="3">
<li>test_simple_object_detector(images: list, boxes: list, detector: dlib::object_detector&lt;dlib::scan_fhog_pyramid&lt;dlib::pyramid_down&lt;6u&gt;, dlib::default_fhog_feature_extractor&gt; &gt;, upsampling_amount: int=0L) -&gt; dlib.simple_test_results</li>
</ol>
<dl class="docutils">
<dt>requires </dt>
<dd><blockquote class="first">
<div><ul class="simple">
<li>len(images) == len(boxes)</li>
<li>images should be a list of numpy matrices that represent images, either RGB or grayscale.</li>
<li>boxes should be a list of lists of dlib.rectangle object.</li>
<li>Optionally, take the number of times to upsample the testing images (upsampling_amount &gt;= 0).</li>
</ul>
</div></blockquote>
<dl class="last docutils">
<dt>ensures </dt>
<dd><ul class="first last simple">
<li>Loads a simple_object_detector from the file detector_filename.  This means 
detector_filename should be a file produced by the train_simple_object_detector() 
routine.</li>
<li>This function tests the detector against the dataset and returns the 
precision, recall, and average precision of the detector.  In fact, The 
return value of this function is identical to that of dlib&#8217;s 
test_object_detection_function() routine.  Therefore, see the documentation 
for test_object_detection_function() for a detailed definition of these 
metrics.</li>
</ul>
</dd>
</dl>
</dd>
</dl>
<ol class="arabic simple" start="4">
<li>test_simple_object_detector(images: list, boxes: list, detector: dlib::simple_object_detector_py, upsampling_amount: int=-1L) -&gt; dlib.simple_test_results</li>
</ol>
<dl class="docutils">
<dt>requires </dt>
<dd><blockquote class="first">
<div><ul class="simple">
<li>len(images) == len(boxes)</li>
<li>images should be a list of numpy matrices that represent images, either RGB or grayscale.</li>
<li>boxes should be a list of lists of dlib.rectangle object.</li>
</ul>
</div></blockquote>
<dl class="last docutils">
<dt>ensures </dt>
<dd><ul class="first last simple">
<li>Loads a simple_object_detector from the file detector_filename.  This means 
detector_filename should be a file produced by the train_simple_object_detector() 
routine.</li>
<li>This function tests the detector against the dataset and returns the 
precision, recall, and average precision of the detector.  In fact, The 
return value of this function is identical to that of dlib&#8217;s 
test_object_detection_function() routine.  Therefore, see the documentation 
for test_object_detection_function() for a detailed definition of these 
metrics.</li>
</ul>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="dlib.threshold_filter_singular_values">
<code class="descclassname">dlib.</code><code class="descname">threshold_filter_singular_values</code><span class="sig-paren">(</span><em>detector: dlib.simple_object_detector</em>, <em>thresh: float</em><span class="sig-paren">)</span> &rarr; dlib.simple_object_detector<a class="headerlink" href="#dlib.threshold_filter_singular_values" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>requires </dt>
<dd><ul class="first last simple">
<li>thresh &gt;= 0</li>
</ul>
</dd>
<dt>ensures </dt>
<dd><ul class="first last simple">
<li>Removes all components of the filters in the given detector that have 
singular values that are smaller than the given threshold.  Therefore, this 
function allows you to control how many separable filters are in a detector. 
In particular, as thresh gets larger the quantity 
num_separable_filters(threshold_filter_singular_values(detector,thresh)) 
will generally get smaller and therefore give a faster running detector. 
However, note that at some point a large enough thresh will drop too much 
information from the filters and their accuracy will suffer.</li>
<li>returns the updated detector</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="dlib.threshold_image">
<code class="descclassname">dlib.</code><code class="descname">threshold_image</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.threshold_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>threshold_image(img: numpy.ndarray[(rows,cols),uint8]) -&gt; numpy.ndarray[(rows,cols),uint8]</li>
<li>threshold_image(img: numpy.ndarray[(rows,cols),uint16]) -&gt; numpy.ndarray[(rows,cols),uint8]</li>
<li>threshold_image(img: numpy.ndarray[(rows,cols),uint32]) -&gt; numpy.ndarray[(rows,cols),uint8]</li>
<li>threshold_image(img: numpy.ndarray[(rows,cols),float32]) -&gt; numpy.ndarray[(rows,cols),uint8]</li>
<li>threshold_image(img: numpy.ndarray[(rows,cols),float64]) -&gt; numpy.ndarray[(rows,cols),uint8]</li>
<li>threshold_image(img: numpy.ndarray[(rows,cols,3),uint8]) -&gt; numpy.ndarray[(rows,cols),uint8]</li>
</ol>
<p>Thresholds img and returns the result.  Pixels in img with grayscale values &gt;= partition_pixels(img) 
have an output value of 255 and all others have a value of 0.</p>
<ol class="arabic simple" start="7">
<li>threshold_image(img: numpy.ndarray[(rows,cols),uint8], thresh: int) -&gt; numpy.ndarray[(rows,cols),uint8]</li>
<li>threshold_image(img: numpy.ndarray[(rows,cols),uint16], thresh: int) -&gt; numpy.ndarray[(rows,cols),uint8]</li>
<li>threshold_image(img: numpy.ndarray[(rows,cols),uint32], thresh: int) -&gt; numpy.ndarray[(rows,cols),uint8]</li>
<li>threshold_image(img: numpy.ndarray[(rows,cols),float32], thresh: float) -&gt; numpy.ndarray[(rows,cols),uint8]</li>
<li>threshold_image(img: numpy.ndarray[(rows,cols),float64], thresh: float) -&gt; numpy.ndarray[(rows,cols),uint8]</li>
<li>threshold_image(img: numpy.ndarray[(rows,cols,3),uint8], thresh: int) -&gt; numpy.ndarray[(rows,cols),uint8]</li>
</ol>
<p>Thresholds img and returns the result.  Pixels in img with grayscale values &gt;= thresh 
have an output value of 255 and all others have a value of 0.</p>
</dd></dl>

<dl class="function">
<dt id="dlib.tile_images">
<code class="descclassname">dlib.</code><code class="descname">tile_images</code><span class="sig-paren">(</span><em>images: list</em><span class="sig-paren">)</span> &rarr; array<a class="headerlink" href="#dlib.tile_images" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>requires </dt>
<dd><ul class="first last simple">
<li>images is a list of numpy arrays that can be interpreted as images.  They 
must all be the same type of image as well.</li>
</ul>
</dd>
<dt>ensures </dt>
<dd><ul class="first last simple">
<li>This function takes the given images and tiles them into a single large 
square image and returns this new big tiled image.  Therefore, it is a 
useful method to visualize many small images at once.</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="dlib.train_sequence_segmenter">
<code class="descclassname">dlib.</code><code class="descname">train_sequence_segmenter</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.train_sequence_segmenter" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>train_sequence_segmenter(samples: dlib.vectorss, segments: dlib.rangess, params: dlib.segmenter_params=&lt;BIO,highFeats,signed,win=5,threads=4,eps=0.1,cache=40,non-verbose,C=100&gt;) -&gt; dlib.segmenter_type</li>
<li>train_sequence_segmenter(samples: dlib.sparse_vectorss, segments: dlib.rangess, params: dlib.segmenter_params=&lt;BIO,highFeats,signed,win=5,threads=4,eps=0.1,cache=40,non-verbose,C=100&gt;) -&gt; dlib.segmenter_type</li>
</ol>
</dd></dl>

<dl class="function">
<dt id="dlib.train_shape_predictor">
<code class="descclassname">dlib.</code><code class="descname">train_shape_predictor</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.train_shape_predictor" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>train_shape_predictor(images: list, object_detections: list, options: dlib.shape_predictor_training_options) -&gt; dlib.shape_predictor</li>
</ol>
<dl class="docutils">
<dt>requires </dt>
<dd><ul class="first last simple">
<li>options.lambda_param &gt; 0</li>
<li>0 &lt; options.nu &lt;= 1</li>
<li>options.feature_pool_region_padding &gt;= 0</li>
<li>len(images) == len(object_detections)</li>
<li>images should be a list of numpy matrices that represent images, either RGB or grayscale.</li>
<li>object_detections should be a list of lists of dlib.full_object_detection objects.       Each dlib.full_object_detection contains the bounding box and the lists of points that make up the object parts.</li>
</ul>
</dd>
<dt>ensures </dt>
<dd><ul class="first last simple">
<li>Uses dlib&#8217;s shape_predictor_trainer object to train a 
shape_predictor based on the provided labeled images, full_object_detections, and options.</li>
<li>The trained shape_predictor is returned</li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li>train_shape_predictor(dataset_filename: unicode, predictor_output_filename: unicode, options: dlib.shape_predictor_training_options) -&gt; None</li>
</ol>
<dl class="docutils">
<dt>requires </dt>
<dd><ul class="first last simple">
<li>options.lambda_param &gt; 0</li>
<li>0 &lt; options.nu &lt;= 1</li>
<li>options.feature_pool_region_padding &gt;= 0</li>
</ul>
</dd>
<dt>ensures </dt>
<dd><ul class="first last simple">
<li>Uses dlib&#8217;s shape_predictor_trainer to train a 
shape_predictor based on the labeled images in the XML file 
dataset_filename and the provided options.  This function assumes the file dataset_filename is in the 
XML format produced by dlib&#8217;s save_image_dataset_metadata() routine.</li>
<li>The trained shape predictor is serialized to the file predictor_output_filename.</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="dlib.train_simple_object_detector">
<code class="descclassname">dlib.</code><code class="descname">train_simple_object_detector</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.train_simple_object_detector" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>train_simple_object_detector(dataset_filename: unicode, detector_output_filename: unicode, options: dlib.simple_object_detector_training_options) -&gt; None</li>
</ol>
<dl class="docutils">
<dt>requires </dt>
<dd><ul class="first last simple">
<li>options.C &gt; 0</li>
</ul>
</dd>
<dt>ensures </dt>
<dd><ul class="first last simple">
<li>Uses the structural_object_detection_trainer to train a 
simple_object_detector based on the labeled images in the XML file 
dataset_filename.  This function assumes the file dataset_filename is in the 
XML format produced by dlib&#8217;s save_image_dataset_metadata() routine.</li>
<li>This function will apply a reasonable set of default parameters and 
preprocessing techniques to the training procedure for simple_object_detector 
objects.  So the point of this function is to provide you with a very easy 
way to train a basic object detector.</li>
<li>The trained object detector is serialized to the file detector_output_filename.</li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li>train_simple_object_detector(images: list, boxes: list, options: dlib.simple_object_detector_training_options) -&gt; dlib::simple_object_detector_py</li>
</ol>
<dl class="docutils">
<dt>requires </dt>
<dd><ul class="first last simple">
<li>options.C &gt; 0</li>
<li>len(images) == len(boxes)</li>
<li>images should be a list of numpy matrices that represent images, either RGB or grayscale.</li>
<li>boxes should be a list of lists of dlib.rectangle object.</li>
</ul>
</dd>
<dt>ensures </dt>
<dd><ul class="first last simple">
<li>Uses the structural_object_detection_trainer to train a 
simple_object_detector based on the labeled images and bounding boxes.</li>
<li>This function will apply a reasonable set of default parameters and 
preprocessing techniques to the training procedure for simple_object_detector 
objects.  So the point of this function is to provide you with a very easy 
way to train a basic object detector.</li>
<li>The trained object detector is returned.</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="dlib.transform_image">
<code class="descclassname">dlib.</code><code class="descname">transform_image</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.transform_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>transform_image(img: numpy.ndarray[(rows,cols),uint8], map_point: dlib.point_transform_projective, rows: int, columns: int) -&gt; numpy.ndarray[(rows,cols),uint8]</li>
<li>transform_image(img: numpy.ndarray[(rows,cols),uint16], map_point: dlib.point_transform_projective, rows: int, columns: int) -&gt; numpy.ndarray[(rows,cols),uint16]</li>
<li>transform_image(img: numpy.ndarray[(rows,cols),uint32], map_point: dlib.point_transform_projective, rows: int, columns: int) -&gt; numpy.ndarray[(rows,cols),uint32]</li>
<li>transform_image(img: numpy.ndarray[(rows,cols),uint64], map_point: dlib.point_transform_projective, rows: int, columns: int) -&gt; numpy.ndarray[(rows,cols),uint64]</li>
<li>transform_image(img: numpy.ndarray[(rows,cols),int8], map_point: dlib.point_transform_projective, rows: int, columns: int) -&gt; numpy.ndarray[(rows,cols),int8]</li>
<li>transform_image(img: numpy.ndarray[(rows,cols),int16], map_point: dlib.point_transform_projective, rows: int, columns: int) -&gt; numpy.ndarray[(rows,cols),int16]</li>
<li>transform_image(img: numpy.ndarray[(rows,cols),int32], map_point: dlib.point_transform_projective, rows: int, columns: int) -&gt; numpy.ndarray[(rows,cols),int32]</li>
<li>transform_image(img: numpy.ndarray[(rows,cols),int64], map_point: dlib.point_transform_projective, rows: int, columns: int) -&gt; numpy.ndarray[(rows,cols),int64]</li>
<li>transform_image(img: numpy.ndarray[(rows,cols),float32], map_point: dlib.point_transform_projective, rows: int, columns: int) -&gt; numpy.ndarray[(rows,cols),float32]</li>
<li>transform_image(img: numpy.ndarray[(rows,cols),float64], map_point: dlib.point_transform_projective, rows: int, columns: int) -&gt; numpy.ndarray[(rows,cols),float64]</li>
<li>transform_image(img: numpy.ndarray[(rows,cols,3),uint8], map_point: dlib.point_transform_projective, rows: int, columns: int) -&gt; numpy.ndarray[(rows,cols,3),uint8]</li>
</ol>
<dl class="docutils">
<dt>requires </dt>
<dd><ul class="first last simple">
<li>rows &gt; 0</li>
<li>columns &gt; 0</li>
</ul>
</dd>
<dt>ensures </dt>
<dd><ul class="first last simple">
<li>Returns an image that is the given rows by columns in size and contains a 
transformed part of img.  To do this, we interpret map_point as a mapping 
from pixels in the returned image to pixels in the input img.  transform_image()  
uses this mapping and bilinear interpolation to fill the output image with an 
interpolated copy of img.</li>
<li>Any locations in the output image that map to pixels outside img are set to 0.</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="dlib.translate_rect">
<code class="descclassname">dlib.</code><code class="descname">translate_rect</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.translate_rect" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>translate_rect(rect: dlib.rectangle, p: dlib.point) -&gt; dlib.rectangle</li>
</ol>
<blockquote>
<div><dl class="docutils">
<dt>returns rectangle(rect.left()+p.x, rect.top()+p.y, rect.right()+p.x, rect.bottom()+p.y) </dt>
<dd>(i.e. moves the location of the rectangle but doesn&#8217;t change its shape)</dd>
</dl>
</div></blockquote>
<ol class="arabic simple" start="2">
<li>translate_rect(rect: dlib.drectangle, p: dlib.point) -&gt; dlib.drectangle</li>
</ol>
<blockquote>
<div><dl class="docutils">
<dt>returns rectangle(rect.left()+p.x, rect.top()+p.y, rect.right()+p.x, rect.bottom()+p.y) </dt>
<dd>(i.e. moves the location of the rectangle but doesn&#8217;t change its shape)</dd>
</dl>
</div></blockquote>
<ol class="arabic simple" start="3">
<li>translate_rect(rect: dlib.rectangle, p: dlib.dpoint) -&gt; dlib.rectangle</li>
</ol>
<blockquote>
<div><dl class="docutils">
<dt>returns rectangle(rect.left()+p.x, rect.top()+p.y, rect.right()+p.x, rect.bottom()+p.y) </dt>
<dd>(i.e. moves the location of the rectangle but doesn&#8217;t change its shape)</dd>
</dl>
</div></blockquote>
<ol class="arabic simple" start="4">
<li>translate_rect(rect: dlib.drectangle, p: dlib.dpoint) -&gt; dlib.drectangle</li>
</ol>
<blockquote>
<div><dl class="docutils">
<dt>returns rectangle(rect.left()+p.x, rect.top()+p.y, rect.right()+p.x, rect.bottom()+p.y) </dt>
<dd>(i.e. moves the location of the rectangle but doesn&#8217;t change its shape)</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="class">
<dt id="dlib.vector">
<em class="property">class </em><code class="descclassname">dlib.</code><code class="descname">vector</code><a class="headerlink" href="#dlib.vector" title="Permalink to this definition">¶</a></dt>
<dd><p>This object represents the mathematical idea of a column vector.</p>
<dl class="method">
<dt id="dlib.vector.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.vector.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: dlib.vector) -&gt; None</li>
<li>__init__(self: dlib.vector, arg0: object) -&gt; None</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="dlib.vector.resize">
<code class="descname">resize</code><span class="sig-paren">(</span><em>self: dlib.vector</em>, <em>arg0: int</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.vector.resize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dlib.vector.set_size">
<code class="descname">set_size</code><span class="sig-paren">(</span><em>self: dlib.vector</em>, <em>arg0: int</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.vector.set_size" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.vector.shape">
<code class="descname">shape</code><a class="headerlink" href="#dlib.vector.shape" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="dlib.vectors">
<em class="property">class </em><code class="descclassname">dlib.</code><code class="descname">vectors</code><a class="headerlink" href="#dlib.vectors" title="Permalink to this definition">¶</a></dt>
<dd><p>This object is an array of vector objects.</p>
<dl class="method">
<dt id="dlib.vectors.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.vectors.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: dlib.vectors) -&gt; None</li>
<li>__init__(self: dlib.vectors, arg0: dlib.vectors) -&gt; None</li>
</ol>
<p>Copy constructor</p>
<ol class="arabic simple" start="3">
<li>__init__(self: dlib.vectors, arg0: iterable) -&gt; None</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="dlib.vectors.append">
<code class="descname">append</code><span class="sig-paren">(</span><em>self: dlib.vectors</em>, <em>x: dlib.vector</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.vectors.append" title="Permalink to this definition">¶</a></dt>
<dd><p>Add an item to the end of the list</p>
</dd></dl>

<dl class="method">
<dt id="dlib.vectors.clear">
<code class="descname">clear</code><span class="sig-paren">(</span><em>self: dlib.vectors</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.vectors.clear" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dlib.vectors.count">
<code class="descname">count</code><span class="sig-paren">(</span><em>self: dlib.vectors</em>, <em>x: dlib.vector</em><span class="sig-paren">)</span> &rarr; int<a class="headerlink" href="#dlib.vectors.count" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of times <code class="docutils literal"><span class="pre">x</span></code> appears in the list</p>
</dd></dl>

<dl class="method">
<dt id="dlib.vectors.extend">
<code class="descname">extend</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.vectors.extend" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>extend(self: dlib.vectors, L: dlib.vectors) -&gt; None</li>
</ol>
<p>Extend the list by appending all the items in the given list</p>
<ol class="arabic simple" start="2">
<li>extend(self: dlib.vectors, arg0: list) -&gt; None</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="dlib.vectors.insert">
<code class="descname">insert</code><span class="sig-paren">(</span><em>self: dlib.vectors</em>, <em>i: int</em>, <em>x: dlib.vector</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.vectors.insert" title="Permalink to this definition">¶</a></dt>
<dd><p>Insert an item at a given position.</p>
</dd></dl>

<dl class="method">
<dt id="dlib.vectors.pop">
<code class="descname">pop</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.vectors.pop" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>pop(self: dlib.vectors) -&gt; dlib.vector</li>
</ol>
<p>Remove and return the last item</p>
<ol class="arabic simple" start="2">
<li>pop(self: dlib.vectors, i: int) -&gt; dlib.vector</li>
</ol>
<p>Remove and return the item at index <code class="docutils literal"><span class="pre">i</span></code></p>
</dd></dl>

<dl class="method">
<dt id="dlib.vectors.remove">
<code class="descname">remove</code><span class="sig-paren">(</span><em>self: dlib.vectors</em>, <em>x: dlib.vector</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.vectors.remove" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove the first item from the list whose value is x. It is an error if there is no such item.</p>
</dd></dl>

<dl class="method">
<dt id="dlib.vectors.resize">
<code class="descname">resize</code><span class="sig-paren">(</span><em>self: dlib.vectors</em>, <em>arg0: int</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.vectors.resize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="dlib.vectorss">
<em class="property">class </em><code class="descclassname">dlib.</code><code class="descname">vectorss</code><a class="headerlink" href="#dlib.vectorss" title="Permalink to this definition">¶</a></dt>
<dd><p>This object is an array of arrays of vector objects.</p>
<dl class="method">
<dt id="dlib.vectorss.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.vectorss.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: dlib.vectorss) -&gt; None</li>
<li>__init__(self: dlib.vectorss, arg0: dlib.vectorss) -&gt; None</li>
</ol>
<p>Copy constructor</p>
<ol class="arabic simple" start="3">
<li>__init__(self: dlib.vectorss, arg0: iterable) -&gt; None</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="dlib.vectorss.append">
<code class="descname">append</code><span class="sig-paren">(</span><em>self: dlib.vectorss</em>, <em>x: dlib.vectors</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.vectorss.append" title="Permalink to this definition">¶</a></dt>
<dd><p>Add an item to the end of the list</p>
</dd></dl>

<dl class="method">
<dt id="dlib.vectorss.clear">
<code class="descname">clear</code><span class="sig-paren">(</span><em>self: dlib.vectorss</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.vectorss.clear" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dlib.vectorss.count">
<code class="descname">count</code><span class="sig-paren">(</span><em>self: dlib.vectorss</em>, <em>x: dlib.vectors</em><span class="sig-paren">)</span> &rarr; int<a class="headerlink" href="#dlib.vectorss.count" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of times <code class="docutils literal"><span class="pre">x</span></code> appears in the list</p>
</dd></dl>

<dl class="method">
<dt id="dlib.vectorss.extend">
<code class="descname">extend</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.vectorss.extend" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>extend(self: dlib.vectorss, L: dlib.vectorss) -&gt; None</li>
</ol>
<p>Extend the list by appending all the items in the given list</p>
<ol class="arabic simple" start="2">
<li>extend(self: dlib.vectorss, arg0: list) -&gt; None</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="dlib.vectorss.insert">
<code class="descname">insert</code><span class="sig-paren">(</span><em>self: dlib.vectorss</em>, <em>i: int</em>, <em>x: dlib.vectors</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.vectorss.insert" title="Permalink to this definition">¶</a></dt>
<dd><p>Insert an item at a given position.</p>
</dd></dl>

<dl class="method">
<dt id="dlib.vectorss.pop">
<code class="descname">pop</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.vectorss.pop" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>pop(self: dlib.vectorss) -&gt; dlib.vectors</li>
</ol>
<p>Remove and return the last item</p>
<ol class="arabic simple" start="2">
<li>pop(self: dlib.vectorss, i: int) -&gt; dlib.vectors</li>
</ol>
<p>Remove and return the item at index <code class="docutils literal"><span class="pre">i</span></code></p>
</dd></dl>

<dl class="method">
<dt id="dlib.vectorss.remove">
<code class="descname">remove</code><span class="sig-paren">(</span><em>self: dlib.vectorss</em>, <em>x: dlib.vectors</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.vectorss.remove" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove the first item from the list whose value is x. It is an error if there is no such item.</p>
</dd></dl>

<dl class="method">
<dt id="dlib.vectorss.resize">
<code class="descname">resize</code><span class="sig-paren">(</span><em>self: dlib.vectorss</em>, <em>arg0: int</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.vectorss.resize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="dlib.zero_border_pixels">
<code class="descclassname">dlib.</code><code class="descname">zero_border_pixels</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.zero_border_pixels" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>zero_border_pixels(img: numpy.ndarray[(rows,cols),uint8], x_border_size: int, y_border_size: int) -&gt; None</li>
<li>zero_border_pixels(img: numpy.ndarray[(rows,cols),uint16], x_border_size: int, y_border_size: int) -&gt; None</li>
<li>zero_border_pixels(img: numpy.ndarray[(rows,cols),uint32], x_border_size: int, y_border_size: int) -&gt; None</li>
<li>zero_border_pixels(img: numpy.ndarray[(rows,cols),uint64], x_border_size: int, y_border_size: int) -&gt; None</li>
<li>zero_border_pixels(img: numpy.ndarray[(rows,cols),int8], x_border_size: int, y_border_size: int) -&gt; None</li>
<li>zero_border_pixels(img: numpy.ndarray[(rows,cols),int16], x_border_size: int, y_border_size: int) -&gt; None</li>
<li>zero_border_pixels(img: numpy.ndarray[(rows,cols),int32], x_border_size: int, y_border_size: int) -&gt; None</li>
<li>zero_border_pixels(img: numpy.ndarray[(rows,cols),int64], x_border_size: int, y_border_size: int) -&gt; None</li>
<li>zero_border_pixels(img: numpy.ndarray[(rows,cols),float32], x_border_size: int, y_border_size: int) -&gt; None</li>
<li>zero_border_pixels(img: numpy.ndarray[(rows,cols),float64], x_border_size: int, y_border_size: int) -&gt; None</li>
<li>zero_border_pixels(img: numpy.ndarray[(rows,cols,3),uint8], x_border_size: int, y_border_size: int) -&gt; None</li>
</ol>
<dl class="docutils">
<dt>requires </dt>
<dd><ul class="first last simple">
<li>x_border_size &gt;= 0</li>
<li>y_border_size &gt;= 0</li>
</ul>
</dd>
<dt>ensures </dt>
<dd><ul class="first last">
<li><p class="first">The size and shape of img isn&#8217;t changed by this function.</p>
</li>
<li><dl class="first docutils">
<dt>for all valid r such that r+y_border_size or r-y_border_size gives an invalid row </dt>
<dd><ul class="first last">
<li><dl class="first docutils">
<dt>for all valid c such that c+x_border_size or c-x_border_size gives an invalid column  </dt>
<dd><ul class="first last simple">
<li>assigns the pixel img[r][c] to 0.  
(i.e. assigns 0 to every pixel in the border of img)</li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="12">
<li>zero_border_pixels(img: numpy.ndarray[(rows,cols),uint8], inside: dlib.rectangle) -&gt; None</li>
<li>zero_border_pixels(img: numpy.ndarray[(rows,cols),uint16], inside: dlib.rectangle) -&gt; None</li>
<li>zero_border_pixels(img: numpy.ndarray[(rows,cols),uint32], inside: dlib.rectangle) -&gt; None</li>
<li>zero_border_pixels(img: numpy.ndarray[(rows,cols),uint64], inside: dlib.rectangle) -&gt; None</li>
<li>zero_border_pixels(img: numpy.ndarray[(rows,cols),int8], inside: dlib.rectangle) -&gt; None</li>
<li>zero_border_pixels(img: numpy.ndarray[(rows,cols),int16], inside: dlib.rectangle) -&gt; None</li>
<li>zero_border_pixels(img: numpy.ndarray[(rows,cols),int32], inside: dlib.rectangle) -&gt; None</li>
<li>zero_border_pixels(img: numpy.ndarray[(rows,cols),int64], inside: dlib.rectangle) -&gt; None</li>
<li>zero_border_pixels(img: numpy.ndarray[(rows,cols),float32], inside: dlib.rectangle) -&gt; None</li>
<li>zero_border_pixels(img: numpy.ndarray[(rows,cols),float64], inside: dlib.rectangle) -&gt; None</li>
<li>zero_border_pixels(img: numpy.ndarray[(rows,cols,3),uint8], inside: dlib.rectangle) -&gt; None</li>
</ol>
<dl class="docutils">
<dt>ensures </dt>
<dd><ul class="first last simple">
<li>The size and shape of img isn&#8217;t changed by this function.</li>
<li>All the pixels in img that are not contained inside the inside rectangle 
given to this function are set to 0.  That is, anything not &#8220;inside&#8221; is on 
the border and set to 0.</li>
</ul>
</dd>
</dl>
</dd></dl>

<span class="target" id="module-dlib.cuda"></span><p>Routines for setting CUDA specific properties.</p>
<dl class="function">
<dt id="dlib.cuda.get_device">
<code class="descclassname">dlib.cuda.</code><code class="descname">get_device</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &rarr; int<a class="headerlink" href="#dlib.cuda.get_device" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the active CUDA device.</p>
</dd></dl>

<dl class="function">
<dt id="dlib.cuda.get_num_devices">
<code class="descclassname">dlib.cuda.</code><code class="descname">get_num_devices</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &rarr; int<a class="headerlink" href="#dlib.cuda.get_num_devices" title="Permalink to this definition">¶</a></dt>
<dd><p>Find out how many CUDA devices are available.</p>
</dd></dl>

<dl class="function">
<dt id="dlib.cuda.set_device">
<code class="descclassname">dlib.cuda.</code><code class="descname">set_device</code><span class="sig-paren">(</span><em>device_id: int</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.cuda.set_device" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the active CUDA device.  It is required that 0 &lt;= device_id &lt; get_num_devices().</p>
</dd></dl>

<span class="target" id="module-dlib.image_dataset_metadata"></span><p>Routines and objects for working with dlib&#8217;s image dataset metadata XML files.</p>
<dl class="class">
<dt id="dlib.image_dataset_metadata.box">
<em class="property">class </em><code class="descclassname">dlib.image_dataset_metadata.</code><code class="descname">box</code><a class="headerlink" href="#dlib.image_dataset_metadata.box" title="Permalink to this definition">¶</a></dt>
<dd><p>This object represents an annotated rectangular area of an image. 
It is typically used to mark the location of an object such as a 
person, car, etc.</p>
<p>The main variable of interest is rect.  It gives the location of 
the box.  All the other variables are optional.</p>
<dl class="attribute">
<dt id="dlib.image_dataset_metadata.box.FEMALE">
<code class="descname">FEMALE</code><em class="property"> = gender_type.FEMALE</em><a class="headerlink" href="#dlib.image_dataset_metadata.box.FEMALE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.image_dataset_metadata.box.MALE">
<code class="descname">MALE</code><em class="property"> = gender_type.MALE</em><a class="headerlink" href="#dlib.image_dataset_metadata.box.MALE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.image_dataset_metadata.box.UNKNOWN">
<code class="descname">UNKNOWN</code><em class="property"> = gender_type.UNKNOWN</em><a class="headerlink" href="#dlib.image_dataset_metadata.box.UNKNOWN" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dlib.image_dataset_metadata.box.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: dlib.image_dataset_metadata.box</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.image_dataset_metadata.box.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.image_dataset_metadata.box.age">
<code class="descname">age</code><a class="headerlink" href="#dlib.image_dataset_metadata.box.age" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.image_dataset_metadata.box.angle">
<code class="descname">angle</code><a class="headerlink" href="#dlib.image_dataset_metadata.box.angle" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.image_dataset_metadata.box.detection_score">
<code class="descname">detection_score</code><a class="headerlink" href="#dlib.image_dataset_metadata.box.detection_score" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.image_dataset_metadata.box.difficult">
<code class="descname">difficult</code><a class="headerlink" href="#dlib.image_dataset_metadata.box.difficult" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.image_dataset_metadata.box.gender">
<code class="descname">gender</code><a class="headerlink" href="#dlib.image_dataset_metadata.box.gender" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="dlib.image_dataset_metadata.box.gender_type">
<em class="property">class </em><code class="descname">gender_type</code><a class="headerlink" href="#dlib.image_dataset_metadata.box.gender_type" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="dlib.image_dataset_metadata.box.gender_type.FEMALE">
<code class="descname">FEMALE</code><em class="property"> = gender_type.FEMALE</em><a class="headerlink" href="#dlib.image_dataset_metadata.box.gender_type.FEMALE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.image_dataset_metadata.box.gender_type.MALE">
<code class="descname">MALE</code><em class="property"> = gender_type.MALE</em><a class="headerlink" href="#dlib.image_dataset_metadata.box.gender_type.MALE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.image_dataset_metadata.box.gender_type.UNKNOWN">
<code class="descname">UNKNOWN</code><em class="property"> = gender_type.UNKNOWN</em><a class="headerlink" href="#dlib.image_dataset_metadata.box.gender_type.UNKNOWN" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dlib.image_dataset_metadata.box.gender_type.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: dlib.image_dataset_metadata.box.gender_type</em>, <em>arg0: int</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.image_dataset_metadata.box.gender_type.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="dlib.image_dataset_metadata.box.ignore">
<code class="descclassname">box.</code><code class="descname">ignore</code><a class="headerlink" href="#dlib.image_dataset_metadata.box.ignore" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.image_dataset_metadata.box.label">
<code class="descclassname">box.</code><code class="descname">label</code><a class="headerlink" href="#dlib.image_dataset_metadata.box.label" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.image_dataset_metadata.box.occluded">
<code class="descclassname">box.</code><code class="descname">occluded</code><a class="headerlink" href="#dlib.image_dataset_metadata.box.occluded" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.image_dataset_metadata.box.parts">
<code class="descclassname">box.</code><code class="descname">parts</code><a class="headerlink" href="#dlib.image_dataset_metadata.box.parts" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.image_dataset_metadata.box.pose">
<code class="descclassname">box.</code><code class="descname">pose</code><a class="headerlink" href="#dlib.image_dataset_metadata.box.pose" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.image_dataset_metadata.box.rect">
<code class="descclassname">box.</code><code class="descname">rect</code><a class="headerlink" href="#dlib.image_dataset_metadata.box.rect" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.image_dataset_metadata.box.truncated">
<code class="descclassname">box.</code><code class="descname">truncated</code><a class="headerlink" href="#dlib.image_dataset_metadata.box.truncated" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="dlib.image_dataset_metadata.boxes">
<em class="property">class </em><code class="descclassname">dlib.image_dataset_metadata.</code><code class="descname">boxes</code><a class="headerlink" href="#dlib.image_dataset_metadata.boxes" title="Permalink to this definition">¶</a></dt>
<dd><p>An array of dlib::image_dataset_metadata::box objects.</p>
<dl class="method">
<dt id="dlib.image_dataset_metadata.boxes.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.image_dataset_metadata.boxes.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: dlib.image_dataset_metadata.boxes) -&gt; None</li>
<li>__init__(self: dlib.image_dataset_metadata.boxes, arg0: dlib.image_dataset_metadata.boxes) -&gt; None</li>
</ol>
<p>Copy constructor</p>
<ol class="arabic simple" start="3">
<li>__init__(self: dlib.image_dataset_metadata.boxes, arg0: iterable) -&gt; None</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="dlib.image_dataset_metadata.boxes.append">
<code class="descname">append</code><span class="sig-paren">(</span><em>self: dlib.image_dataset_metadata.boxes</em>, <em>x: dlib.image_dataset_metadata.box</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.image_dataset_metadata.boxes.append" title="Permalink to this definition">¶</a></dt>
<dd><p>Add an item to the end of the list</p>
</dd></dl>

<dl class="method">
<dt id="dlib.image_dataset_metadata.boxes.extend">
<code class="descname">extend</code><span class="sig-paren">(</span><em>self: dlib.image_dataset_metadata.boxes</em>, <em>L: dlib.image_dataset_metadata.boxes</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.image_dataset_metadata.boxes.extend" title="Permalink to this definition">¶</a></dt>
<dd><p>Extend the list by appending all the items in the given list</p>
</dd></dl>

<dl class="method">
<dt id="dlib.image_dataset_metadata.boxes.insert">
<code class="descname">insert</code><span class="sig-paren">(</span><em>self: dlib.image_dataset_metadata.boxes</em>, <em>i: int</em>, <em>x: dlib.image_dataset_metadata.box</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.image_dataset_metadata.boxes.insert" title="Permalink to this definition">¶</a></dt>
<dd><p>Insert an item at a given position.</p>
</dd></dl>

<dl class="method">
<dt id="dlib.image_dataset_metadata.boxes.pop">
<code class="descname">pop</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.image_dataset_metadata.boxes.pop" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>pop(self: dlib.image_dataset_metadata.boxes) -&gt; dlib.image_dataset_metadata.box</li>
</ol>
<p>Remove and return the last item</p>
<ol class="arabic simple" start="2">
<li>pop(self: dlib.image_dataset_metadata.boxes, i: int) -&gt; dlib.image_dataset_metadata.box</li>
</ol>
<p>Remove and return the item at index <code class="docutils literal"><span class="pre">i</span></code></p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="dlib.image_dataset_metadata.dataset">
<em class="property">class </em><code class="descclassname">dlib.image_dataset_metadata.</code><code class="descname">dataset</code><a class="headerlink" href="#dlib.image_dataset_metadata.dataset" title="Permalink to this definition">¶</a></dt>
<dd><p>This object represents a labeled set of images.  In particular, it contains the filename for each image as well as annotated boxes.</p>
<dl class="method">
<dt id="dlib.image_dataset_metadata.dataset.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: dlib.image_dataset_metadata.dataset</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.image_dataset_metadata.dataset.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.image_dataset_metadata.dataset.comment">
<code class="descname">comment</code><a class="headerlink" href="#dlib.image_dataset_metadata.dataset.comment" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.image_dataset_metadata.dataset.images">
<code class="descname">images</code><a class="headerlink" href="#dlib.image_dataset_metadata.dataset.images" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.image_dataset_metadata.dataset.name">
<code class="descname">name</code><a class="headerlink" href="#dlib.image_dataset_metadata.dataset.name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="dlib.image_dataset_metadata.image">
<em class="property">class </em><code class="descclassname">dlib.image_dataset_metadata.</code><code class="descname">image</code><a class="headerlink" href="#dlib.image_dataset_metadata.image" title="Permalink to this definition">¶</a></dt>
<dd><p>This object represents an annotated image.</p>
<dl class="method">
<dt id="dlib.image_dataset_metadata.image.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: dlib.image_dataset_metadata.image</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.image_dataset_metadata.image.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.image_dataset_metadata.image.boxes">
<code class="descname">boxes</code><a class="headerlink" href="#dlib.image_dataset_metadata.image.boxes" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="dlib.image_dataset_metadata.image.filename">
<code class="descname">filename</code><a class="headerlink" href="#dlib.image_dataset_metadata.image.filename" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="dlib.image_dataset_metadata.images">
<em class="property">class </em><code class="descclassname">dlib.image_dataset_metadata.</code><code class="descname">images</code><a class="headerlink" href="#dlib.image_dataset_metadata.images" title="Permalink to this definition">¶</a></dt>
<dd><p>An array of dlib::image_dataset_metadata::image objects.</p>
<dl class="method">
<dt id="dlib.image_dataset_metadata.images.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.image_dataset_metadata.images.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: dlib.image_dataset_metadata.images) -&gt; None</li>
<li>__init__(self: dlib.image_dataset_metadata.images, arg0: dlib.image_dataset_metadata.images) -&gt; None</li>
</ol>
<p>Copy constructor</p>
<ol class="arabic simple" start="3">
<li>__init__(self: dlib.image_dataset_metadata.images, arg0: iterable) -&gt; None</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="dlib.image_dataset_metadata.images.append">
<code class="descname">append</code><span class="sig-paren">(</span><em>self: dlib.image_dataset_metadata.images</em>, <em>x: dlib.image_dataset_metadata.image</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.image_dataset_metadata.images.append" title="Permalink to this definition">¶</a></dt>
<dd><p>Add an item to the end of the list</p>
</dd></dl>

<dl class="method">
<dt id="dlib.image_dataset_metadata.images.extend">
<code class="descname">extend</code><span class="sig-paren">(</span><em>self: dlib.image_dataset_metadata.images</em>, <em>L: dlib.image_dataset_metadata.images</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.image_dataset_metadata.images.extend" title="Permalink to this definition">¶</a></dt>
<dd><p>Extend the list by appending all the items in the given list</p>
</dd></dl>

<dl class="method">
<dt id="dlib.image_dataset_metadata.images.insert">
<code class="descname">insert</code><span class="sig-paren">(</span><em>self: dlib.image_dataset_metadata.images</em>, <em>i: int</em>, <em>x: dlib.image_dataset_metadata.image</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.image_dataset_metadata.images.insert" title="Permalink to this definition">¶</a></dt>
<dd><p>Insert an item at a given position.</p>
</dd></dl>

<dl class="method">
<dt id="dlib.image_dataset_metadata.images.pop">
<code class="descname">pop</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.image_dataset_metadata.images.pop" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>pop(self: dlib.image_dataset_metadata.images) -&gt; dlib.image_dataset_metadata.image</li>
</ol>
<p>Remove and return the last item</p>
<ol class="arabic simple" start="2">
<li>pop(self: dlib.image_dataset_metadata.images, i: int) -&gt; dlib.image_dataset_metadata.image</li>
</ol>
<p>Remove and return the item at index <code class="docutils literal"><span class="pre">i</span></code></p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="dlib.image_dataset_metadata.load_image_dataset_metadata">
<code class="descclassname">dlib.image_dataset_metadata.</code><code class="descname">load_image_dataset_metadata</code><span class="sig-paren">(</span><em>filename: unicode</em><span class="sig-paren">)</span> &rarr; dlib.image_dataset_metadata.dataset<a class="headerlink" href="#dlib.image_dataset_metadata.load_image_dataset_metadata" title="Permalink to this definition">¶</a></dt>
<dd><p>Attempts to interpret filename as a file containing XML formatted data as produced by the save_image_dataset_metadata() function.  The data is loaded and returned as a dlib.image_dataset_metadata.dataset object.</p>
</dd></dl>

<dl class="class">
<dt id="dlib.image_dataset_metadata.parts">
<em class="property">class </em><code class="descclassname">dlib.image_dataset_metadata.</code><code class="descname">parts</code><a class="headerlink" href="#dlib.image_dataset_metadata.parts" title="Permalink to this definition">¶</a></dt>
<dd><p>This object is a dictionary mapping string names to object part locations.</p>
<dl class="method">
<dt id="dlib.image_dataset_metadata.parts.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dlib.image_dataset_metadata.parts.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: dlib.image_dataset_metadata.parts) -&gt; None</li>
<li>__init__(self: dlib.image_dataset_metadata.parts, arg0: dict) -&gt; None</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="dlib.image_dataset_metadata.parts.items">
<code class="descname">items</code><span class="sig-paren">(</span><em>self: dlib.image_dataset_metadata.parts</em><span class="sig-paren">)</span> &rarr; iterator<a class="headerlink" href="#dlib.image_dataset_metadata.parts.items" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="dlib.image_dataset_metadata.save_image_dataset_metadata">
<code class="descclassname">dlib.image_dataset_metadata.</code><code class="descname">save_image_dataset_metadata</code><span class="sig-paren">(</span><em>data: dlib.image_dataset_metadata.dataset</em>, <em>filename: unicode</em><span class="sig-paren">)</span> &rarr; None<a class="headerlink" href="#dlib.image_dataset_metadata.save_image_dataset_metadata" title="Permalink to this definition">¶</a></dt>
<dd><p>Writes the contents of the meta object to a file with the given filename.  The file will be in an XML format.</p>
</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="#">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Classes</a></li>
<li><a class="reference internal" href="#functions">Functions</a></li>
<li><a class="reference internal" href="#detailed-api-listing">Detailed API Listing</a></li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/index.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="#">dlib  documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2013, Davis E. King.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.6.
    </div>
  </body>
</html>